import { LegoProvingKey } from './legosnark';
export declare function isEmptyObject(obj: any): boolean;
export declare function jsonObjToUint8Array(json: string): Uint8Array;
export declare function getUint8ArraysFromObject(obj: Record<string, unknown>, keys: string[]): Uint8Array[];
export declare function bytesToChallenge(bytes: Uint8Array): Uint8Array;
export declare function isNumberBiggerThanNBits(num: number, bits: number): boolean;
/**
 * Throws an error if the given number takes more bits than expected.
 * @param num
 * @param size - expected size in bits
 */
export declare function ensurePositiveIntegerOfSize(num: number, size: number): void;
export declare function randomFieldElement(seed?: Uint8Array): Uint8Array;
/**
 * Takes an object, nested or otherwise and flattens it to list. Returns 2 arrays, 1st array contains keys in alphabetical
 * sorted order and 2nd contains the values in the order of the keys. Both arrays have same size. Nested keys have their
 * parent key name prefixed with a dot, eg for key `lat` in `{location: {lat: 25.01, long: 30.02} }`, it becomes `location.lat`
 * @param obj
 * @param flattenOptions
 */
export declare function flattenObjectToKeyValuesList(obj: object, flattenOptions?: undefined): [string[], unknown[]];
export declare function isPositiveInteger(n: unknown): boolean;
export declare function bytearrayToHex(b: Uint8Array): string;
export declare function areArraysEqual(arr1: string[] | number[] | boolean[], arr2: string[] | number[] | boolean[]): boolean;
export declare function getProvingAndVerifiyingKeyBytes(provingKey: LegoProvingKey, returnUncompressed: boolean): [Uint8Array, Uint8Array];
//# sourceMappingURL=util.d.ts.map