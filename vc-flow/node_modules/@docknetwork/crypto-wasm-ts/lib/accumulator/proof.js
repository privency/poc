"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NonMembershipProof = exports.MembershipProof = exports.NonMembershipProofProtocol = exports.MembershipProofProtocol = void 0;
const crypto_wasm_1 = require("@docknetwork/crypto-wasm");
const bytearray_wrapper_1 = require("../bytearray-wrapper");
class MembershipProofProtocol extends bytearray_wrapper_1.BytearrayWrapper {
    static initialize(member, witness, publicKey, params, provingKey, blinding) {
        const b = blinding === undefined ? (0, crypto_wasm_1.generateRandomFieldElement)() : blinding;
        const protocol = (0, crypto_wasm_1.accumulatorInitializeMembershipProof)(member, b, witness.value, publicKey.value, params.value, provingKey.value);
        return new MembershipProofProtocol(protocol);
    }
    generateProof(challenge) {
        const proof = (0, crypto_wasm_1.accumulatorGenMembershipProof)(this.value, challenge);
        return new MembershipProof(proof);
    }
    challengeContribution(accumulated, publicKey, params, provingKey) {
        return (0, crypto_wasm_1.accumulatorChallengeContributionFromMembershipProtocol)(this.value, accumulated, publicKey.value, params.value, provingKey.value);
    }
}
exports.MembershipProofProtocol = MembershipProofProtocol;
class NonMembershipProofProtocol extends bytearray_wrapper_1.BytearrayWrapper {
    static initialize(nonMember, witness, publicKey, params, provingKey, blinding) {
        const b = blinding === undefined ? (0, crypto_wasm_1.generateRandomFieldElement)() : blinding;
        const protocol = (0, crypto_wasm_1.accumulatorInitializeNonMembershipProof)(nonMember, b, witness.value, publicKey.value, params.value, provingKey.value);
        return new MembershipProofProtocol(protocol);
    }
    generateProof(challenge) {
        const proof = (0, crypto_wasm_1.accumulatorGenNonMembershipProof)(this.value, challenge);
        return new NonMembershipProof(proof);
    }
    challengeContribution(accumulated, publicKey, params, provingKey) {
        return (0, crypto_wasm_1.accumulatorChallengeContributionFromNonMembershipProtocol)(this.value, accumulated, publicKey.value, params.value, provingKey.value);
    }
}
exports.NonMembershipProofProtocol = NonMembershipProofProtocol;
class MembershipProof extends bytearray_wrapper_1.BytearrayWrapper {
    verify(accumulated, challenge, publicKey, params, provingKey) {
        return (0, crypto_wasm_1.accumulatorVerifyMembershipProof)(this.value, accumulated, challenge, publicKey.value, params.value, provingKey.value);
    }
    challengeContribution(accumulated, publicKey, params, provingKey) {
        return (0, crypto_wasm_1.accumulatorChallengeContributionFromMembershipProof)(this.value, accumulated, publicKey.value, params.value, provingKey.value);
    }
}
exports.MembershipProof = MembershipProof;
class NonMembershipProof extends bytearray_wrapper_1.BytearrayWrapper {
    verify(accumulated, challenge, publicKey, params, provingKey) {
        return (0, crypto_wasm_1.accumulatorVerifyNonMembershipProof)(this.value, accumulated, challenge, publicKey.value, params.value, provingKey.value);
    }
    challengeContribution(accumulated, publicKey, params, provingKey) {
        return (0, crypto_wasm_1.accumulatorChallengeContributionFromNonMembershipProof)(this.value, accumulated, publicKey.value, params.value, provingKey.value);
    }
}
exports.NonMembershipProof = NonMembershipProof;
//# sourceMappingURL=proof.js.map