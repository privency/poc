"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NonMembershipProvingKey = exports.MembershipProvingKey = exports.AccumulatorKeypair = exports.AccumulatorPublicKey = exports.AccumulatorSecretKey = exports.AccumulatorParams = void 0;
const bytearray_wrapper_1 = require("../bytearray-wrapper");
const crypto_wasm_1 = require("@docknetwork/crypto-wasm");
class AccumulatorParams extends bytearray_wrapper_1.BytearrayWrapper {
    /**
     *  Generate accumulator parameters. They are needed to generate public key and initialize the accumulator.
     * @param label - Pass to generate parameters deterministically.
     * @returns
     */
    static generate(label) {
        return new AccumulatorParams((0, crypto_wasm_1.generateAccumulatorParams)(label));
    }
    /**
     * Check if parameters are valid. Before verifying witness or using for proof verification,
     * make sure the params are valid.
     * @returns true if key is valid, false otherwise
     */
    isValid() {
        return (0, crypto_wasm_1.isAccumulatorParamsValid)(this.value);
    }
}
exports.AccumulatorParams = AccumulatorParams;
class AccumulatorSecretKey extends bytearray_wrapper_1.BytearrayWrapper {
    /**
     * Generate secret key for the accumulator manager who updates the accumulator and creates witnesses.
     * @param seed - Pass to generate key deterministically.
     * @returns
     */
    static generate(seed) {
        return new AccumulatorSecretKey((0, crypto_wasm_1.generateAccumulatorSecretKey)(seed));
    }
    /**
     * Generate public key from given params and secret key.
     * @param params
     * @returns
     */
    generatePublicKey(params) {
        return new AccumulatorPublicKey((0, crypto_wasm_1.generateAccumulatorPublicKey)(this.value, params.value));
    }
}
exports.AccumulatorSecretKey = AccumulatorSecretKey;
class AccumulatorPublicKey extends bytearray_wrapper_1.BytearrayWrapper {
    static generate(secretKey, params) {
        return secretKey.generatePublicKey(params);
    }
    /**
     * Check if public key is valid. Before verifying witness or using for proof verification,
     * make sure the public key is valid.
     * @returns true if key is valid, false otherwise
     */
    isValid() {
        return (0, crypto_wasm_1.isAccumulatorPublicKeyValid)(this.value);
    }
}
exports.AccumulatorPublicKey = AccumulatorPublicKey;
class AccumulatorKeypair {
    constructor(sk, pk) {
        this.sk = sk;
        this.pk = pk;
    }
    static generate(params, seed) {
        const keypair = (0, crypto_wasm_1.generateAccumulatorKeyPair)(params.value, seed);
        return new AccumulatorKeypair(new AccumulatorSecretKey(keypair.secret_key), new AccumulatorPublicKey(keypair.public_key));
    }
    get secretKey() {
        return this.sk;
    }
    get publicKey() {
        return this.pk;
    }
}
exports.AccumulatorKeypair = AccumulatorKeypair;
/**
 * Generate proving key for proving membership in an accumulator in zero knowledge. Proving key is
 * public data that must be known to both the prover and verifier. Any prover and verifier pair can mutually agree
 * on a proving key and the manager does not need to be aware of any proving key.
 * @param label - The bytearray that is hashed to deterministically generate the proving key.
 */
class MembershipProvingKey extends bytearray_wrapper_1.BytearrayWrapper {
    static generate(label) {
        return new MembershipProvingKey((0, crypto_wasm_1.generateMembershipProvingKey)(label));
    }
}
exports.MembershipProvingKey = MembershipProvingKey;
/**
 * Generate proving key for proving non-membership in a universal accumulator in zero knowledge.
 * @param label - The bytearray that is hashed to deterministically generate the proving key.
 */
class NonMembershipProvingKey extends bytearray_wrapper_1.BytearrayWrapper {
    static generate(label) {
        return new NonMembershipProvingKey((0, crypto_wasm_1.generateNonMembershipProvingKey)(label));
    }
    deriveMembershipProvingKey() {
        return new MembershipProvingKey((0, crypto_wasm_1.accumulatorDeriveMembershipProvingKeyFromNonMembershipKey)(this.value));
    }
}
exports.NonMembershipProvingKey = NonMembershipProvingKey;
//# sourceMappingURL=params-and-keys.js.map