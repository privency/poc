"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UniversalAccumulator = exports.PositiveAccumulator = exports.Accumulator = void 0;
const crypto_wasm_1 = require("@docknetwork/crypto-wasm");
const accumulatorWitness_1 = require("./accumulatorWitness");
const util_1 = require("../util");
const params_and_keys_1 = require("./params-and-keys");
/**
 * Interface implemented by both Positive and Universal accumulator. Contains implementations for parameter and key generation.
 * Note:
 * - The secret key and params are optional in functions like `add`, `remove`, etc. as they can be stored in the accumulator
 * object. If exposure to the secret key needs to be minimized, don't pass it to the constructor but only to functions that need it.
 * - Methods to update the accumulator optionally accept a state, i.e. an object implementing `IAccumulatorState` which
 * should be updated when the new elements are added or old elements are removed from the accumulator. An additional purpose of passing
 * the state object is to check if duplicate elements are not added or already absent elements are not removed or membership witness
 * for absent elements is not created. If checks in the `state` fail, they throw errors.
 */
class Accumulator {
    /**
     * Construct an accumulator object.
     * @param value - The accumulated value
     * @param sk - The secret key. Is optional.
     * @param params - The params. Is optional.
     */
    constructor({ value, sk, params }) {
        if (value === undefined) {
            throw new Error('Needs to pass the accumulated value.');
        }
        this.value = value;
        this.secretKey = sk;
        this.params = params;
    }
    setNew(value) {
        this.value = value;
    }
    /**
     * To add arbitrary bytes like byte representation of UUID or some other user id or something else as an accumulator
     * member, encode it first using this. This is an irreversible encoding as a hash function is used to convert a message
     * of arbitrary length to a fixed length encoding.
     * @param bytes
     */
    static encodeBytesAsAccumulatorMember(bytes) {
        return (0, crypto_wasm_1.generateFieldElementFromBytes)(bytes);
    }
    /**
     * To add a positive number as an accumulator member, encode it first using this.
     * Encodes a positive safe integer, i.e. of 53 bits
     * @param num - should be a positive integer
     */
    static encodePositiveNumberAsAccumulatorMember(num) {
        return (0, crypto_wasm_1.generateFieldElementFromNumber)(num);
    }
    /**
     *  Generate accumulator parameters. They are needed to generate public key and initialize the accumulator.
     * @param label - Pass to generate parameters deterministically.
     * @returns
     */
    static generateParams(label) {
        return params_and_keys_1.AccumulatorParams.generate(label);
    }
    /**
     * Generate secret key for the accumulator manager who updates the accumulator and creates witnesses.
     * @param seed - Pass to generate key deterministically.
     * @returns
     */
    static generateSecretKey(seed) {
        return params_and_keys_1.AccumulatorSecretKey.generate(seed);
    }
    /**
     * Generate public key from given params and secret key.
     * @param secretKey
     * @param params
     * @returns
     */
    static generatePublicKeyFromSecretKey(secretKey, params) {
        return secretKey.generatePublicKey(params);
    }
    /**
     * Generate private and public key from given params and optional `seed`.
     * @param params
     * @param seed - Pass to generate keys deterministically.
     * @returns
     */
    static generateKeypair(params, seed) {
        return params_and_keys_1.AccumulatorKeypair.generate(params, seed);
    }
    /**
     * Generate proving key for proving membership in an accumulator in zero knowledge. Proving key is
     * public data that must be known to both the prover and verifier. Any prover and verifier pair can mutually agree
     * on a proving key and the manager does not need to be aware of any proving key.
     * @param label - The bytearray that is hashed to deterministically generate the proving key.
     */
    static generateMembershipProvingKey(label) {
        return params_and_keys_1.MembershipProvingKey.generate(label);
    }
    /**
     * Generate proving key for proving non-membership in a universal accumulator in zero knowledge.
     * @param label - The bytearray that is hashed to deterministically generate the proving key.
     */
    static generateNonMembershipProvingKey(label) {
        return params_and_keys_1.NonMembershipProvingKey.generate(label);
    }
    static deriveMembershipKeyFromNonMembershipProvingKey(nonMembershipKey) {
        return nonMembershipKey.deriveMembershipProvingKey();
    }
    /**
     * Return the secret key if provided as an argument else look for secret key on `this`.
     * @param secretKey
     * @returns secret key or throws error if cannot find secret key
     */
    getSecretKey(secretKey) {
        if (secretKey === undefined) {
            if (this.secretKey === undefined) {
                throw new Error('Secret key needs to be provided');
            }
            return this.secretKey;
        }
        return secretKey;
    }
    /**
     * Return the params if provided as an argument else look for params on `this`.
     * @param params
     * @returns params or throws error if cannot find params
     */
    getParams(params) {
        if (params === undefined) {
            if (this.params === undefined) {
                throw new Error('Params needs to be provided');
            }
            return this.params;
        }
        return params;
    }
    /**
     * Check if element is absent in the state and throws an error if its present. Only checks if the state is passed
     * @param element
     * @param state
     * @protected
     */
    ensureAbsence(element, state) {
        return __awaiter(this, void 0, void 0, function* () {
            if (state !== undefined) {
                const isPresent = yield state.has(element);
                if (isPresent) {
                    throw new Error(`${element} already present`);
                }
            }
        });
    }
    /**
     * Check if element is present in the state and throws an error if its absent. Only checks if the state is passed
     * @param element
     * @param state
     * @protected
     */
    ensurePresence(element, state) {
        return __awaiter(this, void 0, void 0, function* () {
            if (state !== undefined) {
                const isPresent = yield state.has(element);
                if (!isPresent) {
                    throw new Error(`${element} not present`);
                }
            }
        });
    }
    /**
     * Check if a batch of elements is absent in the state and throws an error any of them is present. Only checks if the state is passed
     * @param elements
     * @param state
     * @protected
     */
    ensureAbsenceOfBatch(elements, state) {
        return __awaiter(this, void 0, void 0, function* () {
            if (state !== undefined) {
                for (const e of elements) {
                    yield this.ensureAbsence(e, state);
                }
            }
        });
    }
    /**
     * Check if a batch of elements is present in the state and throws an error any of them is absent. Only checks if the state is passed
     * @param elements
     * @param state
     * @protected
     */
    ensurePresenceOfBatch(elements, state) {
        return __awaiter(this, void 0, void 0, function* () {
            if (state !== undefined) {
                for (const e of elements) {
                    yield this.ensurePresence(e, state);
                }
            }
        });
    }
    /**
     * If state is provided, add the element to the state
     * @param element
     * @param state
     * @protected
     */
    addToState(element, state) {
        return __awaiter(this, void 0, void 0, function* () {
            if (state !== undefined) {
                yield state.add(element);
            }
        });
    }
    /**
     * If state is provided, remove the element from the state
     * @param element
     * @param state
     * @protected
     */
    removeFromState(element, state) {
        return __awaiter(this, void 0, void 0, function* () {
            if (state !== undefined) {
                yield state.remove(element);
            }
        });
    }
    /**
     * If state is provided, add the batch of elements to the state
     * @param elements
     * @param state
     * @protected
     */
    addBatchToState(elements, state) {
        return __awaiter(this, void 0, void 0, function* () {
            if (state !== undefined) {
                for (const e of elements) {
                    yield this.addToState(e, state);
                }
            }
        });
    }
    /**
     * If state is provided, remove the batch of elements from the state
     * @param elements
     * @param state
     * @protected
     */
    removeBatchFromState(elements, state) {
        return __awaiter(this, void 0, void 0, function* () {
            if (state !== undefined) {
                for (const e of elements) {
                    yield this.removeFromState(e, state);
                }
            }
        });
    }
}
exports.Accumulator = Accumulator;
/**
 * Accumulator that supports only membership proofs.
 */
class PositiveAccumulator extends Accumulator {
    /**
     * Get the current accumulated value
     */
    get accumulated() {
        return this.value;
    }
    /**
     * Initialize a positive accumulator
     * @param params
     * @param secretKey - Optional. If provided, its stored to do any future updates.
     */
    static initialize(params, secretKey) {
        const value = (0, crypto_wasm_1.positiveAccumulatorInitialize)(params.value);
        return new PositiveAccumulator({ value, params, sk: secretKey });
    }
    /**
     * Add a single element to the accumulator
     * @param element
     * @param secretKey
     * @param state - Optional. If provided, checked before adding and updated with the new element
     */
    add(element, secretKey, state) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.ensureAbsence(element, state);
            const sk = this.getSecretKey(secretKey);
            this.value = (0, crypto_wasm_1.positiveAccumulatorAdd)(this.value, element, sk.value);
            yield this.addToState(element, state);
        });
    }
    /**
     * Remove a single element from the accumulator
     * @param element
     * @param secretKey
     * @param state- Optional. If provided, checked before removing and element is removed
     */
    remove(element, secretKey, state) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.ensurePresence(element, state);
            const sk = this.getSecretKey(secretKey);
            this.value = (0, crypto_wasm_1.positiveAccumulatorRemove)(this.value, element, sk.value);
            yield this.removeFromState(element, state);
        });
    }
    /**
     * Add multiple elements in a batch.
     * @param elements
     * @param secretKey
     * @param state
     */
    addBatch(elements, secretKey, state) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.ensureAbsenceOfBatch(elements, state);
            const sk = this.getSecretKey(secretKey);
            this.value = (0, crypto_wasm_1.positiveAccumulatorAddBatch)(this.value, elements, sk.value);
            yield this.addBatchToState(elements, state);
        });
    }
    /**
     * Remove multiple elements in a batch.
     * @param elements
     * @param secretKey
     * @param state
     */
    removeBatch(elements, secretKey, state) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.ensurePresenceOfBatch(elements, state);
            const sk = this.getSecretKey(secretKey);
            this.value = (0, crypto_wasm_1.positiveAccumulatorRemoveBatch)(this.value, elements, sk.value);
            yield this.removeBatchFromState(elements, state);
        });
    }
    /**
     * Add and remove 1 batch of elements each.
     * @param additions
     * @param removals
     * @param secretKey
     * @param state
     */
    addRemoveBatches(additions, removals, secretKey, state) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.ensureAbsenceOfBatch(additions, state);
            yield this.ensurePresenceOfBatch(removals, state);
            const sk = this.getSecretKey(secretKey);
            this.value = (0, crypto_wasm_1.positiveAccumulatorBatchUpdates)(this.value, additions, removals, sk.value);
            yield this.addBatchToState(additions, state);
            yield this.removeBatchFromState(removals, state);
        });
    }
    /**
     * Create membership witness for a single member.
     * @param member - for which the witness is created.
     * @param secretKey
     * @param state - Optional. If provided, checks that `member` is present in state
     * @returns - Promise that resolves to the membership witness
     */
    membershipWitness(member, secretKey, state) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.ensurePresence(member, state);
            const sk = this.getSecretKey(secretKey);
            const wit = (0, crypto_wasm_1.positiveAccumulatorMembershipWitness)(this.value, member, sk.value);
            return new accumulatorWitness_1.MembershipWitness(wit);
        });
    }
    /**
     * Create membership witnesses for a batch of members. More efficient than creating witness for 1 member at a time.
     * @param members - array of members for which witnesses need to be creates
     * @param secretKey
     * @param state - Optional. If provided, checks that all `members` are present in state
     * @returns - Promise that resolves to array of membership witnesses
     */
    membershipWitnessesForBatch(members, secretKey, state) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.ensurePresenceOfBatch(members, state);
            const sk = this.getSecretKey(secretKey);
            return (0, crypto_wasm_1.positiveAccumulatorMembershipWitnessesForBatch)(this.value, members, sk.value).map((m) => new accumulatorWitness_1.MembershipWitness(m));
        });
    }
    /**
     * Verify that membership witness is valid for the member.
     * @param member
     * @param witness
     * @param publicKey
     * @param params
     * @returns - true if witness is valid, false otherwise
     */
    verifyMembershipWitness(member, witness, publicKey, params) {
        const params_ = this.getParams(params);
        return (0, crypto_wasm_1.positiveAccumulatorVerifyMembership)(this.value, member, witness.value, publicKey.value, params_.value);
    }
    toJSON() {
        return JSON.stringify({
            value: Array.from(this.value),
            sk: this.secretKey,
            params: this.params
        });
    }
    static fromJSON(json) {
        const obj = JSON.parse(json);
        const [value] = (0, util_1.getUint8ArraysFromObject)(obj, ['value']);
        return new PositiveAccumulator({ value: value, sk: obj.sk, params: obj.params });
    }
    /**
     * Used by the verifier to create the accumulator.
     * @param accumulated
     */
    static fromAccumulated(accumulated) {
        return new PositiveAccumulator({ value: accumulated });
    }
}
exports.PositiveAccumulator = PositiveAccumulator;
/**
 * Accumulator that supports both membership proofs and non-membership proofs. For guarding against forgery of
 * non-membership proofs (details in the paper), during initialization, it should generate several accumulator members
 * and never remove them from accumulator, nor it should allow duplicates of them to be added. Thus, several methods
 * accept an optional persistent database `IInitialElementsStore` which stores those initial elements.
 */
class UniversalAccumulator extends Accumulator {
    /**
     * Initialize a universal accumulator of the given `maxSize`. The function takes time proportional to `maxSize` as it
     * generates about the same number of elements as the `maxSize` and takes their product in the end. These "initial elements"
     * should not be added or removed from the accumulator.
     * @param maxSize - Maximum members the accumulator can have at any instant.
     * @param params
     * @param secretKey
     * @param initialElementsStore - Optional, stores "initial elements" generated during initialization.
     * @param batchSize - Breaks down this large computation in batches of size `batchSize`.
     */
    static initialize(maxSize, params, secretKey, initialElementsStore, batchSize = 100) {
        return __awaiter(this, void 0, void 0, function* () {
            const storePresent = initialElementsStore !== undefined;
            // store the products of each batch
            const products = [];
            // The first batch of products is the elements fixed for each curve
            const fixed = UniversalAccumulator.fixedInitialElements();
            if (storePresent) {
                for (const i of fixed) {
                    yield initialElementsStore.add(i);
                }
            }
            products.push((0, crypto_wasm_1.universalAccumulatorComputeInitialFv)(fixed, secretKey.value));
            // store a batch of generated elements and take the product once the batch is full
            let currentBatch = [];
            // Accumulate 1 more than the maximum number of allowed members as specified in the paper
            for (let i = 0; i <= maxSize; i++) {
                const e = (0, crypto_wasm_1.generateRandomFieldElement)();
                currentBatch.push(e);
                if (storePresent) {
                    yield initialElementsStore.add(e);
                }
                if (currentBatch.length == batchSize) {
                    // Batch full, take product
                    products.push((0, crypto_wasm_1.universalAccumulatorComputeInitialFv)(currentBatch, secretKey.value));
                    currentBatch = [];
                }
            }
            if (currentBatch.length > 0) {
                products.push((0, crypto_wasm_1.universalAccumulatorComputeInitialFv)(currentBatch, secretKey.value));
            }
            // take the product of the products from each batch
            const product = (0, crypto_wasm_1.universalAccumulatorCombineMultipleInitialFv)(products);
            return UniversalAccumulator.initializeGivenInitialElementsProduct(maxSize, product, params, secretKey);
        });
    }
    /***
     * Assumes that the initial elements are generated and their product is taken, initialize the accumulator.
     * @param maxSize
     * @param initialElementsProduct
     * @param params
     * @param secretKey
     */
    static initializeGivenInitialElementsProduct(maxSize, initialElementsProduct, params, secretKey) {
        const value = (0, crypto_wasm_1.universalAccumulatorInitialiseGivenFv)(initialElementsProduct, params.value, maxSize);
        return new UniversalAccumulator({ value, params, sk: secretKey });
    }
    get accumulated() {
        return this.value.V;
    }
    // The following functions optionally take secret key as an argument as its better to not store secret key in memory for
    // long time.
    // If secret key is not provided, it looks in the object's fields for secret key.
    /**
     * Add a single element to the accumulator
     * @param element - The element to add.
     * @param secretKey - If secret key is not provided, its expected to find the secret key on the object.
     * @param state - If state is provided it is checked before computing the new accumulator and updated with new element after
     * computing the new accumulator. Throws error if element present.
     * @param initialElementsStore - if provided, check that the element is not part of the initial elements, throws error if it is.
     */
    add(element, secretKey, state, initialElementsStore) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.checkBeforeAdd(element, state, initialElementsStore);
            const sk = this.getSecretKey(secretKey);
            this.value = (0, crypto_wasm_1.universalAccumulatorAdd)(this.value, element, sk.value);
            yield this.addToState(element, state);
        });
    }
    /**
     * Remove a single element from the accumulator
     * @param element
     * @param secretKey
     * @param state - If state is provided it is checked before computing the new accumulator and element is removed from it after
     * computing the new accumulator. Throws error if element is not present.
     * @param initialElementsStore - if provided, check that the element is not part of the initial elements, throws error if it is.
     */
    remove(element, secretKey, state, initialElementsStore) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.checkBeforeRemove(element, state, initialElementsStore);
            const sk = this.getSecretKey(secretKey);
            this.value = (0, crypto_wasm_1.universalAccumulatorRemove)(this.value, element, sk.value);
            yield this.removeFromState(element, state);
        });
    }
    addBatch(elements, secretKey, state, initialElementsStore) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.checkBeforeAddBatch(elements, state, initialElementsStore);
            const sk = this.getSecretKey(secretKey);
            this.value = (0, crypto_wasm_1.universalAccumulatorAddBatch)(this.value, elements, sk.value);
            yield this.addBatchToState(elements, state);
        });
    }
    removeBatch(elements, secretKey, state, initialElementsStore) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.checkBeforeRemoveBatch(elements, state, initialElementsStore);
            const sk = this.getSecretKey(secretKey);
            this.value = (0, crypto_wasm_1.universalAccumulatorRemoveBatch)(this.value, elements, sk.value);
            yield this.removeBatchFromState(elements, state);
        });
    }
    addRemoveBatches(additions, removals, secretKey, state, initialElementsStore) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.checkBeforeAddBatch(additions, state, initialElementsStore);
            yield this.checkBeforeRemoveBatch(removals, state, initialElementsStore);
            const sk = this.getSecretKey(secretKey);
            this.value = (0, crypto_wasm_1.universalAccumulatorBatchUpdates)(this.value, additions, removals, sk.value);
            yield this.addBatchToState(additions, state);
            yield this.removeBatchFromState(removals, state);
        });
    }
    membershipWitness(member, secretKey, state, initialElementsStore) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.checkElementAcceptable(member, initialElementsStore);
            yield this.ensurePresence(member, state);
            const sk = this.getSecretKey(secretKey);
            const wit = (0, crypto_wasm_1.universalAccumulatorMembershipWitness)(this.value, member, sk.value);
            return new accumulatorWitness_1.MembershipWitness(wit);
        });
    }
    membershipWitnessesForBatch(members, secretKey, state, initialElementsStore) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.checkElementBatchAcceptable(members, initialElementsStore);
            yield this.ensurePresenceOfBatch(members, state);
            const sk = this.getSecretKey(secretKey);
            return (0, crypto_wasm_1.universalAccumulatorMembershipWitnessesForBatch)(this.value, members, sk.value).map((m) => new accumulatorWitness_1.MembershipWitness(m));
        });
    }
    /**
     * Calculate the non-membership witness for the given element. The function takes time proportional to the current
     * size of the accumulator as it takes the product of difference of all members and the non-member. To avoid taking too
     * much memory, it breaks the computation into smaller batches.
     * @param nonMember
     * @param state
     * @param secretKey
     * @param params
     * @param initialElementsStore
     * @param batchSize - Breaks down this large computation in batches of size `batchSize`.
     */
    nonMembershipWitness(nonMember, state, secretKey, params, initialElementsStore, batchSize = 100) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.checkElementAcceptable(nonMember, initialElementsStore);
            yield this.ensureAbsence(nonMember, state);
            const sk = this.getSecretKey(secretKey);
            const params_ = this.getParams(params);
            const members = yield state.elements();
            let currentBatch = [];
            const ds = [];
            for (const member of members) {
                currentBatch.push(member);
                if (currentBatch.length == batchSize) {
                    ds.push((0, crypto_wasm_1.universalAccumulatorComputeD)(nonMember, currentBatch));
                    currentBatch = [];
                }
            }
            if (currentBatch.length > 0) {
                ds.push((0, crypto_wasm_1.universalAccumulatorComputeD)(nonMember, currentBatch));
            }
            const d = (0, crypto_wasm_1.universalAccumulatorCombineMultipleD)(ds);
            const wit = (0, crypto_wasm_1.universalAccumulatorNonMembershipWitness)(this.value, d, nonMember, sk.value, params_.value);
            return new accumulatorWitness_1.NonMembershipWitness(wit);
        });
    }
    /**
     * Calculate the non-membership witness for the given element when the product of differences of all members and
     * non-member (`d`) is already computed.
     * @param nonMember
     * @param d - the product of difference of all members and the non-member.
     * @param secretKey
     * @param params
     * @param state
     * @param initialElementsStore
     */
    nonMembershipWitnessGivenD(nonMember, d, secretKey, params, state, initialElementsStore) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.checkElementAcceptable(nonMember, initialElementsStore);
            yield this.ensureAbsence(nonMember, state);
            const sk = this.getSecretKey(secretKey);
            const params_ = this.getParams(params);
            const wit = (0, crypto_wasm_1.universalAccumulatorNonMembershipWitness)(this.value, d, nonMember, sk.value, params_.value);
            return new accumulatorWitness_1.NonMembershipWitness(wit);
        });
    }
    /**
     * Calculate the non-membership witnesses for given batch of elements. The function takes time proportional to the current
     * members and the number of non-members. To avoid taking too much memory, it breaks the computation into smaller batches.
     * @param nonMembers
     * @param secretKey
     * @param params
     * @param state
     * @param initialElementsStore
     * @param batchSize - Breaks down this large computation in batches of size `batchSize`.
     */
    nonMembershipWitnessesForBatch(nonMembers, state, secretKey, params, initialElementsStore, batchSize = 100) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.checkElementBatchAcceptable(nonMembers, initialElementsStore);
            yield this.ensureAbsenceOfBatch(nonMembers, state);
            const sk = this.getSecretKey(secretKey);
            const params_ = this.getParams(params);
            // store multiple `d`s for each non-member, outer index of array is the non-member index
            const dsForAll = new Array(nonMembers.length);
            for (let i = 0; i < nonMembers.length; i++) {
                dsForAll[i] = new Array();
            }
            let currentBatch = [];
            // Iterate over all members of the accumulator
            const members = yield state.elements();
            for (const member of members) {
                currentBatch.push(member);
                if (currentBatch.length == batchSize) {
                    // Current batch is full, compute `d` for all non-members
                    for (let i = 0; i < nonMembers.length; i++) {
                        dsForAll[i].push((0, crypto_wasm_1.universalAccumulatorComputeD)(nonMembers[i], currentBatch));
                    }
                    currentBatch = [];
                }
            }
            if (currentBatch.length > 0) {
                for (let i = 0; i < nonMembers.length; i++) {
                    dsForAll[i].push((0, crypto_wasm_1.universalAccumulatorComputeD)(nonMembers[i], currentBatch));
                }
            }
            const ds = new Array(nonMembers.length);
            for (let i = 0; i < nonMembers.length; i++) {
                // Combine `d`s corresponding to each non-member
                ds[i] = (0, crypto_wasm_1.universalAccumulatorCombineMultipleD)(dsForAll[i]);
            }
            return (0, crypto_wasm_1.universalAccumulatorNonMembershipWitnessesForBatch)(this.value, ds, nonMembers, sk.value, params_.value).map((m) => new accumulatorWitness_1.NonMembershipWitness(m));
        });
    }
    /**
     * Calculate the non-membership witnesses for given batch of elements when the product of differences of all members and
     * non-member (`d`) for each non-member is already computed.
     * @param nonMembers
     * @param d - array of products of difference of all members and each non-member
     * @param secretKey
     * @param params
     * @param state
     * @param initialElementsStore
     */
    nonMembershipWitnessesForBatchGivenD(nonMembers, d, secretKey, params, state, initialElementsStore) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.checkElementBatchAcceptable(nonMembers, initialElementsStore);
            yield this.ensureAbsenceOfBatch(nonMembers, state);
            const sk = this.getSecretKey(secretKey);
            const params_ = this.getParams(params);
            return (0, crypto_wasm_1.universalAccumulatorNonMembershipWitnessesForBatch)(this.value, d, nonMembers, sk.value, params_.value).map((m) => new accumulatorWitness_1.NonMembershipWitness(m));
        });
    }
    verifyMembershipWitness(member, witness, pk, params) {
        const params_ = this.getParams(params);
        return (0, crypto_wasm_1.universalAccumulatorVerifyMembership)(this.value.V, member, witness.value, pk.value, params_.value);
    }
    verifyNonMembershipWitness(nonMember, witness, pk, params) {
        const params_ = this.getParams(params);
        return (0, crypto_wasm_1.universalAccumulatorVerifyNonMembership)(this.value.V, nonMember, witness.value, pk.value, params_.value);
    }
    /**
     * The first few members of a universal accumulator are fixed for each curve. These should be added to the curve
     * before creating any witness and must never be removed.
     */
    static fixedInitialElements() {
        return (0, crypto_wasm_1.universalAccumulatorFixedInitialElements)();
    }
    /**
     * Takes product of the form `initial_element_i + secret_key`.
     * @param initialElements
     * @param secretKey
     */
    static initialElementsProduct(initialElements, secretKey) {
        return (0, crypto_wasm_1.universalAccumulatorComputeInitialFv)(initialElements, secretKey.value);
    }
    static combineInitialElementsProducts(products) {
        return (0, crypto_wasm_1.universalAccumulatorCombineMultipleInitialFv)(products);
    }
    static dForNonMembershipWitness(nonMember, members) {
        return (0, crypto_wasm_1.universalAccumulatorComputeD)(nonMember, members);
    }
    static dBatchForNonMembershipWitnesses(nonMembers, members) {
        return (0, crypto_wasm_1.universalAccumulatorComputeDForBatch)(nonMembers, members);
    }
    /**
     * Throws an error if the element is part of the initial elements given that the initial element store is provided
     * @param element
     * @param store
     */
    checkElementAcceptable(element, store) {
        return __awaiter(this, void 0, void 0, function* () {
            if (store !== undefined) {
                const isPresent = yield store.has(element);
                if (isPresent) {
                    throw new Error(`${element} isn't acceptable`);
                }
            }
        });
    }
    /**
     * Throws an error if any element of the batch is part of the initial elements given that the initial element store is provided
     * @param elements
     * @param store
     */
    checkElementBatchAcceptable(elements, store) {
        return __awaiter(this, void 0, void 0, function* () {
            if (store !== undefined) {
                for (const e of elements) {
                    yield this.checkElementAcceptable(e, store);
                }
            }
        });
    }
    /**
     * Checks to do before adding a new element
     * @param element
     * @param state
     * @param initialElementsStore
     * @protected
     */
    checkBeforeAdd(element, state, initialElementsStore) {
        const _super = Object.create(null, {
            ensureAbsence: { get: () => super.ensureAbsence }
        });
        return __awaiter(this, void 0, void 0, function* () {
            yield this.checkElementAcceptable(element, initialElementsStore);
            yield _super.ensureAbsence.call(this, element, state);
        });
    }
    /**
     * Checks to do before removing an existing element
     * @param element
     * @param state
     * @param initialElementsStore
     * @protected
     */
    checkBeforeRemove(element, state, initialElementsStore) {
        const _super = Object.create(null, {
            ensurePresence: { get: () => super.ensurePresence }
        });
        return __awaiter(this, void 0, void 0, function* () {
            yield this.checkElementAcceptable(element, initialElementsStore);
            yield _super.ensurePresence.call(this, element, state);
        });
    }
    /**
     * Checks to do before adding several elements as a batch
     * @param elements
     * @param state
     * @param initialElementsStore
     * @protected
     */
    checkBeforeAddBatch(elements, state, initialElementsStore) {
        const _super = Object.create(null, {
            ensureAbsence: { get: () => super.ensureAbsence }
        });
        return __awaiter(this, void 0, void 0, function* () {
            if (state !== undefined) {
                for (const e of elements) {
                    yield this.checkElementAcceptable(e, initialElementsStore);
                    yield _super.ensureAbsence.call(this, e, state);
                }
            }
        });
    }
    /**
     * Checks to do before removing several elements as a batch
     * @param elements
     * @param state
     * @param initialElementsStore
     * @protected
     */
    checkBeforeRemoveBatch(elements, state, initialElementsStore) {
        const _super = Object.create(null, {
            ensurePresence: { get: () => super.ensurePresence }
        });
        return __awaiter(this, void 0, void 0, function* () {
            if (state !== undefined) {
                for (const e of elements) {
                    yield this.checkElementAcceptable(e, initialElementsStore);
                    yield _super.ensurePresence.call(this, e, state);
                }
            }
        });
    }
    toJSON() {
        return JSON.stringify({
            value: { f_V: Array.from(this.value.f_V), V: Array.from(this.value.V) },
            sk: this.secretKey,
            params: this.params
        });
    }
    static fromJSON(json) {
        const obj = JSON.parse(json);
        const [f_V, V] = (0, util_1.getUint8ArraysFromObject)(obj.value, ['f_V', 'V']);
        return new UniversalAccumulator({ value: { f_V, V }, sk: obj.sk, params: obj.params });
    }
    static fromAccumulated(accumulated) {
        return new UniversalAccumulator({ value: { V: accumulated } });
    }
}
exports.UniversalAccumulator = UniversalAccumulator;
//# sourceMappingURL=accumulator.js.map