import { MembershipWitness, NonMembershipWitness } from './accumulatorWitness';
import { IAccumulatorState, IUniversalAccumulatorState } from './IAccumulatorState';
import { IInitialElementsStore } from './IInitialElementsStore';
import { AccumulatorKeypair, AccumulatorParams, AccumulatorPublicKey, AccumulatorSecretKey, MembershipProvingKey, NonMembershipProvingKey } from './params-and-keys';
/**
 * Interface implemented by both Positive and Universal accumulator. Contains implementations for parameter and key generation.
 * Note:
 * - The secret key and params are optional in functions like `add`, `remove`, etc. as they can be stored in the accumulator
 * object. If exposure to the secret key needs to be minimized, don't pass it to the constructor but only to functions that need it.
 * - Methods to update the accumulator optionally accept a state, i.e. an object implementing `IAccumulatorState` which
 * should be updated when the new elements are added or old elements are removed from the accumulator. An additional purpose of passing
 * the state object is to check if duplicate elements are not added or already absent elements are not removed or membership witness
 * for absent elements is not created. If checks in the `state` fail, they throw errors.
 */
export declare abstract class Accumulator {
    value: Uint8Array | object;
    secretKey: AccumulatorSecretKey | undefined;
    params: AccumulatorParams | undefined;
    /**
     * Construct an accumulator object.
     * @param value - The accumulated value
     * @param sk - The secret key. Is optional.
     * @param params - The params. Is optional.
     */
    constructor({ value, sk, params }: any);
    setNew(value: Uint8Array | object): void;
    /**
     * To add arbitrary bytes like byte representation of UUID or some other user id or something else as an accumulator
     * member, encode it first using this. This is an irreversible encoding as a hash function is used to convert a message
     * of arbitrary length to a fixed length encoding.
     * @param bytes
     */
    static encodeBytesAsAccumulatorMember(bytes: Uint8Array): Uint8Array;
    /**
     * To add a positive number as an accumulator member, encode it first using this.
     * Encodes a positive safe integer, i.e. of 53 bits
     * @param num - should be a positive integer
     */
    static encodePositiveNumberAsAccumulatorMember(num: number): Uint8Array;
    /**
     *  Generate accumulator parameters. They are needed to generate public key and initialize the accumulator.
     * @param label - Pass to generate parameters deterministically.
     * @returns
     */
    static generateParams(label?: Uint8Array): AccumulatorParams;
    /**
     * Generate secret key for the accumulator manager who updates the accumulator and creates witnesses.
     * @param seed - Pass to generate key deterministically.
     * @returns
     */
    static generateSecretKey(seed?: Uint8Array): AccumulatorSecretKey;
    /**
     * Generate public key from given params and secret key.
     * @param secretKey
     * @param params
     * @returns
     */
    static generatePublicKeyFromSecretKey(secretKey: AccumulatorSecretKey, params: AccumulatorParams): AccumulatorPublicKey;
    /**
     * Generate private and public key from given params and optional `seed`.
     * @param params
     * @param seed - Pass to generate keys deterministically.
     * @returns
     */
    static generateKeypair(params: AccumulatorParams, seed?: Uint8Array): AccumulatorKeypair;
    /**
     * Generate proving key for proving membership in an accumulator in zero knowledge. Proving key is
     * public data that must be known to both the prover and verifier. Any prover and verifier pair can mutually agree
     * on a proving key and the manager does not need to be aware of any proving key.
     * @param label - The bytearray that is hashed to deterministically generate the proving key.
     */
    static generateMembershipProvingKey(label?: Uint8Array): MembershipProvingKey;
    /**
     * Generate proving key for proving non-membership in a universal accumulator in zero knowledge.
     * @param label - The bytearray that is hashed to deterministically generate the proving key.
     */
    static generateNonMembershipProvingKey(label?: Uint8Array): NonMembershipProvingKey;
    static deriveMembershipKeyFromNonMembershipProvingKey(nonMembershipKey: NonMembershipProvingKey): MembershipProvingKey;
    /**
     * Return the secret key if provided as an argument else look for secret key on `this`.
     * @param secretKey
     * @returns secret key or throws error if cannot find secret key
     */
    protected getSecretKey(secretKey?: AccumulatorSecretKey): AccumulatorSecretKey;
    /**
     * Return the params if provided as an argument else look for params on `this`.
     * @param params
     * @returns params or throws error if cannot find params
     */
    protected getParams(params?: AccumulatorParams): AccumulatorParams;
    /**
     * Get the accumulated value.
     */
    abstract get accumulated(): Uint8Array;
    /**
     * Add a single element to the accumulator
     * @param element - The element to add.
     * @param secretKey - If secret key is not provided, its expected to find the secret key on the object.
     * @param state - If state is provided it is checked before computing the new accumulator and updated with new element after
     * computing the new accumulator. Throws error if element present.
     */
    abstract add(element: Uint8Array, secretKey?: AccumulatorSecretKey, state?: IAccumulatorState): void;
    /**
     * Remove a single element from the accumulator
     * @param element
     * @param secretKey
     * @param state - If state is provided it is checked before computing the new accumulator and element is removed from it after
     * computing the new accumulator. Throws error if element is not present.
     */
    abstract remove(element: Uint8Array, secretKey?: AccumulatorSecretKey, state?: IAccumulatorState): void;
    /**
     * Add a batch of elements to the accumulator.
     * @param elements
     * @param secretKey
     * @param state - If state is provided it is checked before computing the new accumulator and updated with new elements after
     * computing the new accumulator
     */
    abstract addBatch(elements: Uint8Array[], secretKey?: AccumulatorSecretKey, state?: IAccumulatorState): void;
    /**
     * Remove a batch of elements from the accumulator.
     * @param elements
     * @param secretKey
     * @param state - If state is provided it is checked before computing the new accumulator and updated by removing those elements
     * after computing the new accumulator
     */
    abstract removeBatch(elements: Uint8Array[], secretKey?: AccumulatorSecretKey, state?: IAccumulatorState): void;
    /**
     * Add and remove batches of elements.
     * @param additions - The batch to be added
     * @param removals - The batch to be removed.
     * @param secretKey
     * @param state - If state is provided it is checked before computing the new accumulator and updated by adding and
     * removing given elements after computing the new accumulator.
     */
    abstract addRemoveBatches(additions: Uint8Array[], removals: Uint8Array[], secretKey?: AccumulatorSecretKey, state?: IAccumulatorState): void;
    /**
     * Calculate the membership witness for the given element
     * @param element - Whose witness is calculated.
     * @param secretKey
     * @param state - If state is provided it is checked for presence of the element before calculating the witness
     */
    abstract membershipWitness(element: Uint8Array, secretKey?: AccumulatorSecretKey, state?: IAccumulatorState): Promise<MembershipWitness>;
    /**
     * Calculate the membership witnesses for the given batch of elements
     * @param elements - Whose witness is calculated.
     * @param secretKey
     * @param state - If state is provided it is checked for presence of all the elements before calculating the witnesses
     */
    abstract membershipWitnessesForBatch(elements: Uint8Array[], secretKey?: AccumulatorSecretKey, state?: IAccumulatorState): Promise<MembershipWitness[]>;
    /**
     * Verify the membership witness.
     * @param member
     * @param witness
     * @param pk
     * @param params
     */
    abstract verifyMembershipWitness(member: Uint8Array, witness: MembershipWitness, pk: AccumulatorPublicKey, params?: AccumulatorParams): boolean;
    /**
     * Check if element is absent in the state and throws an error if its present. Only checks if the state is passed
     * @param element
     * @param state
     * @protected
     */
    protected ensureAbsence(element: Uint8Array, state?: IAccumulatorState): Promise<void>;
    /**
     * Check if element is present in the state and throws an error if its absent. Only checks if the state is passed
     * @param element
     * @param state
     * @protected
     */
    protected ensurePresence(element: Uint8Array, state?: IAccumulatorState): Promise<void>;
    /**
     * Check if a batch of elements is absent in the state and throws an error any of them is present. Only checks if the state is passed
     * @param elements
     * @param state
     * @protected
     */
    protected ensureAbsenceOfBatch(elements: Uint8Array[], state?: IAccumulatorState): Promise<void>;
    /**
     * Check if a batch of elements is present in the state and throws an error any of them is absent. Only checks if the state is passed
     * @param elements
     * @param state
     * @protected
     */
    protected ensurePresenceOfBatch(elements: Uint8Array[], state?: IAccumulatorState): Promise<void>;
    /**
     * If state is provided, add the element to the state
     * @param element
     * @param state
     * @protected
     */
    protected addToState(element: Uint8Array, state?: IAccumulatorState): Promise<void>;
    /**
     * If state is provided, remove the element from the state
     * @param element
     * @param state
     * @protected
     */
    protected removeFromState(element: Uint8Array, state?: IAccumulatorState): Promise<void>;
    /**
     * If state is provided, add the batch of elements to the state
     * @param elements
     * @param state
     * @protected
     */
    protected addBatchToState(elements: Uint8Array[], state?: IAccumulatorState): Promise<void>;
    /**
     * If state is provided, remove the batch of elements from the state
     * @param elements
     * @param state
     * @protected
     */
    protected removeBatchFromState(elements: Uint8Array[], state?: IAccumulatorState): Promise<void>;
}
/**
 * Accumulator that supports only membership proofs.
 */
export declare class PositiveAccumulator extends Accumulator {
    value: Uint8Array;
    /**
     * Get the current accumulated value
     */
    get accumulated(): Uint8Array;
    /**
     * Initialize a positive accumulator
     * @param params
     * @param secretKey - Optional. If provided, its stored to do any future updates.
     */
    static initialize(params: AccumulatorParams, secretKey?: AccumulatorSecretKey): PositiveAccumulator;
    /**
     * Add a single element to the accumulator
     * @param element
     * @param secretKey
     * @param state - Optional. If provided, checked before adding and updated with the new element
     */
    add(element: Uint8Array, secretKey?: AccumulatorSecretKey, state?: IAccumulatorState): Promise<void>;
    /**
     * Remove a single element from the accumulator
     * @param element
     * @param secretKey
     * @param state- Optional. If provided, checked before removing and element is removed
     */
    remove(element: Uint8Array, secretKey?: AccumulatorSecretKey, state?: IAccumulatorState): Promise<void>;
    /**
     * Add multiple elements in a batch.
     * @param elements
     * @param secretKey
     * @param state
     */
    addBatch(elements: Uint8Array[], secretKey?: AccumulatorSecretKey, state?: IAccumulatorState): Promise<void>;
    /**
     * Remove multiple elements in a batch.
     * @param elements
     * @param secretKey
     * @param state
     */
    removeBatch(elements: Uint8Array[], secretKey?: AccumulatorSecretKey, state?: IAccumulatorState): Promise<void>;
    /**
     * Add and remove 1 batch of elements each.
     * @param additions
     * @param removals
     * @param secretKey
     * @param state
     */
    addRemoveBatches(additions: Uint8Array[], removals: Uint8Array[], secretKey?: AccumulatorSecretKey, state?: IAccumulatorState): Promise<void>;
    /**
     * Create membership witness for a single member.
     * @param member - for which the witness is created.
     * @param secretKey
     * @param state - Optional. If provided, checks that `member` is present in state
     * @returns - Promise that resolves to the membership witness
     */
    membershipWitness(member: Uint8Array, secretKey?: AccumulatorSecretKey, state?: IAccumulatorState): Promise<MembershipWitness>;
    /**
     * Create membership witnesses for a batch of members. More efficient than creating witness for 1 member at a time.
     * @param members - array of members for which witnesses need to be creates
     * @param secretKey
     * @param state - Optional. If provided, checks that all `members` are present in state
     * @returns - Promise that resolves to array of membership witnesses
     */
    membershipWitnessesForBatch(members: Uint8Array[], secretKey?: AccumulatorSecretKey, state?: IAccumulatorState): Promise<MembershipWitness[]>;
    /**
     * Verify that membership witness is valid for the member.
     * @param member
     * @param witness
     * @param publicKey
     * @param params
     * @returns - true if witness is valid, false otherwise
     */
    verifyMembershipWitness(member: Uint8Array, witness: MembershipWitness, publicKey: AccumulatorPublicKey, params?: AccumulatorParams): boolean;
    toJSON(): string;
    static fromJSON(json: string): PositiveAccumulator;
    /**
     * Used by the verifier to create the accumulator.
     * @param accumulated
     */
    static fromAccumulated(accumulated: Uint8Array): PositiveAccumulator;
}
/**
 * Accumulator that supports both membership proofs and non-membership proofs. For guarding against forgery of
 * non-membership proofs (details in the paper), during initialization, it should generate several accumulator members
 * and never remove them from accumulator, nor it should allow duplicates of them to be added. Thus, several methods
 * accept an optional persistent database `IInitialElementsStore` which stores those initial elements.
 */
export declare class UniversalAccumulator extends Accumulator {
    /**
     * `f_V` is supposed to kept private by the accumulator manager. `V` is the accumulated value.
     */
    value: {
        f_V: Uint8Array;
        V: Uint8Array;
        maxSize: number;
    };
    /**
     * Initialize a universal accumulator of the given `maxSize`. The function takes time proportional to `maxSize` as it
     * generates about the same number of elements as the `maxSize` and takes their product in the end. These "initial elements"
     * should not be added or removed from the accumulator.
     * @param maxSize - Maximum members the accumulator can have at any instant.
     * @param params
     * @param secretKey
     * @param initialElementsStore - Optional, stores "initial elements" generated during initialization.
     * @param batchSize - Breaks down this large computation in batches of size `batchSize`.
     */
    static initialize(maxSize: number, params: AccumulatorParams, secretKey: AccumulatorSecretKey, initialElementsStore?: IInitialElementsStore, batchSize?: number): Promise<UniversalAccumulator>;
    /***
     * Assumes that the initial elements are generated and their product is taken, initialize the accumulator.
     * @param maxSize
     * @param initialElementsProduct
     * @param params
     * @param secretKey
     */
    static initializeGivenInitialElementsProduct(maxSize: number, initialElementsProduct: Uint8Array, params: AccumulatorParams, secretKey?: AccumulatorSecretKey): UniversalAccumulator;
    get accumulated(): Uint8Array;
    /**
     * Add a single element to the accumulator
     * @param element - The element to add.
     * @param secretKey - If secret key is not provided, its expected to find the secret key on the object.
     * @param state - If state is provided it is checked before computing the new accumulator and updated with new element after
     * computing the new accumulator. Throws error if element present.
     * @param initialElementsStore - if provided, check that the element is not part of the initial elements, throws error if it is.
     */
    add(element: Uint8Array, secretKey?: AccumulatorSecretKey, state?: IAccumulatorState, initialElementsStore?: IInitialElementsStore): Promise<void>;
    /**
     * Remove a single element from the accumulator
     * @param element
     * @param secretKey
     * @param state - If state is provided it is checked before computing the new accumulator and element is removed from it after
     * computing the new accumulator. Throws error if element is not present.
     * @param initialElementsStore - if provided, check that the element is not part of the initial elements, throws error if it is.
     */
    remove(element: Uint8Array, secretKey?: AccumulatorSecretKey, state?: IAccumulatorState, initialElementsStore?: IInitialElementsStore): Promise<void>;
    addBatch(elements: Uint8Array[], secretKey?: AccumulatorSecretKey, state?: IAccumulatorState, initialElementsStore?: IInitialElementsStore): Promise<void>;
    removeBatch(elements: Uint8Array[], secretKey?: AccumulatorSecretKey, state?: IAccumulatorState, initialElementsStore?: IInitialElementsStore): Promise<void>;
    addRemoveBatches(additions: Uint8Array[], removals: Uint8Array[], secretKey?: AccumulatorSecretKey, state?: IAccumulatorState, initialElementsStore?: IInitialElementsStore): Promise<void>;
    membershipWitness(member: Uint8Array, secretKey?: AccumulatorSecretKey, state?: IAccumulatorState, initialElementsStore?: IInitialElementsStore): Promise<MembershipWitness>;
    membershipWitnessesForBatch(members: Uint8Array[], secretKey?: AccumulatorSecretKey, state?: IAccumulatorState, initialElementsStore?: IInitialElementsStore): Promise<MembershipWitness[]>;
    /**
     * Calculate the non-membership witness for the given element. The function takes time proportional to the current
     * size of the accumulator as it takes the product of difference of all members and the non-member. To avoid taking too
     * much memory, it breaks the computation into smaller batches.
     * @param nonMember
     * @param state
     * @param secretKey
     * @param params
     * @param initialElementsStore
     * @param batchSize - Breaks down this large computation in batches of size `batchSize`.
     */
    nonMembershipWitness(nonMember: Uint8Array, state: IUniversalAccumulatorState, secretKey?: AccumulatorSecretKey, params?: AccumulatorParams, initialElementsStore?: IInitialElementsStore, batchSize?: number): Promise<NonMembershipWitness>;
    /**
     * Calculate the non-membership witness for the given element when the product of differences of all members and
     * non-member (`d`) is already computed.
     * @param nonMember
     * @param d - the product of difference of all members and the non-member.
     * @param secretKey
     * @param params
     * @param state
     * @param initialElementsStore
     */
    nonMembershipWitnessGivenD(nonMember: Uint8Array, d: Uint8Array, secretKey?: AccumulatorSecretKey, params?: AccumulatorParams, state?: IUniversalAccumulatorState, initialElementsStore?: IInitialElementsStore): Promise<NonMembershipWitness>;
    /**
     * Calculate the non-membership witnesses for given batch of elements. The function takes time proportional to the current
     * members and the number of non-members. To avoid taking too much memory, it breaks the computation into smaller batches.
     * @param nonMembers
     * @param secretKey
     * @param params
     * @param state
     * @param initialElementsStore
     * @param batchSize - Breaks down this large computation in batches of size `batchSize`.
     */
    nonMembershipWitnessesForBatch(nonMembers: Uint8Array[], state: IUniversalAccumulatorState, secretKey?: AccumulatorSecretKey, params?: AccumulatorParams, initialElementsStore?: IInitialElementsStore, batchSize?: number): Promise<NonMembershipWitness[]>;
    /**
     * Calculate the non-membership witnesses for given batch of elements when the product of differences of all members and
     * non-member (`d`) for each non-member is already computed.
     * @param nonMembers
     * @param d - array of products of difference of all members and each non-member
     * @param secretKey
     * @param params
     * @param state
     * @param initialElementsStore
     */
    nonMembershipWitnessesForBatchGivenD(nonMembers: Uint8Array[], d: Uint8Array[], secretKey?: AccumulatorSecretKey, params?: AccumulatorParams, state?: IUniversalAccumulatorState, initialElementsStore?: IInitialElementsStore): Promise<NonMembershipWitness[]>;
    verifyMembershipWitness(member: Uint8Array, witness: MembershipWitness, pk: AccumulatorPublicKey, params?: AccumulatorParams): boolean;
    verifyNonMembershipWitness(nonMember: Uint8Array, witness: NonMembershipWitness, pk: AccumulatorPublicKey, params?: AccumulatorParams): boolean;
    /**
     * The first few members of a universal accumulator are fixed for each curve. These should be added to the curve
     * before creating any witness and must never be removed.
     */
    static fixedInitialElements(): Uint8Array[];
    /**
     * Takes product of the form `initial_element_i + secret_key`.
     * @param initialElements
     * @param secretKey
     */
    static initialElementsProduct(initialElements: Uint8Array[], secretKey: AccumulatorSecretKey): Uint8Array;
    static combineInitialElementsProducts(products: Uint8Array[]): Uint8Array;
    static dForNonMembershipWitness(nonMember: Uint8Array, members: Uint8Array[]): Uint8Array;
    static dBatchForNonMembershipWitnesses(nonMembers: Uint8Array[], members: Uint8Array[]): Uint8Array[];
    /**
     * Throws an error if the element is part of the initial elements given that the initial element store is provided
     * @param element
     * @param store
     */
    checkElementAcceptable(element: Uint8Array, store?: IInitialElementsStore): Promise<void>;
    /**
     * Throws an error if any element of the batch is part of the initial elements given that the initial element store is provided
     * @param elements
     * @param store
     */
    checkElementBatchAcceptable(elements: Uint8Array[], store?: IInitialElementsStore): Promise<void>;
    /**
     * Checks to do before adding a new element
     * @param element
     * @param state
     * @param initialElementsStore
     * @protected
     */
    protected checkBeforeAdd(element: Uint8Array, state?: IAccumulatorState, initialElementsStore?: IInitialElementsStore): Promise<void>;
    /**
     * Checks to do before removing an existing element
     * @param element
     * @param state
     * @param initialElementsStore
     * @protected
     */
    protected checkBeforeRemove(element: Uint8Array, state?: IAccumulatorState, initialElementsStore?: IInitialElementsStore): Promise<void>;
    /**
     * Checks to do before adding several elements as a batch
     * @param elements
     * @param state
     * @param initialElementsStore
     * @protected
     */
    protected checkBeforeAddBatch(elements: Uint8Array[], state?: IAccumulatorState, initialElementsStore?: IInitialElementsStore): Promise<void>;
    /**
     * Checks to do before removing several elements as a batch
     * @param elements
     * @param state
     * @param initialElementsStore
     * @protected
     */
    protected checkBeforeRemoveBatch(elements: Uint8Array[], state?: IAccumulatorState, initialElementsStore?: IInitialElementsStore): Promise<void>;
    toJSON(): string;
    static fromJSON(json: string): UniversalAccumulator;
    static fromAccumulated(accumulated: Uint8Array): UniversalAccumulator;
}
//# sourceMappingURL=accumulator.d.ts.map