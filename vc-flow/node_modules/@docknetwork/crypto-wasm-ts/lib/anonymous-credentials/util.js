"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.saverStatement = exports.accumulatorStatement = exports.deepClone = exports.createWitEq = exports.getTransformedMinMax = exports.buildContextForProof = exports.flattenTill2ndLastKey = exports.dockSaverEncryptionGensUncompressed = exports.dockSaverEncryptionGens = exports.dockAccumulatorNonMemProvingKey = exports.dockAccumulatorMemProvingKey = exports.dockAccumulatorParams = void 0;
const accumulator_1 = require("../accumulator");
const types_and_consts_1 = require("./types-and-consts");
const saver_1 = require("../saver");
const flat_1 = require("flat");
const schema_1 = require("./schema");
const bbs_plus_1 = require("../bbs-plus");
const composite_proof_1 = require("../composite-proof");
function dockAccumulatorParams() {
    return accumulator_1.Accumulator.generateParams(types_and_consts_1.ACCUMULATOR_PARAMS_LABEL_BYTES);
}
exports.dockAccumulatorParams = dockAccumulatorParams;
function dockAccumulatorMemProvingKey() {
    return accumulator_1.MembershipProvingKey.generate(types_and_consts_1.ACCUMULATOR_PROVING_KEY_LABEL_BYTES);
}
exports.dockAccumulatorMemProvingKey = dockAccumulatorMemProvingKey;
function dockAccumulatorNonMemProvingKey() {
    return accumulator_1.NonMembershipProvingKey.generate(types_and_consts_1.ACCUMULATOR_PROVING_KEY_LABEL_BYTES);
}
exports.dockAccumulatorNonMemProvingKey = dockAccumulatorNonMemProvingKey;
function dockSaverEncryptionGens() {
    return saver_1.SaverEncryptionGens.generate(types_and_consts_1.SAVER_ENCRYPTION_GENS_BYTES);
}
exports.dockSaverEncryptionGens = dockSaverEncryptionGens;
function dockSaverEncryptionGensUncompressed() {
    return saver_1.SaverEncryptionGens.generate(types_and_consts_1.SAVER_ENCRYPTION_GENS_BYTES).decompress();
}
exports.dockSaverEncryptionGensUncompressed = dockSaverEncryptionGensUncompressed;
function flattenTill2ndLastKey(obj) {
    const flattened = {};
    const temp = (0, flat_1.flatten)(obj);
    for (const k of Object.keys(temp)) {
        // taken from https://stackoverflow.com/a/5555607
        const pos = k.lastIndexOf('.');
        const name = k.substring(0, pos);
        const t = k.substring(pos + 1);
        if (flattened[name] === undefined) {
            flattened[name] = {};
        }
        flattened[name][t] = temp[k];
    }
    const keys = Object.keys(flattened).sort();
    // @ts-ignore
    const values = keys.map((k) => flattened[k]);
    return [keys, values];
}
exports.flattenTill2ndLastKey = flattenTill2ndLastKey;
/**
 * The context passed to the proof contains the version and the presentation spec as well. This is done to bind the
 * presentation spec and the version cryptographically to the proof.
 * @param version
 * @param presSpec
 * @param context
 */
function buildContextForProof(version, presSpec, context) {
    const te = new TextEncoder();
    let ctx = Array.from(te.encode(version));
    if (context !== undefined) {
        if (typeof context === 'string') {
            ctx = ctx.concat(Array.from(te.encode(context)));
        }
        else {
            ctx = ctx.concat(Array.from(context));
        }
    }
    ctx = ctx.concat(Array.from(te.encode(presSpec.toJSON())));
    return new Uint8Array(ctx);
}
exports.buildContextForProof = buildContextForProof;
function getTransformedMinMax(name, valTyp, min, max) {
    let transformedMin, transformedMax;
    switch (valTyp.type) {
        case schema_1.ValueType.PositiveInteger:
            transformedMin = min;
            transformedMax = max;
            break;
        case schema_1.ValueType.Integer:
            transformedMin = bbs_plus_1.Encoder.integerToPositiveInt(valTyp.minimum)(min);
            transformedMax = bbs_plus_1.Encoder.integerToPositiveInt(valTyp.minimum)(max);
            break;
        case schema_1.ValueType.PositiveNumber:
            transformedMin = bbs_plus_1.Encoder.positiveDecimalNumberToPositiveInt(valTyp.decimalPlaces)(min);
            transformedMax = bbs_plus_1.Encoder.positiveDecimalNumberToPositiveInt(valTyp.decimalPlaces)(max);
            break;
        case schema_1.ValueType.Number:
            transformedMin = bbs_plus_1.Encoder.decimalNumberToPositiveInt(valTyp.minimum, valTyp.decimalPlaces)(min);
            transformedMax = bbs_plus_1.Encoder.decimalNumberToPositiveInt(valTyp.minimum, valTyp.decimalPlaces)(max);
            break;
        default:
            throw new Error(`${name} should be of numeric type as per schema but was ${valTyp}`);
    }
    return [transformedMin, transformedMax];
}
exports.getTransformedMinMax = getTransformedMinMax;
function createWitEq(eql, flattenedSchemas) {
    const witnessEq = new composite_proof_1.WitnessEqualityMetaStatement();
    for (const [cIdx, name] of eql) {
        const i = flattenedSchemas[cIdx][0].indexOf(name);
        if (i === -1) {
            throw new Error(`Attribute name ${name} was not found`);
        }
        witnessEq.addWitnessRef(cIdx, i);
    }
    return witnessEq;
}
exports.createWitEq = createWitEq;
function deepClone(obj) {
    return JSON.parse(JSON.stringify(obj));
}
exports.deepClone = deepClone;
function accumulatorStatement(checkType, pk, accumulated, setupParamsTrk) {
    let statement;
    if (!setupParamsTrk.hasAccumulatorParams()) {
        setupParamsTrk.addAccumulatorParams();
    }
    if (checkType === types_and_consts_1.MEM_CHECK_STR) {
        if (!setupParamsTrk.hasAccumulatorMemProvingKey()) {
            setupParamsTrk.addAccumulatorMemProvingKey();
        }
        statement = composite_proof_1.Statement.accumulatorMembershipFromSetupParamRefs(setupParamsTrk.accumParamsIdx, setupParamsTrk.add(composite_proof_1.SetupParam.vbAccumulatorPublicKey(pk)), setupParamsTrk.memPrkIdx, accumulated);
    }
    else {
        if (!setupParamsTrk.hasAccumulatorNonMemProvingKey()) {
            setupParamsTrk.addAccumulatorNonMemProvingKey();
        }
        statement = composite_proof_1.Statement.accumulatorNonMembershipFromSetupParamRefs(setupParamsTrk.accumParamsIdx, setupParamsTrk.add(composite_proof_1.SetupParam.vbAccumulatorPublicKey(pk)), setupParamsTrk.nonMemPrkIdx, accumulated);
    }
    return statement;
}
exports.accumulatorStatement = accumulatorStatement;
function saverStatement(forProver, chunkBitSize, commGensId, encKeyId, snarkKeyId, commGens, encKey, snarkKey, setupParamsTrk) {
    if (commGens instanceof saver_1.SaverChunkedCommitmentGensUncompressed &&
        encKey instanceof saver_1.SaverEncryptionKeyUncompressed &&
        ((forProver && snarkKey instanceof saver_1.SaverProvingKeyUncompressed) ||
            (!forProver && snarkKey instanceof saver_1.SaverVerifyingKeyUncompressed))) {
        if (!setupParamsTrk.hasEncryptionGensUncompressed()) {
            setupParamsTrk.addEncryptionGensUncompressed();
        }
        if (!setupParamsTrk.isTrackingParam(commGensId)) {
            setupParamsTrk.addForParamId(commGensId, composite_proof_1.SetupParam.saverCommitmentGensUncompressed(commGens));
        }
        if (!setupParamsTrk.isTrackingParam(encKeyId)) {
            setupParamsTrk.addForParamId(encKeyId, composite_proof_1.SetupParam.saverEncryptionKeyUncompressed(encKey));
        }
        if (!setupParamsTrk.isTrackingParam(snarkKeyId)) {
            setupParamsTrk.addForParamId(snarkKeyId, forProver
                ? composite_proof_1.SetupParam.saverProvingKeyUncompressed(snarkKey)
                : composite_proof_1.SetupParam.saverVerifyingKeyUncompressed(snarkKey));
        }
    }
    else if (commGens instanceof saver_1.SaverChunkedCommitmentGens &&
        encKey instanceof saver_1.SaverEncryptionKey &&
        ((forProver && snarkKey instanceof saver_1.SaverProvingKey) || (!forProver && snarkKey instanceof saver_1.SaverVerifyingKey))) {
        if (!setupParamsTrk.hasEncryptionGensCompressed()) {
            setupParamsTrk.addEncryptionGensCompressed();
        }
        if (!setupParamsTrk.isTrackingParam(commGensId)) {
            setupParamsTrk.addForParamId(commGensId, composite_proof_1.SetupParam.saverCommitmentGens(commGens));
        }
        if (!setupParamsTrk.isTrackingParam(encKeyId)) {
            setupParamsTrk.addForParamId(encKeyId, composite_proof_1.SetupParam.saverEncryptionKey(encKey));
        }
        if (!setupParamsTrk.isTrackingParam(snarkKeyId)) {
            setupParamsTrk.addForParamId(snarkKeyId, forProver ? composite_proof_1.SetupParam.saverProvingKey(snarkKey) : composite_proof_1.SetupParam.saverVerifyingKey(snarkKey));
        }
    }
    else {
        throw new Error('All SAVER parameters should either be compressed in uncompressed');
    }
    return forProver
        ? composite_proof_1.Statement.saverProverFromSetupParamRefs(setupParamsTrk.encGensIdx, setupParamsTrk.indexForParam(commGensId), setupParamsTrk.indexForParam(encKeyId), setupParamsTrk.indexForParam(snarkKeyId), chunkBitSize)
        : composite_proof_1.Statement.saverVerifierFromSetupParamRefs(setupParamsTrk.encGensIdx, setupParamsTrk.indexForParam(commGensId), setupParamsTrk.indexForParam(encKeyId), setupParamsTrk.indexForParam(snarkKeyId), chunkBitSize);
}
exports.saverStatement = saverStatement;
//# sourceMappingURL=util.js.map