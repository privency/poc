"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PresentationBuilder = void 0;
const versioned_1 = require("./versioned");
const bbs_plus_1 = require("../bbs-plus");
const composite_proof_1 = require("../composite-proof");
const legosnark_1 = require("../legosnark");
const r1cs_1 = require("../r1cs");
const schema_1 = require("./schema");
const sign_verify_js_objs_1 = require("../sign-verify-js-objs");
const types_and_consts_1 = require("./types-and-consts");
const presentation_specification_1 = require("./presentation-specification");
const presentation_1 = require("./presentation");
const accumulator_1 = require("../accumulator");
const util_1 = require("./util");
const flat_1 = require("flat");
const setup_params_tracker_1 = require("./setup-params-tracker");
class PresentationBuilder extends versioned_1.Versioned {
    constructor() {
        super(PresentationBuilder.VERSION);
        this.credentials = [];
        this.revealedAttributes = new Map();
        this.attributeEqualities = [];
        this.credStatuses = new Map();
        this.bounds = new Map();
        this.verifEnc = new Map();
        this.predicateParams = new Map();
        this.circomPredicates = new Map();
        this.spec = new presentation_specification_1.PresentationSpecification();
    }
    addCredential(credential, pk) {
        this.credentials.push([credential, pk]);
        return this.credentials.length - 1;
    }
    // TODO: Since all attr names below will have the full name (incl. top level attrib, check that no predicate on revealed attrs)
    // NOTE: This and several methods below expect nested attributes names with "dot"s as separators. Passing the nested structure is also
    // possible but will need more parsing and thus can be handled later.
    /**
     *
     * @param credIdx
     * @param attributeNames - Nested attribute names use the "dot" separator
     */
    markAttributesRevealed(credIdx, attributeNames) {
        this.validateCredIndex(credIdx);
        let revealed = this.revealedAttributes.get(credIdx);
        if (revealed === undefined) {
            revealed = new Set();
        }
        for (const a of attributeNames) {
            revealed.add(a);
        }
        this.revealedAttributes.set(credIdx, revealed);
    }
    /**
     *
     * @param equality - Array of reference to attribute where each reference is a pair with 1st item being credential index
     * and 2nd being attribute index in the flattened attribute list.
     */
    markAttributesEqual(...equality) {
        for (const aRef of equality) {
            this.validateCredIndex(aRef[0]);
        }
        this.attributeEqualities.push(equality);
    }
    /**
     * Add accumulator value, witness and public key for proving credential status.
     * @param credIdx
     * @param accumWitness
     * @param accumulated
     * @param accumPublicKey
     * @param extra
     */
    addAccumInfoForCredStatus(credIdx, accumWitness, accumulated, accumPublicKey, extra = {}) {
        this.validateCredIndex(credIdx);
        this.credStatuses.set(credIdx, [accumWitness, accumulated, accumPublicKey, extra]);
    }
    /**
     *
     * @param credIdx
     * @param attributeName - Nested attribute names use the "dot" separator
     * @param min
     * @param max
     * @param provingKeyId
     * @param provingKey
     */
    enforceBounds(credIdx, attributeName, min, max, provingKeyId, provingKey) {
        if (min >= max) {
            throw new Error(`Invalid bounds min=${min}, max=${max}`);
        }
        this.validateCredIndex(credIdx);
        let b = this.bounds.get(credIdx);
        if (b !== undefined) {
            if (b.get(attributeName) !== undefined) {
                throw new Error(`Already enforced bounds on credential index ${credIdx} and attribute name ${attributeName}`);
            }
        }
        else {
            b = new Map();
        }
        this.updatePredicateParams(provingKeyId, provingKey);
        b.set(attributeName, { min, max, paramId: provingKeyId });
        this.bounds.set(credIdx, b);
    }
    /**
     *
     * @param credIdx
     * @param attributeName - Nested attribute names use the "dot" separator
     * @param chunkBitSize
     * @param commGensId
     * @param encryptionKeyId
     * @param snarkPkId
     * @param commGens
     * @param encryptionKey
     * @param snarkPk
     */
    verifiablyEncrypt(credIdx, attributeName, chunkBitSize, commGensId, encryptionKeyId, snarkPkId, commGens, encryptionKey, snarkPk) {
        if (chunkBitSize !== 8 && chunkBitSize !== 16) {
            throw new Error(`Only 8 and 16 supported for chunkBitSize but given ${chunkBitSize}`);
        }
        this.validateCredIndex(credIdx);
        let v = this.verifEnc.get(credIdx);
        if (v !== undefined) {
            if (v.get(attributeName) !== undefined) {
                throw new Error(`Already enforced verifiable encryption on credential index ${credIdx} and attribute name ${attributeName}`);
            }
        }
        else {
            v = new Map();
        }
        this.updatePredicateParams(commGensId, commGens);
        this.updatePredicateParams(encryptionKeyId, encryptionKey);
        this.updatePredicateParams(snarkPkId, snarkPk);
        v.set(attributeName, {
            chunkBitSize,
            commitmentGensId: commGensId,
            encryptionKeyId: encryptionKeyId,
            snarkKeyId: snarkPkId
        });
        this.verifEnc.set(credIdx, v);
    }
    enforceCircomPredicate(credIdx, 
    // For each circuit private variable name, give its corresponding attribute names
    circuitPrivateVars, 
    // For each circuit public variable name, give its corresponding values
    circuitPublicVars, circuitId, provingKeyId, r1cs, wasmBytes, provingKey) {
        if (circuitPrivateVars.length == 0) {
            throw new Error('Provide at least one private variable mapping');
        }
        this.validateCredIndex(credIdx);
        this.updatePredicateParams(provingKeyId, provingKey);
        this.updatePredicateParams(PresentationBuilder.r1csParamId(circuitId), r1cs !== undefined ? (0, r1cs_1.getR1CS)(r1cs) : undefined);
        this.updatePredicateParams(PresentationBuilder.wasmParamId(circuitId), wasmBytes);
        let predicates = this.circomPredicates.get(credIdx);
        if (predicates === undefined) {
            predicates = [];
        }
        predicates.push([circuitPrivateVars, circuitPublicVars, circuitId, provingKeyId]);
        this.circomPredicates.set(credIdx, predicates);
    }
    /**
     * Create a presentation
     */
    finalize() {
        const numCreds = this.credentials.length;
        // Tracking maximum attributes across all credentials so that new values for signatures
        // params are only created when the need be. Check definition of `adapt` for more details.
        let maxAttribs = 2; // version and schema
        let sigParams = bbs_plus_1.SignatureParamsG1.generate(maxAttribs, types_and_consts_1.SIGNATURE_PARAMS_LABEL_BYTES);
        const statements = new composite_proof_1.Statements();
        const metaStatements = new composite_proof_1.MetaStatements();
        const witnesses = new composite_proof_1.Witnesses();
        // Flattened schemas of all the credentials of this builder
        const flattenedSchemas = [];
        // Store only needed encoded values of names and their indices. Maps cred index -> attribute index in schema -> encoded attribute
        const unrevealedMsgsEncoded = new Map();
        // For credentials with status, i.e. using accumulators, type is [credIndex, revCheckType, encoded (non)member]
        const credStatusAux = [];
        const setupParamsTrk = new setup_params_tracker_1.SetupParamsTracker();
        // Reset spec state (incase this method is called more than once)
        this.spec.reset();
        // Create statements and witnesses for proving possession of each credential, i.e. proof of knowledge of BBS+ sigs.
        // Also collect encoded attributes used in any predicate
        for (let i = 0; i < numCreds; i++) {
            const cred = this.credentials[i][0];
            const schema = cred.schema;
            const flattenedSchema = schema.flatten();
            const numAttribs = flattenedSchema[0].length;
            if (maxAttribs < numAttribs) {
                sigParams = sigParams.adapt(numAttribs);
                maxAttribs = numAttribs;
            }
            let revealedNames = this.revealedAttributes.get(i);
            if (revealedNames === undefined) {
                revealedNames = new Set();
            }
            // CredentialBuilder version, schema and 2 fields of revocation - registry id (denoting the accumulator) and the check
            // type, i.e. "membership" or "non-membership" are always revealed.
            revealedNames.add(types_and_consts_1.CRYPTO_VERSION_STR);
            revealedNames.add(types_and_consts_1.SCHEMA_STR);
            if (cred.credentialStatus !== undefined) {
                if (cred.credentialStatus[types_and_consts_1.ID_STR] === undefined ||
                    (cred.credentialStatus[types_and_consts_1.REV_CHECK_STR] !== types_and_consts_1.MEM_CHECK_STR &&
                        cred.credentialStatus[types_and_consts_1.REV_CHECK_STR] !== types_and_consts_1.NON_MEM_CHECK_STR)) {
                    throw new Error(`Credential for ${i} has invalid status ${cred.credentialStatus}`);
                }
                revealedNames.add(`${types_and_consts_1.STATUS_STR}.${types_and_consts_1.ID_STR}`);
                revealedNames.add(`${types_and_consts_1.STATUS_STR}.${types_and_consts_1.REV_CHECK_STR}`);
            }
            const [revealedAttrsEncoded, unrevealedAttrsEncoded, revealedAtts] = (0, sign_verify_js_objs_1.getRevealedAndUnrevealed)(cred.serializeForSigning(), revealedNames, schema.encoder);
            const statement = composite_proof_1.Statement.bbsSignatureFromSetupParamRefs(setupParamsTrk.add(composite_proof_1.SetupParam.bbsSignatureParamsG1(sigParams.adapt(numAttribs))), setupParamsTrk.add(composite_proof_1.SetupParam.bbsSignaturePublicKeyG2(this.credentials[i][1])), revealedAttrsEncoded, false);
            const witness = composite_proof_1.Witness.bbsSignature(cred.signature, unrevealedAttrsEncoded, false);
            statements.add(statement);
            witnesses.add(witness);
            let presentedStatus;
            if (cred.credentialStatus !== undefined) {
                const s = this.credStatuses.get(i);
                if (s === undefined) {
                    throw new Error(`No status details found for credential index ${i}`);
                }
                presentedStatus = {
                    [types_and_consts_1.ID_STR]: cred.credentialStatus[types_and_consts_1.ID_STR],
                    [types_and_consts_1.TYPE_STR]: types_and_consts_1.STATUS_TYPE_STR,
                    [types_and_consts_1.REV_CHECK_STR]: cred.credentialStatus[types_and_consts_1.REV_CHECK_STR],
                    accumulated: s[1],
                    extra: s[3]
                };
                credStatusAux.push([
                    i,
                    cred.credentialStatus[types_and_consts_1.REV_CHECK_STR],
                    schema.encoder.encodeMessage(`${types_and_consts_1.STATUS_STR}.${types_and_consts_1.REV_ID_STR}`, cred.credentialStatus[types_and_consts_1.REV_ID_STR])
                ]);
            }
            // Get encoded attributes which are used in bound check
            let attributeBounds;
            const bounds = this.bounds.get(i);
            if (bounds !== undefined && bounds.size > 0) {
                attributeBounds = {};
                const encodedAttrs = unrevealedMsgsEncoded.get(i) || new Map();
                for (const [name, b] of bounds.entries()) {
                    attributeBounds[name] = b;
                    const nameIdx = flattenedSchema[0].indexOf(name);
                    encodedAttrs.set(nameIdx, unrevealedAttrsEncoded.get(nameIdx));
                }
                attributeBounds = (0, flat_1.unflatten)(attributeBounds);
                unrevealedMsgsEncoded.set(i, encodedAttrs);
            }
            // Get encoded attributes which are used in verifiable encryption
            let attributeEncs;
            const encs = this.verifEnc.get(i);
            if (encs !== undefined && encs.size > 0) {
                attributeEncs = {};
                const encodedAttrs = unrevealedMsgsEncoded.get(i) || new Map();
                for (const [name, ve] of encs.entries()) {
                    const nameIdx = flattenedSchema[0].indexOf(name);
                    const valTyp = schema.typeOfName(name, flattenedSchema);
                    if (valTyp.type !== schema_1.ValueType.RevStr) {
                        throw new Error(`Attribute name ${name} of credential index ${i} should be a reversible string type but was ${valTyp}`);
                    }
                    attributeEncs[name] = ve;
                    encodedAttrs.set(nameIdx, unrevealedAttrsEncoded.get(nameIdx));
                }
                attributeEncs = (0, flat_1.unflatten)(attributeEncs);
                unrevealedMsgsEncoded.set(i, encodedAttrs);
            }
            function circomAttrForSpec(attrName, encodedAttrs) {
                const nameIdx = flattenedSchema[0].indexOf(attrName);
                encodedAttrs.set(nameIdx, unrevealedAttrsEncoded.get(nameIdx));
                return (0, flat_1.unflatten)({ [attrName]: null });
            }
            // Get encoded attributes used in predicates expressed as Circom programs
            let predicatesForSpec;
            const predicates = this.circomPredicates.get(i);
            if (predicates !== undefined && predicates.length > 0) {
                predicatesForSpec = [];
                const encodedAttrs = unrevealedMsgsEncoded.get(i) || new Map();
                predicates.forEach((predicate) => {
                    const privateVars = predicate[0];
                    const privateVarsForSpec = [];
                    privateVars.forEach(([varName, attrName]) => {
                        if (Array.isArray(attrName)) {
                            const attributeName = [];
                            attrName.forEach((a) => {
                                // @ts-ignore
                                attributeName.push(circomAttrForSpec(a, encodedAttrs));
                            });
                            privateVarsForSpec.push({
                                varName,
                                attributeName
                            });
                        }
                        else {
                            privateVarsForSpec.push({
                                varName,
                                // @ts-ignore
                                attributeName: circomAttrForSpec(attrName, encodedAttrs)
                            });
                        }
                    });
                    // @ts-ignore
                    predicatesForSpec.push({
                        privateVars: privateVarsForSpec,
                        publicVars: predicate[1].map(([n, v]) => {
                            return {
                                varName: n,
                                value: v
                            };
                        }),
                        circuitId: predicate[2],
                        snarkKeyId: predicate[3]
                    });
                });
                unrevealedMsgsEncoded.set(i, encodedAttrs);
            }
            const ver = revealedAtts[types_and_consts_1.CRYPTO_VERSION_STR];
            const sch = revealedAtts[types_and_consts_1.SCHEMA_STR];
            delete revealedAtts[types_and_consts_1.CRYPTO_VERSION_STR];
            delete revealedAtts[types_and_consts_1.SCHEMA_STR];
            delete revealedAtts[types_and_consts_1.STATUS_STR];
            this.spec.addPresentedCredential(ver, sch, revealedAtts, presentedStatus, attributeBounds, attributeEncs, predicatesForSpec);
            flattenedSchemas.push(flattenedSchema);
        }
        // Create statements and witnesses for accumulators used in credential status
        credStatusAux.forEach(([i, t, value]) => {
            const s = this.credStatuses.get(i);
            if (s === undefined) {
                throw new Error(`No status details found for credential index ${i}`);
            }
            const [wit, acc, pk] = s;
            let witness;
            if (t === types_and_consts_1.MEM_CHECK_STR) {
                if (!(wit instanceof accumulator_1.MembershipWitness)) {
                    throw new Error(`Expected membership witness but got non-membership witness for credential index ${i}`);
                }
                witness = composite_proof_1.Witness.accumulatorMembership(value, wit);
            }
            else {
                if (!(wit instanceof accumulator_1.NonMembershipWitness)) {
                    throw new Error(`Expected non-membership witness but got membership witness for credential index ${i}`);
                }
                witness = composite_proof_1.Witness.accumulatorNonMembership(value, wit);
            }
            const statement = (0, util_1.accumulatorStatement)(t, pk, acc, setupParamsTrk);
            const sIdx = statements.add(statement);
            witnesses.add(witness);
            const witnessEq = new composite_proof_1.WitnessEqualityMetaStatement();
            witnessEq.addWitnessRef(i, flattenedSchemas[i][0].indexOf(`${types_and_consts_1.STATUS_STR}.${types_and_consts_1.REV_ID_STR}`));
            witnessEq.addWitnessRef(sIdx, 0);
            metaStatements.addWitnessEquality(witnessEq);
        });
        // Create meta-statements for enforcing attribute equalities
        for (const eql of this.attributeEqualities) {
            metaStatements.addWitnessEquality((0, util_1.createWitEq)(eql, flattenedSchemas));
            this.spec.attributeEqualities.push(eql);
        }
        // For enforcing attribute bounds, add statement and witness
        for (const [cId, bounds] of this.bounds.entries()) {
            const dataSortedByNameIdx = [];
            for (const [name, b] of bounds.entries()) {
                const nameIdx = flattenedSchemas[cId][0].indexOf(name);
                dataSortedByNameIdx.push([nameIdx, name, b]);
            }
            // Sort by attribute index so that both prover and verifier create statements and witnesses in the same order
            dataSortedByNameIdx.sort(function (a, b) {
                return a[0] - b[0];
            });
            dataSortedByNameIdx.forEach(([nameIdx, name, { min, max, paramId }]) => {
                var _a;
                const valTyp = schema_1.CredentialSchema.typeOfName(name, flattenedSchemas[cId]);
                const [transformedMin, transformedMax] = (0, util_1.getTransformedMinMax)(name, valTyp, min, max);
                const param = this.predicateParams.get(paramId);
                this.addLegoProvingKeyToTracker(paramId, param, setupParamsTrk, cId);
                const statement = composite_proof_1.Statement.boundCheckProverFromSetupParamRefs(transformedMin, transformedMax, setupParamsTrk.indexForParam(paramId));
                const encodedAttrVal = (_a = unrevealedMsgsEncoded.get(cId)) === null || _a === void 0 ? void 0 : _a.get(nameIdx);
                witnesses.add(composite_proof_1.Witness.boundCheckLegoGroth16(encodedAttrVal));
                const sIdx = statements.add(statement);
                const witnessEq = new composite_proof_1.WitnessEqualityMetaStatement();
                witnessEq.addWitnessRef(cId, nameIdx);
                witnessEq.addWitnessRef(sIdx, 0);
                metaStatements.addWitnessEquality(witnessEq);
            });
        }
        // For adding ciphertexts corresponding to verifiably encrypted attributes in the presentation
        const credAttrToSId = new Map();
        // For enforcing attribute encryption, add statement and witness
        for (const [cId, verEnc] of this.verifEnc.entries()) {
            const dataSortedByNameIdx = [];
            for (const [name, ve] of verEnc.entries()) {
                const nameIdx = flattenedSchemas[cId][0].indexOf(name);
                dataSortedByNameIdx.push([nameIdx, name, ve]);
            }
            // Sort by attribute index so that both prover and verifier create statements and witnesses in the same order
            dataSortedByNameIdx.sort(function (a, b) {
                return a[0] - b[0];
            });
            const attrToSid = new Map();
            dataSortedByNameIdx.forEach(([nameIdx, name, { chunkBitSize, commitmentGensId, encryptionKeyId, snarkKeyId }]) => {
                var _a;
                const commGens = this.predicateParams.get(commitmentGensId);
                if (commGens === undefined) {
                    throw new Error(`Predicate param for id ${commitmentGensId} not found`);
                }
                const encKey = this.predicateParams.get(encryptionKeyId);
                if (encKey === undefined) {
                    throw new Error(`Predicate param for id ${encryptionKeyId} not found`);
                }
                const snarkPk = this.predicateParams.get(snarkKeyId);
                if (snarkPk === undefined) {
                    throw new Error(`Predicate param for id ${snarkKeyId} not found`);
                }
                const statement = (0, util_1.saverStatement)(true, chunkBitSize, commitmentGensId, encryptionKeyId, snarkKeyId, commGens, encKey, snarkPk, setupParamsTrk);
                const encodedAttrVal = (_a = unrevealedMsgsEncoded.get(cId)) === null || _a === void 0 ? void 0 : _a.get(nameIdx);
                witnesses.add(composite_proof_1.Witness.saver(encodedAttrVal));
                const sIdx = statements.add(statement);
                const witnessEq = new composite_proof_1.WitnessEqualityMetaStatement();
                witnessEq.addWitnessRef(cId, nameIdx);
                witnessEq.addWitnessRef(sIdx, 0);
                metaStatements.addWitnessEquality(witnessEq);
                attrToSid.set(name, sIdx);
            });
            if (attrToSid.size > 0) {
                credAttrToSId.set(cId, attrToSid);
            }
        }
        // For enforcing Circom predicates, add statement and witness
        for (const [cId, predicates] of this.circomPredicates.entries()) {
            predicates.forEach(([privateVars, publicVars, circuitId, snarkKeyId]) => {
                const snarkKey = this.predicateParams.get(snarkKeyId);
                const r1csId = PresentationBuilder.r1csParamId(circuitId);
                const r1cs = this.predicateParams.get(r1csId);
                const wasmId = PresentationBuilder.wasmParamId(circuitId);
                const wasm = this.predicateParams.get(wasmId);
                this.addLegoProvingKeyToTracker(snarkKeyId, snarkKey, setupParamsTrk, cId);
                if (r1cs === undefined || wasm === undefined) {
                    throw new Error('Both WASM and R1CS should be present');
                }
                if (!setupParamsTrk.isTrackingParam(r1csId)) {
                    setupParamsTrk.addForParamId(r1csId, composite_proof_1.SetupParam.r1cs(r1cs));
                }
                if (!setupParamsTrk.isTrackingParam(wasmId)) {
                    setupParamsTrk.addForParamId(wasmId, composite_proof_1.SetupParam.bytes(wasm));
                }
                const statement = composite_proof_1.Statement.r1csCircomProverFromSetupParamRefs(setupParamsTrk.indexForParam(r1csId), setupParamsTrk.indexForParam(wasmId), setupParamsTrk.indexForParam(snarkKeyId));
                const sIdx = statements.add(statement);
                function addWitnessEqualityAndReturnEncodedAttr(name) {
                    var _a;
                    const nameIdx = flattenedSchemas[cId][0].indexOf(name);
                    const witnessEq = new composite_proof_1.WitnessEqualityMetaStatement();
                    witnessEq.addWitnessRef(cId, nameIdx);
                    witnessEq.addWitnessRef(sIdx, predicateWitnessIdx++);
                    metaStatements.addWitnessEquality(witnessEq);
                    return (_a = unrevealedMsgsEncoded.get(cId)) === null || _a === void 0 ? void 0 : _a.get(nameIdx);
                }
                let predicateWitnessIdx = 0;
                const circuitInputs = new r1cs_1.CircomInputs();
                // For each private input, set its value as the corresponding attribute and set the witness equality
                privateVars.forEach(([varName, name]) => {
                    if (Array.isArray(name)) {
                        circuitInputs.setPrivateArrayInput(varName, name.map((n) => {
                            return addWitnessEqualityAndReturnEncodedAttr(n);
                        }));
                    }
                    else {
                        circuitInputs.setPrivateInput(varName, addWitnessEqualityAndReturnEncodedAttr(name));
                    }
                });
                publicVars.forEach(([varName, value]) => {
                    if (Array.isArray(value)) {
                        circuitInputs.setPublicArrayInput(varName, value);
                    }
                    else {
                        circuitInputs.setPublicInput(varName, value);
                    }
                });
                witnesses.add(composite_proof_1.Witness.r1csCircomWitness(circuitInputs));
            });
        }
        // The version and spec are also added to the proof thus binding these to the proof cryptographically.
        const ctx = (0, util_1.buildContextForProof)(this.version, this.spec, this._context);
        this._proofSpec = new composite_proof_1.QuasiProofSpecG1(statements, metaStatements, setupParamsTrk.setupParams, ctx);
        this.proof = composite_proof_1.CompositeProofG1.generateUsingQuasiProofSpec(this._proofSpec, witnesses, this._nonce);
        let attributeCiphertexts;
        if (credAttrToSId.size > 0) {
            const allSIds = [];
            for (const v of credAttrToSId.values()) {
                for (const sId of v.values()) {
                    allSIds.push(sId);
                }
            }
            const ciphertexts = this.proof.getSaverCiphertexts(allSIds);
            attributeCiphertexts = new Map();
            for (const [i, v] of credAttrToSId.entries()) {
                const m = {};
                for (const [name, sId] of v.entries()) {
                    let curM = m;
                    // name is a flattened name, like credentialSubject.nesting1.nesting2.name
                    const nameParts = name.split('.');
                    for (let j = 0; j < nameParts.length - 1; j++) {
                        if (curM[nameParts[j]] === undefined) {
                            curM[nameParts[j]] = {};
                        }
                        // `curM` refers to this inner object of `m`
                        curM = curM[nameParts[j]];
                    }
                    curM[nameParts[nameParts.length - 1]] = ciphertexts[allSIds.indexOf(sId)];
                }
                attributeCiphertexts.set(i, m);
            }
        }
        return new presentation_1.Presentation(this.version, this.spec, this.proof, attributeCiphertexts, this._context, this._nonce);
    }
    get context() {
        return this._context;
    }
    set context(context) {
        this._context = context;
    }
    get nonce() {
        return this._nonce;
    }
    set nonce(nonce) {
        this._nonce = nonce;
    }
    validateCredIndex(credIdx) {
        if (credIdx >= this.credentials.length) {
            throw new Error(`Invalid credential index ${credIdx}. Number of credentials is ${this.credentials.length}`);
        }
    }
    updatePredicateParams(id, val) {
        if (val !== undefined) {
            if (this.predicateParams.has(id)) {
                throw new Error(`Predicate params already exists for id ${id}`);
            }
            this.predicateParams.set(id, val);
        }
    }
    static r1csParamId(circuitId) {
        return `${circuitId}__r1cs__`;
    }
    static wasmParamId(circuitId) {
        return `${circuitId}__wasm__`;
    }
    addLegoProvingKeyToTracker(paramId, param, setupParamsTrk, credentialIdx) {
        if (param instanceof legosnark_1.LegoProvingKey) {
            if (!setupParamsTrk.isTrackingParam(paramId)) {
                setupParamsTrk.addForParamId(paramId, composite_proof_1.SetupParam.legosnarkProvingKey(param));
            }
        }
        else if (param instanceof legosnark_1.LegoProvingKeyUncompressed) {
            if (!setupParamsTrk.isTrackingParam(paramId)) {
                setupParamsTrk.addForParamId(paramId, composite_proof_1.SetupParam.legosnarkProvingKeyUncompressed(param));
            }
        }
        else {
            throw new Error(`Predicate param id ${paramId} (for credential index ${credentialIdx}) was expected to be a Legosnark proving key but was ${param}`);
        }
    }
}
exports.PresentationBuilder = PresentationBuilder;
// NOTE: Follows semver and must be updated accordingly when the logic of this class changes or the
// underlying crypto changes.
PresentationBuilder.VERSION = '0.0.1';
//# sourceMappingURL=presentation-builder.js.map