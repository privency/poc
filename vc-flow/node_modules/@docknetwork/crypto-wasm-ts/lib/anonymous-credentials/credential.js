"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Credential = void 0;
const versioned_1 = require("./versioned");
const schema_1 = require("./schema");
const types_and_consts_1 = require("./types-and-consts");
const bbs_plus_1 = require("../bbs-plus");
const sign_verify_js_objs_1 = require("../sign-verify-js-objs");
const util_1 = require("../util");
const bs58_1 = __importDefault(require("bs58"));
class Credential extends versioned_1.Versioned {
    constructor(version, schema, subject, topLevelFields, sig, credStatus) {
        super(version);
        this.schema = schema;
        this.subject = subject;
        this.topLevelFields = topLevelFields;
        this.signature = sig;
        this.credentialStatus = credStatus;
    }
    verify(publicKey, signatureParams) {
        const cred = this.serializeForSigning();
        return (0, sign_verify_js_objs_1.verifyMessageObject)(cred, this.signature, publicKey, signatureParams !== undefined ? signatureParams : types_and_consts_1.SIGNATURE_PARAMS_LABEL_BYTES, this.schema.encoder);
    }
    getTopLevelField(name) {
        const v = this.topLevelFields.get(name);
        if (v === undefined) {
            throw new Error(`Top level field ${name} is absent`);
        }
        return v;
    }
    /**
     * A credential will have at least some proof metadata like the type or purpose. This adds those defaults to the
     * given object.
     * @param s
     */
    static applyDefaultProofMetadataIfNeeded(s) {
        if (!s['proof']) {
            s['proof'] = {
                type: types_and_consts_1.CRED_PROOF_TYPE
            };
        }
    }
    serializeForSigning() {
        var _a;
        // Schema should be part of the credential signature to prevent the credential holder from convincing a verifier of a manipulated schema
        const s = {
            [types_and_consts_1.CRYPTO_VERSION_STR]: this.version,
            // Converting the schema to a JSON string rather than keeping it JSO object to avoid creating extra fields while
            // signing which makes the implementation more expensive as one sig param is needed for each field.
            [types_and_consts_1.SCHEMA_STR]: JSON.stringify((_a = this.schema) === null || _a === void 0 ? void 0 : _a.toJSON()),
            [types_and_consts_1.SUBJECT_STR]: this.subject
        };
        for (const [k, v] of this.topLevelFields.entries()) {
            s[k] = v;
        }
        if (this.credentialStatus !== undefined) {
            s[types_and_consts_1.STATUS_STR] = this.credentialStatus;
        }
        Credential.applyDefaultProofMetadataIfNeeded(s);
        delete s['proof']['proofValue'];
        return s;
    }
    toJSON() {
        const j = {};
        j['cryptoVersion'] = this._version;
        j['credentialSchema'] = JSON.stringify(this.schema.toJSON());
        j['credentialSubject'] = this.subject;
        if (this.credentialStatus !== undefined) {
            j['credentialStatus'] = this.credentialStatus;
        }
        for (const [k, v] of this.topLevelFields.entries()) {
            j[k] = v;
        }
        Credential.applyDefaultProofMetadataIfNeeded(j);
        j['proof']['proofValue'] = bs58_1.default.encode(this.signature.bytes);
        return j;
    }
    toJSONWithJsonLdContext() {
        let j = this.toJSON();
        const jctx = this.schema.getJsonLdContext();
        // TODO: Uncomment me. The correct context should be "something like" below. See comments over the commented function `getJsonLdContext` for details
        // jctx['@context'][1]['proof'] = {
        //   type: 'schema:Text',
        //   proofValue: 'schema:Text',
        // };
        jctx['@context'][1]['proof'] = schema_1.CredentialSchema.getDummyContextValue('proof');
        jctx['@context'][1]['type'] = schema_1.CredentialSchema.getDummyContextValue('type');
        jctx['@context'][1]['proofValue'] = schema_1.CredentialSchema.getDummyContextValue('proofValue');
        j = Object.assign(Object.assign({}, j), jctx);
        return j;
    }
    static fromJSON(j, proofValue) {
        // @ts-ignore
        const { cryptoVersion, credentialSchema, credentialSubject, credentialStatus, proof } = j, custom = __rest(j, ["cryptoVersion", "credentialSchema", "credentialSubject", "credentialStatus", "proof"]);
        // Ensure proof is present
        if (!proof) {
            throw new Error(`Credential.fromJSON expects proof to be defined in object`);
        }
        // Ensure proof type is correct
        if (proof['type'] !== types_and_consts_1.CRED_PROOF_TYPE) {
            throw new Error(`Invalid proof type ${proof['type']}`);
        }
        // Ensure we trim off proofValue as that isnt signed
        const trimmedProof = Object.assign({}, proof);
        if (!proofValue) {
            if (trimmedProof && trimmedProof.proofValue) {
                proofValue = trimmedProof.proofValue;
                delete trimmedProof.proofValue;
            }
            else {
                throw new Error('A proofValue was neither provided nor was provided');
            }
        }
        const sig = new bbs_plus_1.SignatureG1(bs58_1.default.decode(proofValue));
        const topLevelFields = new Map();
        Object.keys(custom).forEach((k) => {
            topLevelFields.set(k, custom[k]);
        });
        // Note: There is some inconsistency here. While serialization "proof" doesn't exist in `topLevelFields` but during
        // deserialization, it is. This doesn't break anything for now but can cause unexpected errors in future as the
        // deserialized object won't be exactly same as the object that was serialized.
        if (!(0, util_1.isEmptyObject)(trimmedProof)) {
            topLevelFields.set('proof', trimmedProof);
        }
        return new Credential(cryptoVersion, schema_1.CredentialSchema.fromJSON(typeof credentialSchema === 'string' ? JSON.parse(credentialSchema) : credentialSchema), credentialSubject, topLevelFields, sig, credentialStatus);
    }
}
exports.Credential = Credential;
//# sourceMappingURL=credential.js.map