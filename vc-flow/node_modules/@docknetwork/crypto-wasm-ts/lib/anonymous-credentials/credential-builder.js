"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CredentialBuilder = exports.DefaultSigningOpts = void 0;
const sign_verify_js_objs_1 = require("../sign-verify-js-objs");
const versioned_1 = require("./versioned");
const schema_1 = require("./schema");
const types_and_consts_1 = require("./types-and-consts");
const credential_1 = require("./credential");
const flat_1 = require("flat");
const util_1 = require("../util");
exports.DefaultSigningOpts = {
    requireSameFieldsAsSchema: true
};
/**
 * Create a credential
 */
class CredentialBuilder extends versioned_1.Versioned {
    constructor() {
        super(CredentialBuilder.VERSION);
        this._topLevelFields = new Map();
    }
    /**
     * Currently supports only 1 subject. Nothing tricky in supporting more but more parsing and serialization work
     * @param subject
     */
    set subject(subject) {
        this._subject = subject;
    }
    // @ts-ignore
    get subject() {
        return this._subject;
    }
    set schema(schema) {
        this._schema = schema;
    }
    // @ts-ignore
    get schema() {
        return this._schema;
    }
    set credStatus(subject) {
        this._credStatus = subject;
    }
    get credStatus() {
        return this._credStatus;
    }
    setCredentialStatus(registryId, revCheck, memberValue) {
        if (revCheck !== types_and_consts_1.MEM_CHECK_STR && revCheck !== types_and_consts_1.NON_MEM_CHECK_STR) {
            throw new Error(`Revocation check should be either ${types_and_consts_1.MEM_CHECK_STR} or ${types_and_consts_1.NON_MEM_CHECK_STR} but was ${revCheck}`);
        }
        this._credStatus = {
            [types_and_consts_1.TYPE_STR]: types_and_consts_1.STATUS_TYPE_STR,
            [types_and_consts_1.ID_STR]: registryId,
            [types_and_consts_1.REV_CHECK_STR]: revCheck,
            [types_and_consts_1.REV_ID_STR]: memberValue
        };
    }
    get signature() {
        return this._sig;
    }
    setTopLevelField(name, value) {
        if (value !== undefined) {
            this._topLevelFields.set(name, value);
        }
    }
    getTopLevelField(name) {
        const v = this._topLevelFields.get(name);
        if (v === undefined) {
            throw new Error(`Top level field ${name} is absent`);
        }
        return v;
    }
    /**
     * Serializes and signs creating a credential.
     * Expects the credential to have the same fields as schema. This is intentional to always communicate to the
     * verifier the full structure of the credential.
     *
     * @param secretKey
     * @param signatureParams - This makes bulk issuance of credentials with same number of attributes faster because the
     * signature params don't have to be generated.
     * @param signingOpts
     */
    sign(secretKey, signatureParams, signingOpts) {
        if (signingOpts === undefined) {
            signingOpts = exports.DefaultSigningOpts;
        }
        const cred = this.updateSchemaIfNeeded(signingOpts);
        const schema = this.schema;
        const signed = (0, sign_verify_js_objs_1.signMessageObject)(cred, secretKey, signatureParams !== undefined ? signatureParams : types_and_consts_1.SIGNATURE_PARAMS_LABEL_BYTES, schema.encoder);
        this._encodedAttributes = signed.encodedMessages;
        this._sig = signed.signature;
        return new credential_1.Credential(this._version, schema, 
        // @ts-ignore
        this._subject, this._topLevelFields, this._sig, this._credStatus);
    }
    serializeForSigning() {
        var _a;
        // Schema should be part of the credential signature to prevent the credential holder from convincing a verifier of a manipulated schema
        const s = {
            [types_and_consts_1.CRYPTO_VERSION_STR]: this._version,
            [types_and_consts_1.SCHEMA_STR]: JSON.stringify((_a = this.schema) === null || _a === void 0 ? void 0 : _a.toJSON()),
            [types_and_consts_1.SUBJECT_STR]: this._subject
        };
        for (const [k, v] of this._topLevelFields.entries()) {
            s[k] = v;
        }
        if (this._credStatus !== undefined) {
            s[types_and_consts_1.STATUS_STR] = this._credStatus;
        }
        credential_1.Credential.applyDefaultProofMetadataIfNeeded(s);
        return s;
    }
    /**
     * When schema doesn't match the credential, create a new appropriate schema and update the credential. Returns the
     * serialized credential
     * @param signingOpts
     */
    updateSchemaIfNeeded(signingOpts) {
        var _a;
        const cred = this.serializeForSigning();
        const schema = this.schema;
        if (signingOpts && !CredentialBuilder.hasSameFieldsAsSchema(cred, schema)) {
            if (signingOpts.requireSameFieldsAsSchema) {
                throw new Error('Credential does not have the fields as schema');
            }
            else {
                // Generate new schema
                this.schema = schema_1.CredentialSchema.generateAppropriateSchema(cred, schema);
                cred[types_and_consts_1.SCHEMA_STR] = JSON.stringify((_a = this.schema) === null || _a === void 0 ? void 0 : _a.toJSON());
            }
        }
        return cred;
    }
    static hasSameFieldsAsSchema(cred, schema) {
        return (0, util_1.areArraysEqual)(schema.flatten()[0], Object.keys((0, flat_1.flatten)(cred)).sort());
    }
}
exports.CredentialBuilder = CredentialBuilder;
// NOTE: Follows semver and must be updated accordingly when the logic of this class changes or the
// underlying crypto changes.
CredentialBuilder.VERSION = '0.1.0';
//# sourceMappingURL=credential-builder.js.map