"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Presentation = void 0;
const versioned_1 = require("./versioned");
const presentation_specification_1 = require("./presentation-specification");
const composite_proof_1 = require("../composite-proof");
const bbs_plus_1 = require("../bbs-plus");
const schema_1 = require("./schema");
const flat_1 = require("flat");
const types_and_consts_1 = require("./types-and-consts");
const util_1 = require("./util");
const legosnark_1 = require("../legosnark");
const saver_1 = require("../saver");
const bs58_1 = __importDefault(require("bs58"));
const setup_params_tracker_1 = require("./setup-params-tracker");
const util_2 = require("../util");
class Presentation extends versioned_1.Versioned {
    constructor(version, spec, proof, attributeCiphertexts, context, nonce) {
        super(version);
        this.spec = spec;
        this.proof = proof;
        this.attributeCiphertexts = attributeCiphertexts;
        this.context = context;
        this.nonce = nonce;
    }
    /**
     *
     * @param publicKeys - Array of keys in the order of credentials in the presentation.
     * @param accumulatorPublicKeys - Mapping credential index -> accumulator public key
     * @param predicateParams - Setup params for various predicates
     * @param circomOutputs - Values for the outputs variables of the Circom programs used for predicates
     */
    verify(publicKeys, accumulatorPublicKeys, predicateParams, circomOutputs) {
        const numCreds = this.spec.credentials.length;
        if (publicKeys.length != numCreds) {
            throw new Error(`Supply same no of public keys as creds. ${publicKeys.length} != ${numCreds}`);
        }
        let maxAttribs = 2; // version and schema
        let sigParams = bbs_plus_1.SignatureParamsG1.generate(maxAttribs, types_and_consts_1.SIGNATURE_PARAMS_LABEL_BYTES);
        const statements = new composite_proof_1.Statements();
        const metaStatements = new composite_proof_1.MetaStatements();
        const flattenedSchemas = [];
        // For credentials with status, i.e. using accumulators, type is [credIndex, revCheckType, accumulator]
        const credStatusAux = [];
        const boundsAux = [];
        const verEncAux = [];
        const circomAux = [];
        const setupParamsTrk = new setup_params_tracker_1.SetupParamsTracker();
        for (let i = 0; i < this.spec.credentials.length; i++) {
            const presentedCred = this.spec.credentials[i];
            const presentedCredSchema = schema_1.CredentialSchema.fromJSON(JSON.parse(presentedCred.schema));
            const flattenedSchema = presentedCredSchema.flatten();
            const numAttribs = flattenedSchema[0].length;
            const revealedEncoded = Presentation.encodeRevealed(i, presentedCred, presentedCredSchema, flattenedSchema[0]);
            if (maxAttribs < numAttribs) {
                sigParams = sigParams.adapt(numAttribs);
                maxAttribs = numAttribs;
            }
            const statement = composite_proof_1.Statement.bbsSignatureFromSetupParamRefs(setupParamsTrk.add(composite_proof_1.SetupParam.bbsSignatureParamsG1(sigParams.adapt(numAttribs))), setupParamsTrk.add(composite_proof_1.SetupParam.bbsSignaturePublicKeyG2(publicKeys[i])), revealedEncoded, false);
            statements.add(statement);
            flattenedSchemas.push(flattenedSchema);
            if (presentedCred.status !== undefined) {
                // The input validation and security checks for these have been done as part of encoding revealed attributes
                credStatusAux.push([i, presentedCred.status[types_and_consts_1.REV_CHECK_STR], presentedCred.status.accumulated]);
            }
            if (presentedCred.bounds !== undefined) {
                boundsAux.push([i, presentedCred.bounds]);
            }
            if (presentedCred.verifiableEncryptions !== undefined) {
                verEncAux.push([i, presentedCred.verifiableEncryptions]);
            }
            if (presentedCred.circomPredicates !== undefined) {
                circomAux.push([i, presentedCred.circomPredicates]);
            }
        }
        credStatusAux.forEach(([i, t, accum]) => {
            // let statement;
            const pk = accumulatorPublicKeys === null || accumulatorPublicKeys === void 0 ? void 0 : accumulatorPublicKeys.get(i);
            if (pk === undefined) {
                throw new Error(`Accumulator public key wasn't provided for credential index ${i}`);
            }
            const statement = (0, util_1.accumulatorStatement)(t, pk, accum, setupParamsTrk);
            const sIdx = statements.add(statement);
            const witnessEq = new composite_proof_1.WitnessEqualityMetaStatement();
            witnessEq.addWitnessRef(i, flattenedSchemas[i][0].indexOf(`${types_and_consts_1.STATUS_STR}.${types_and_consts_1.REV_ID_STR}`));
            witnessEq.addWitnessRef(sIdx, 0);
            metaStatements.addWitnessEquality(witnessEq);
        });
        for (const eql of this.spec.attributeEqualities) {
            metaStatements.addWitnessEquality((0, util_1.createWitEq)(eql, flattenedSchemas));
        }
        boundsAux.forEach(([i, b]) => {
            const bounds = (0, util_1.flattenTill2ndLastKey)(b);
            bounds[0].forEach((name, j) => {
                const nameIdx = flattenedSchemas[i][0].indexOf(name);
                const valTyp = schema_1.CredentialSchema.typeOfName(name, flattenedSchemas[i]);
                const [min, max] = [bounds[1][j]['min'], bounds[1][j]['max']];
                const [transformedMin, transformedMax] = (0, util_1.getTransformedMinMax)(name, valTyp, min, max);
                const paramId = bounds[1][j]['paramId'];
                const param = predicateParams === null || predicateParams === void 0 ? void 0 : predicateParams.get(paramId);
                Presentation.addLegoVerifyingKeyToTracker(paramId, param, setupParamsTrk);
                const statement = composite_proof_1.Statement.boundCheckVerifierFromSetupParamRefs(transformedMin, transformedMax, setupParamsTrk.indexForParam(paramId));
                const sIdx = statements.add(statement);
                const witnessEq = new composite_proof_1.WitnessEqualityMetaStatement();
                witnessEq.addWitnessRef(i, nameIdx);
                witnessEq.addWitnessRef(sIdx, 0);
                metaStatements.addWitnessEquality(witnessEq);
            });
        });
        verEncAux.forEach(([i, v]) => {
            const verEnc = (0, util_1.flattenTill2ndLastKey)(v);
            verEnc[0].forEach((name, j) => {
                const valTyp = schema_1.CredentialSchema.typeOfName(name, flattenedSchemas[i]);
                if (valTyp.type !== schema_1.ValueType.RevStr) {
                    throw new Error(`Attribute name ${name} of credential index ${i} should be a reversible string type but was ${valTyp}`);
                }
                const nameIdx = flattenedSchemas[i][0].indexOf(name);
                const commGensId = verEnc[1][j]['commitmentGensId'];
                if (commGensId === undefined) {
                    throw new Error(`Commitment gens id not found for ${name}`);
                }
                const commGens = predicateParams === null || predicateParams === void 0 ? void 0 : predicateParams.get(commGensId);
                if (commGens === undefined) {
                    throw new Error(`Commitment gens not found for id ${commGensId}`);
                }
                const encKeyId = verEnc[1][j]['encryptionKeyId'];
                if (encKeyId === undefined) {
                    throw new Error(`Encryption key id not found for ${name}`);
                }
                const encKey = predicateParams === null || predicateParams === void 0 ? void 0 : predicateParams.get(encKeyId);
                if (encKey === undefined) {
                    throw new Error(`Encryption key not found for id ${encKey}`);
                }
                const snarkVkId = verEnc[1][j]['snarkKeyId'];
                if (snarkVkId === undefined) {
                    throw new Error(`Snark verification key id not found for ${name}`);
                }
                const snarkVk = predicateParams === null || predicateParams === void 0 ? void 0 : predicateParams.get(snarkVkId);
                if (snarkVk === undefined) {
                    throw new Error(`Snark verification key not found for id ${snarkVkId}`);
                }
                const chunkBitSize = verEnc[1][j]['chunkBitSize'];
                const statement = (0, util_1.saverStatement)(false, chunkBitSize, commGensId, encKeyId, snarkVkId, commGens, encKey, snarkVk, setupParamsTrk);
                const sIdx = statements.add(statement);
                const witnessEq = new composite_proof_1.WitnessEqualityMetaStatement();
                witnessEq.addWitnessRef(i, nameIdx);
                witnessEq.addWitnessRef(sIdx, 0);
                metaStatements.addWitnessEquality(witnessEq);
            });
        });
        circomAux.forEach(([i, predicates]) => {
            const outputs = circomOutputs === null || circomOutputs === void 0 ? void 0 : circomOutputs.get(i);
            predicates.forEach((pred, j) => {
                const param = predicateParams === null || predicateParams === void 0 ? void 0 : predicateParams.get(pred.snarkKeyId);
                Presentation.addLegoVerifyingKeyToTracker(pred.snarkKeyId, param, setupParamsTrk);
                let publicInputs = pred.publicVars.flatMap((pv) => {
                    return pv.value;
                });
                if (outputs !== undefined && outputs.length > j) {
                    publicInputs = outputs[j].concat(publicInputs);
                }
                const unqId = `circom-outputs-${i}__${j}`;
                setupParamsTrk.addForParamId(unqId, composite_proof_1.SetupParam.fieldElementVec(publicInputs));
                const statement = composite_proof_1.Statement.r1csCircomVerifierFromSetupParamRefs(setupParamsTrk.indexForParam(unqId), setupParamsTrk.indexForParam(pred.snarkKeyId));
                const sIdx = statements.add(statement);
                function addWitnessEquality(attributeName) {
                    const attr = (0, util_2.flattenObjectToKeyValuesList)(attributeName);
                    const nameIdx = flattenedSchemas[i][0].indexOf(attr[0][0]);
                    const witnessEq = new composite_proof_1.WitnessEqualityMetaStatement();
                    witnessEq.addWitnessRef(i, nameIdx);
                    witnessEq.addWitnessRef(sIdx, predicateWitnessIdx++);
                    metaStatements.addWitnessEquality(witnessEq);
                }
                let predicateWitnessIdx = 0;
                pred.privateVars.forEach((privateVars) => {
                    if (Array.isArray(privateVars.attributeName)) {
                        privateVars.attributeName.forEach((a) => {
                            addWitnessEquality(a);
                        });
                    }
                    else {
                        addWitnessEquality(privateVars.attributeName);
                    }
                });
            });
        });
        const ctx = (0, util_1.buildContextForProof)(this.version, this.spec, this.context);
        const proofSpec = new composite_proof_1.QuasiProofSpecG1(statements, metaStatements, setupParamsTrk.setupParams, ctx);
        return this.proof.verifyUsingQuasiProofSpec(proofSpec, this.nonce);
    }
    /**
     * Encode the revealed attributes of the presented credential
     * @param credIdx
     * @param presentedCred
     * @param presentedCredSchema
     * @param flattenedNames
     */
    static encodeRevealed(credIdx, presentedCred, presentedCredSchema, flattenedNames) {
        const revealedRaw = (0, util_1.deepClone)(presentedCred.revealedAttributes);
        revealedRaw[types_and_consts_1.CRYPTO_VERSION_STR] = presentedCred.version;
        revealedRaw[types_and_consts_1.SCHEMA_STR] = presentedCred.schema;
        if (presentedCredSchema.hasStatus()) {
            // To guard against a malicious holder not proving the credential status when required.
            if (presentedCred.status === undefined) {
                throw new Error(`Schema for the credential index ${credIdx} required a status but wasn't provided`);
            }
            if (presentedCred.status[types_and_consts_1.ID_STR] === undefined ||
                (presentedCred.status[types_and_consts_1.REV_CHECK_STR] !== types_and_consts_1.MEM_CHECK_STR &&
                    presentedCred.status[types_and_consts_1.REV_CHECK_STR] !== types_and_consts_1.NON_MEM_CHECK_STR)) {
                throw new Error(`Presented credential for ${credIdx} has invalid status ${presentedCred.status}`);
            }
            // Following will also ensure that holder (prover) cannot change the registry (accumulator) id or the type of check
            revealedRaw[types_and_consts_1.STATUS_STR] = {
                [types_and_consts_1.ID_STR]: presentedCred.status[types_and_consts_1.ID_STR],
                [types_and_consts_1.REV_CHECK_STR]: presentedCred.status[types_and_consts_1.REV_CHECK_STR]
            };
        }
        const encoded = new Map();
        Object.entries((0, flat_1.flatten)(revealedRaw)).forEach(([k, v]) => {
            const i = flattenedNames.indexOf(k);
            if (i === -1) {
                throw new Error(`Attribute name ${k} not found in schema`);
            }
            encoded.set(i, presentedCredSchema.encoder.encodeMessage(k, v));
        });
        return encoded;
    }
    toJSON() {
        var _a;
        const attributeCiphertexts = {};
        if (this.attributeCiphertexts !== undefined) {
            for (const [i, v] of this.attributeCiphertexts.entries()) {
                attributeCiphertexts[i] = {};
                Presentation.toBs58(v, attributeCiphertexts[i]);
            }
        }
        const creds = [];
        for (const cred of this.spec.credentials) {
            const current = (0, util_1.deepClone)(cred); // Need this deep cloning because structure of revealed attributes or key `extra` isn't fixed
            if (cred.status !== undefined) {
                // @ts-ignore
                (_a = current.status) === null || _a === void 0 ? void 0 : _a.accumulated = bs58_1.default.encode(cred.status.accumulated);
            }
            creds.push(current);
        }
        return {
            version: this.version,
            context: this.context,
            nonce: this.nonce ? bs58_1.default.encode(this.nonce) : null,
            spec: {
                credentials: creds,
                attributeEqualities: this.spec.attributeEqualities
            },
            attributeCiphertexts,
            proof: bs58_1.default.encode(this.proof.bytes)
        };
    }
    static fromJSON(j) {
        // @ts-ignore
        const { version, context, nonce, spec, attributeCiphertexts, proof } = j;
        const nnc = nonce ? bs58_1.default.decode(nonce) : undefined;
        const presSpec = new presentation_specification_1.PresentationSpecification();
        for (const cred of spec['credentials']) {
            let status;
            if (cred['status'] !== undefined) {
                status = (0, util_1.deepClone)(cred['status']);
                status['accumulated'] = bs58_1.default.decode(cred['status']['accumulated']);
            }
            presSpec.addPresentedCredential(cred['version'], cred['schema'], cred['revealedAttributes'], status, cred['bounds'], cred['verifiableEncryptions'], cred['circomPredicates']);
        }
        presSpec.attributeEqualities = spec['attributeEqualities'];
        const atc = new Map();
        if (attributeCiphertexts !== undefined) {
            Object.keys(attributeCiphertexts).forEach((k) => {
                const c = attributeCiphertexts[k];
                const rc = {};
                Presentation.fromBs58(c, rc);
                atc.set(parseInt(k), rc);
            });
        }
        return new Presentation(version, presSpec, new composite_proof_1.CompositeProofG1(bs58_1.default.decode(proof)), atc, context, nnc);
    }
    static toBs58(v, ret) {
        Object.keys(v).forEach((k) => {
            if (v[k] instanceof saver_1.SaverCiphertext) {
                // @ts-ignore
                ret[k] = bs58_1.default.encode(v[k].bytes);
            }
            else {
                ret[k] = {};
                Presentation.toBs58(v[k], ret[k]);
            }
        });
    }
    static fromBs58(v, ret) {
        Object.keys(v).forEach((k) => {
            if (typeof v[k] === 'string') {
                ret[k] = new saver_1.SaverCiphertext(bs58_1.default.decode(v[k]));
            }
            else {
                ret[k] = {};
                // @ts-ignore
                Presentation.fromBs58(v[k], ret[k]);
            }
        });
    }
    static addLegoVerifyingKeyToTracker(paramId, param, setupParamsTrk) {
        if (param instanceof legosnark_1.LegoVerifyingKey) {
            if (!setupParamsTrk.isTrackingParam(paramId)) {
                setupParamsTrk.addForParamId(paramId, composite_proof_1.SetupParam.legosnarkVerifyingKey(param));
            }
        }
        else if (param instanceof legosnark_1.LegoVerifyingKeyUncompressed) {
            if (!setupParamsTrk.isTrackingParam(paramId)) {
                setupParamsTrk.addForParamId(paramId, composite_proof_1.SetupParam.legosnarkVerifyingKeyUncompressed(param));
            }
        }
        else {
            throw new Error(`Predicate param id ${paramId} was expected to be a Legosnark verifying key but was ${param}`);
        }
    }
}
exports.Presentation = Presentation;
//# sourceMappingURL=presentation.js.map