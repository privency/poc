import { Versioned } from './versioned';
import { Encoder } from '../bbs-plus';
import { CRYPTO_VERSION_STR, FlattenedSchema, SCHEMA_STR, STATUS_STR, SUBJECT_STR } from './types-and-consts';
/**
 * Rules
 * 1. Schema must define a top level `credentialSubject` field for the subject, and it can be an array of object
 * 2. Credential status if defined must be present as `credentialStatus` field.
 * 3. Any top level keys in the schema JSON can be created
 Some example schemas

 {
  '$schema': 'http://json-schema.org/draft-07/schema#',
  type: 'object',
  properties: {
    credentialSubject: {
      type: 'object',
      properties: {
        fname: { type: 'string' },
        lname: { type: 'string' },
        email: { type: 'string' },
        SSN: { '$ref': '#/definitions/encryptableString' },
        userId: { '$ref': '#/definitions/encryptableCompString' },
        country: { type: 'string' },
        city: { type: 'string' },
        timeOfBirth: { type: 'integer', minimum: 0 },
        height: { type: 'number', minimum: 0, multipleOf: 0.1 },
        weight: { type: 'number', minimum: 0, multipleOf: 0.1 },
        BMI: { type: 'number', minimum: 0, multipleOf: 0.01 },
        score: { type: 'number', minimum: -100, multipleOf: 0.1 },
        secret: { type: 'string' }
      }
    }
  },
  definitions: {
    encryptableString: { type: 'string' },
    encryptableCompString: { type: 'string' }
  }
}

 {
  '$schema': 'http://json-schema.org/draft-07/schema#',
  type: 'object',
  properties: {
    credentialSubject: {
      type: 'object',
      properties: {
        fname: { type: 'string' },
        lname: { type: 'string' },
        sensitive: {
          type: 'object',
          properties: {
            very: {
              type: 'object',
              properties: { secret: { type: 'string' } }
            },
            email: { type: 'string' },
            phone: { type: 'string' },
            SSN: { '$ref': '#/definitions/encryptableString' }
          }
        },
        lessSensitive: {
          type: 'object',
          properties: {
            location: {
              type: 'object',
              properties: { country: { type: 'string' }, city: { type: 'string' } }
            },
            department: {
              type: 'object',
              properties: {
                name: { type: 'string' },
                location: {
                  type: 'object',
                  properties: {
                    name: { type: 'string' },
                    geo: {
                      type: 'object',
                      properties: {
                        lat: {
                          type: 'number',
                          minimum: -90,
                          multipleOf: 0.001
                        },
                        long: {
                          type: 'number',
                          minimum: -180,
                          multipleOf: 0.001
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        rank: { type: 'integer', minimum: 0 }
      }
    },
    credentialStatus: {
      type: 'object',
      properties: {
        id: { type: 'string' },
        type: { type: 'string' },
        revocationCheck: { type: 'string' },
        revocationId: { type: 'string' }
      }
    }
  },
  definitions: {
    encryptableString: { type: 'string' },
    encryptableCompString: { type: 'string' }
  }
 }

 {
  '$schema': 'http://json-schema.org/draft-07/schema#',
  type: 'object',
  properties: {
    credentialSubject: {
      type: 'array',
      items: [
        {
          type: 'object',
          properties: {
            name: { type: 'string' },
            location: {
              type: 'object',
              properties: {
                name: { type: 'string' },
                geo: {
                  type: 'object',
                  properties: {
                    lat: { type: 'number', minimum: -90, multipleOf: 0.001 },
                    long: {
                      type: 'number',
                      minimum: -180,
                      multipleOf: 0.001
                    }
                  }
                }
              }
            }
          }
        },
        {
          type: 'object',
          properties: {
            name: { type: 'string' },
            location: {
              type: 'object',
              properties: {
                name: { type: 'string' },
                geo: {
                  type: 'object',
                  properties: {
                    lat: { type: 'number', minimum: -90, multipleOf: 0.001 },
                    long: {
                      type: 'number',
                      minimum: -180,
                      multipleOf: 0.001
                    }
                  }
                }
              }
            }
          }
        },
        {
          type: 'object',
          properties: {
            name: { type: 'string' },
            location: {
              type: 'object',
              properties: {
                name: { type: 'string' },
                geo: {
                  type: 'object',
                  properties: {
                    lat: { type: 'number', minimum: -90, multipleOf: 0.001 },
                    long: {
                      type: 'number',
                      minimum: -180,
                      multipleOf: 0.001
                    }
                  }
                }
              }
            }
          }
        }
      ]
    }
  },
  definitions: {
    encryptableString: { type: 'string' },
    encryptableCompString: { type: 'string' }
  }
 }

 {
  '$schema': 'http://json-schema.org/draft-07/schema#',
  type: 'object',
  properties: {
    credentialSubject: {
      type: 'array',
      items: [
        {
          type: 'object',
          properties: {
            name: { type: 'string' },
            location: {
              type: 'object',
              properties: {
                name: { type: 'string' },
                geo: {
                  type: 'object',
                  properties: {
                    lat: { type: 'number', minimum: -90, multipleOf: 0.001 },
                    long: {
                      type: 'number',
                      minimum: -180,
                      multipleOf: 0.001
                    }
                  }
                }
              }
            }
          }
        },
        {
          type: 'object',
          properties: {
            name: { type: 'string' },
            location: {
              type: 'object',
              properties: {
                name: { type: 'string' },
                geo: {
                  type: 'object',
                  properties: {
                    lat: { type: 'number', minimum: -90, multipleOf: 0.001 },
                    long: {
                      type: 'number',
                      minimum: -180,
                      multipleOf: 0.001
                    }
                  }
                }
              }
            }
          }
        },
        {
          type: 'object',
          properties: {
            name: { type: 'string' },
            location: {
              type: 'object',
              properties: {
                name: { type: 'string' },
                geo: {
                  type: 'object',
                  properties: {
                    lat: { type: 'number', minimum: -90, multipleOf: 0.001 },
                    long: {
                      type: 'number',
                      minimum: -180,
                      multipleOf: 0.001
                    }
                  }
                }
              }
            }
          }
        }
      ]
    },
    issuer: {
      type: 'object',
      properties: {
        name: { type: 'string' },
        desc: { type: 'string' },
        logo: { type: 'string' }
      }
    },
    issuanceDate: { type: 'integer', minimum: 0 },
    expirationDate: { type: 'integer', minimum: 0 }
  },
  definitions: {
    encryptableString: { type: 'string' },
    encryptableCompString: { type: 'string' }
  }
}
 */
export declare const META_SCHEMA_STR = "$schema";
export interface ISchema {
    [CRYPTO_VERSION_STR]: object;
    [SCHEMA_STR]: object;
    [SUBJECT_STR]: object | object[];
    [STATUS_STR]?: object;
    [key: string]: object;
}
export declare enum ValueType {
    Str = 0,
    RevStr = 1,
    PositiveInteger = 2,
    Integer = 3,
    PositiveNumber = 4,
    Number = 5
}
export interface StringType {
    type: ValueType.Str;
}
export interface ReversibleStringType {
    type: ValueType.RevStr;
    compress: boolean;
}
export interface PositiveIntegerType {
    type: ValueType.PositiveInteger;
}
export interface IntegerType {
    type: ValueType.Integer;
    minimum: number;
}
export interface PositiveNumberType {
    type: ValueType.PositiveNumber;
    decimalPlaces: number;
}
export interface NumberType {
    type: ValueType.Number;
    minimum: number;
    decimalPlaces: number;
}
export declare type ValueTypes = StringType | ReversibleStringType | PositiveIntegerType | IntegerType | PositiveNumberType | NumberType;
export interface IJsonSchemaProperties {
    [SUBJECT_STR]: object | object[];
    [STATUS_STR]?: object;
    [key: string]: object;
}
export interface IJsonSchema {
    [META_SCHEMA_STR]: string;
    $id?: string;
    title?: string;
    type: string;
    properties: IJsonSchemaProperties;
    definitions?: {
        [key: string]: object;
    };
}
export interface ISchemaParsingOpts {
    useDefaults: boolean;
    defaultMinimumInteger: number;
    defaultDecimalPlaces: number;
}
export declare const DefaultSchemaParsingOpts: ISchemaParsingOpts;
export declare type CredVal = string | number | object | CredVal[];
export declare class CredentialSchema extends Versioned {
    static VERSION: string;
    private static readonly STR_TYPE;
    private static readonly STR_REV_TYPE;
    private static readonly POSITIVE_INT_TYPE;
    private static readonly INT_TYPE;
    private static readonly POSITIVE_NUM_TYPE;
    private static readonly NUM_TYPE;
    static RESERVED_NAMES: Set<string>;
    static IMPLICIT_FIELDS: {
        cryptoVersion: {
            type: string;
        };
        credentialSchema: {
            type: string;
        };
    };
    static JSON_SCHEMA_CUSTOM_DEFS: {
        encryptableString: {
            type: string;
        };
        encryptableCompString: {
            type: string;
        };
    };
    static JSON_SCHEMA_OVERRIDE_DEFS: {
        '#/definitions/encryptableString': {
            type: string;
            compress: boolean;
        };
        '#/definitions/encryptableCompString': {
            type: string;
            compress: boolean;
        };
    };
    static IGNORE_GENERIC_VALIDATION: Set<string>;
    static POSSIBLE_TYPES: Set<string>;
    readonly schema: ISchema;
    readonly jsonSchema: IJsonSchema;
    readonly parsingOptions: ISchemaParsingOpts;
    encoder: Encoder;
    /**
     * Takes a schema object as per JSON-schema syntax (`IJsonSchema`), validates it and converts it to an internal
     * representation (`ISchema`) and stores both as the one with JSON-schema syntax is added to the credential representation.
     * @param jsonSchema
     * @param parsingOpts
     */
    constructor(jsonSchema: IJsonSchema, parsingOpts?: Partial<ISchemaParsingOpts>);
    /**
     * Initialize the encoder as per the internal representation of schema, i.e. `ISchema`
     */
    initEncoder(): void;
    /**
     * Validates the internal representation of schema
     * @param schema
     */
    static validate(schema: ISchema): void;
    static validateGeneric(schema: object, ignoreKeys?: Set<string>): void;
    typeOfName(name: string, flattenedSchema?: FlattenedSchema): ValueTypes;
    static typeOfName(name: string, flattenedSchema: FlattenedSchema): ValueTypes;
    static typeOfValue(value: object): ValueTypes;
    static essential(withDefinitions?: boolean): IJsonSchema;
    static statusAsJsonSchema(): object;
    flatten(): FlattenedSchema;
    hasStatus(): boolean;
    toJSON(): object;
    static fromJSON(j: object): CredentialSchema;
    asEmbeddedJsonSchema(): string;
    static asEmbeddedJsonSchema(jsonSchema: IJsonSchema): string;
    static extractJsonSchemaFromEmbedded(embedded: string): IJsonSchema;
    getJsonLdContext(): object;
    static getDummyContextValue(term: string): string;
    /**
     * Convert a schema object as per JSON-schema syntax (`IJsonSchema`) to the internal representation (`ISchema`).
     * Currently, does not check if the needed JSON-schema definitions are actually present but assumes that they will be
     * already passed.
     * @param inputNode
     * @param parsingOpts
     * @param nodeKeyName - Name of the node, used for throwing more informative error message
     * @param rootObject
     */
    static convertToInternalSchemaObj(inputNode: any, parsingOpts: ISchemaParsingOpts, nodeKeyName?: string, rootObject?: object): object;
    static parseIntegerType(node: {
        minimum?: number;
    }, parsingOpts: ISchemaParsingOpts, nodeName: string): object;
    static parseNumberType(node: {
        minimum?: number;
        multipleOf: number;
    }, parsingOpts: ISchemaParsingOpts, nodeName: string): object;
    static getDecimalPlaces(d: number): number;
    static flattenSchemaObj(schema: object): FlattenedSchema;
    /**
     * Generate a schema based on the credential and with the help of a schema that defines some fields. For fields with a
     * conflicting types between credential and schema, error will be thrown. For extra keys or items in schema, they will be
     * removed in the returned schema. The missing keys or items in schema will be added in the returned schema.
     * @param cred
     * @param schema
     */
    static generateAppropriateSchema(cred: object, schema: CredentialSchema): CredentialSchema;
    private static getType;
    private static getSubschema;
    /**
     * Update given JSON-schema properties based on the given credential object.
     * @param cred
     * @param schemaProps
     * @private
     */
    private static generateFromCredential;
    private static validateStringType;
}
//# sourceMappingURL=schema.d.ts.map