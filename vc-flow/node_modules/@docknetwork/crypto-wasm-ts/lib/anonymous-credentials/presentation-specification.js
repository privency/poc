"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PresentationSpecification = void 0;
const types_and_consts_1 = require("./types-and-consts");
const bs58_1 = __importDefault(require("bs58"));
/**
 * Specifies what the presentation is proving like what credentials, what's being revealed, which attributes are being proven
 * equal, bounds being enforced, etc
 */
class PresentationSpecification {
    constructor() {
        this.credentials = [];
        this.attributeEqualities = [];
    }
    reset() {
        this.credentials = [];
        this.attributeEqualities = [];
    }
    addPresentedCredential(version, schema, revealedAttributes, status, bounds, verifiableEncryptions, circomPredicates) {
        const ps = {
            version,
            schema,
            revealedAttributes
        };
        if (status !== undefined) {
            ps['status'] = status;
        }
        if (bounds !== undefined) {
            ps['bounds'] = bounds;
        }
        if (verifiableEncryptions !== undefined) {
            ps['verifiableEncryptions'] = verifiableEncryptions;
        }
        if (circomPredicates !== undefined) {
            ps['circomPredicates'] = circomPredicates;
        }
        this.credentials.push(ps);
    }
    getStatus(credIndex) {
        if (credIndex >= this.credentials.length) {
            throw new Error(`Invalid credential index ${credIndex}`);
        }
        return this.credentials[credIndex].status;
    }
    toJSON() {
        const j = {
            credentials: [],
            attributeEqualities: this.attributeEqualities
        };
        for (const pc of this.credentials) {
            const curJ = {
                version: pc.version,
                schema: pc.schema,
                revealedAttributes: pc.revealedAttributes
            };
            if (pc.status !== undefined) {
                curJ['status'] = Object.assign({}, pc.status);
                curJ['status'].accumulated = bs58_1.default.encode(pc.status.accumulated);
            }
            if (pc.bounds !== undefined) {
                curJ['bounds'] = pc.bounds;
            }
            if (pc.verifiableEncryptions !== undefined) {
                curJ['verifiableEncryptions'] = pc.verifiableEncryptions;
            }
            if (pc.circomPredicates !== undefined) {
                curJ['circomPredicates'] = pc.circomPredicates;
            }
            // @ts-ignore
            j.credentials.push(curJ);
        }
        return JSON.stringify(j);
    }
}
exports.PresentationSpecification = PresentationSpecification;
//# sourceMappingURL=presentation-specification.js.map