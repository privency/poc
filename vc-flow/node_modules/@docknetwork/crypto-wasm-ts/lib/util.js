"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getProvingAndVerifiyingKeyBytes = exports.areArraysEqual = exports.bytearrayToHex = exports.isPositiveInteger = exports.flattenObjectToKeyValuesList = exports.randomFieldElement = exports.ensurePositiveIntegerOfSize = exports.isNumberBiggerThanNBits = exports.bytesToChallenge = exports.getUint8ArraysFromObject = exports.jsonObjToUint8Array = exports.isEmptyObject = void 0;
const crypto_wasm_1 = require("@docknetwork/crypto-wasm");
const flat_1 = require("flat");
function isEmptyObject(obj) {
    if (!obj) {
        return true;
    }
    return Object.keys(obj).length === 0;
}
exports.isEmptyObject = isEmptyObject;
function jsonObjToUint8Array(json) {
    const obj = JSON.parse(json);
    const arr = getUint8ArraysFromObject(obj, ['value']);
    return arr[0];
}
exports.jsonObjToUint8Array = jsonObjToUint8Array;
function getUint8ArraysFromObject(obj, keys) {
    const values = [];
    for (const k of keys) {
        if (obj[k] === undefined) {
            throw new Error(`Missing field "${k}"`);
        }
        if (obj[k] instanceof Uint8Array) {
            values.push(obj[k]);
            continue;
        }
        if (!(obj[k] instanceof Array)) {
            throw new Error(`value of key "${k}" should be Array`);
        }
        values.push(obj[k]);
    }
    return values;
}
exports.getUint8ArraysFromObject = getUint8ArraysFromObject;
function bytesToChallenge(bytes) {
    return (0, crypto_wasm_1.generateFieldElementFromBytes)(bytes);
}
exports.bytesToChallenge = bytesToChallenge;
function isNumberBiggerThanNBits(num, bits) {
    // Following can be done using bit shifts, but they only work for small number of shifts. Checked in Chrome and FF
    return num.toString(2).length > bits;
}
exports.isNumberBiggerThanNBits = isNumberBiggerThanNBits;
/**
 * Throws an error if the given number takes more bits than expected.
 * @param num
 * @param size - expected size in bits
 */
function ensurePositiveIntegerOfSize(num, size) {
    if (!(Number.isSafeInteger(num) && num > 0)) {
        throw new Error(`{num} should be safe positive integer`);
    }
    if (isNumberBiggerThanNBits(num, size)) {
        throw new Error(`{num} was found to be bigger than {size} bits`);
    }
}
exports.ensurePositiveIntegerOfSize = ensurePositiveIntegerOfSize;
function randomFieldElement(seed) {
    return (0, crypto_wasm_1.generateRandomFieldElement)(seed);
}
exports.randomFieldElement = randomFieldElement;
/**
 * Takes an object, nested or otherwise and flattens it to list. Returns 2 arrays, 1st array contains keys in alphabetical
 * sorted order and 2nd contains the values in the order of the keys. Both arrays have same size. Nested keys have their
 * parent key name prefixed with a dot, eg for key `lat` in `{location: {lat: 25.01, long: 30.02} }`, it becomes `location.lat`
 * @param obj
 * @param flattenOptions
 */
function flattenObjectToKeyValuesList(obj, flattenOptions = undefined) {
    const flattened = (0, flat_1.flatten)(obj, flattenOptions);
    const keys = Object.keys(flattened).sort();
    // @ts-ignore
    const values = keys.map((k) => flattened[k]);
    return [keys, values];
}
exports.flattenObjectToKeyValuesList = flattenObjectToKeyValuesList;
function isPositiveInteger(n) {
    // @ts-ignore
    return Number.isInteger(n) && n >= 0;
}
exports.isPositiveInteger = isPositiveInteger;
function bytearrayToHex(b) {
    const alphabet = '0123456789abcdef';
    let hex = '';
    b.forEach((v) => {
        hex += alphabet[v >> 4] + alphabet[v & 15];
    });
    return hex;
}
exports.bytearrayToHex = bytearrayToHex;
function areArraysEqual(arr1, arr2) {
    if (arr1.length !== arr2.length) {
        return false;
    }
    for (let i = 0; i < arr1.length; i++) {
        if (arr1[i] !== arr2[i]) {
            return false;
        }
    }
    return true;
}
exports.areArraysEqual = areArraysEqual;
function getProvingAndVerifiyingKeyBytes(provingKey, returnUncompressed) {
    let pkBytes, vkBytes;
    if (returnUncompressed) {
        pkBytes = provingKey.decompress().bytes;
        vkBytes = provingKey.getVerifyingKeyUncompressed().bytes;
    }
    else {
        pkBytes = provingKey.bytes;
        vkBytes = provingKey.getVerifyingKey().bytes;
    }
    return [pkBytes, vkBytes];
}
exports.getProvingAndVerifiyingKeyBytes = getProvingAndVerifiyingKeyBytes;
//# sourceMappingURL=util.js.map