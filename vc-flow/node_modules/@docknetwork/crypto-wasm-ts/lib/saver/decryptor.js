"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SaverDecryptor = exports.Decrypted = exports.SaverVerifyingKey = exports.SaverVerifyingKeyUncompressed = exports.SaverProvingKey = exports.SaverProvingKeyUncompressed = exports.SaverDecryptionKey = exports.SaverDecryptionKeyUncompressed = exports.SaverEncryptionKey = exports.SaverEncryptionKeyUncompressed = exports.SaverEncryptionGens = exports.SaverEncryptionGensUncompressed = exports.SaverSecretKey = void 0;
const crypto_wasm_1 = require("@docknetwork/crypto-wasm");
const util_1 = require("./util");
const bytearray_wrapper_1 = require("../bytearray-wrapper");
/**
 * Secret key for the decryptor
 */
class SaverSecretKey extends bytearray_wrapper_1.BytearrayWrapper {
}
exports.SaverSecretKey = SaverSecretKey;
/**
 * Same as `SaverEncryptionGens` but uncompressed
 */
class SaverEncryptionGensUncompressed extends bytearray_wrapper_1.BytearrayWrapper {
}
exports.SaverEncryptionGensUncompressed = SaverEncryptionGensUncompressed;
/**
 * Generators for creating secret, encryption and decryption keys and the SNARK setup.
 */
class SaverEncryptionGens extends bytearray_wrapper_1.BytearrayWrapper {
    static generate(label) {
        const gens = (0, crypto_wasm_1.saverGenerateEncryptionGenerators)(label);
        return new SaverEncryptionGens(gens);
    }
    decompress() {
        return new SaverEncryptionGensUncompressed((0, crypto_wasm_1.saverDecompressEncryptionGenerators)(this.value));
    }
}
exports.SaverEncryptionGens = SaverEncryptionGens;
/**
 * Same as `SaverEncryptionKey` but in uncompressed form.
 */
class SaverEncryptionKeyUncompressed extends bytearray_wrapper_1.BytearrayWrapper {
}
exports.SaverEncryptionKeyUncompressed = SaverEncryptionKeyUncompressed;
/**
 * Key used to encrypt the message and prove and verify the encryption
 */
class SaverEncryptionKey extends bytearray_wrapper_1.BytearrayWrapper {
    decompress() {
        return new SaverEncryptionKeyUncompressed((0, crypto_wasm_1.saverDecompressEncryptionKey)(this.value));
    }
}
exports.SaverEncryptionKey = SaverEncryptionKey;
/**
 * Same as `SaverDecryptionKey` but in uncompressed form.
 */
class SaverDecryptionKeyUncompressed extends bytearray_wrapper_1.BytearrayWrapper {
}
exports.SaverDecryptionKeyUncompressed = SaverDecryptionKeyUncompressed;
/**
 * Key used to decrypt the message and verify the decryption
 */
class SaverDecryptionKey extends bytearray_wrapper_1.BytearrayWrapper {
    decompress() {
        return new SaverDecryptionKeyUncompressed((0, crypto_wasm_1.saverDecompressDecryptionKey)(this.value));
    }
}
exports.SaverDecryptionKey = SaverDecryptionKey;
/**
 * Same as `SaverProvingKey` but in uncompressed form.
 */
class SaverProvingKeyUncompressed extends bytearray_wrapper_1.BytearrayWrapper {
}
exports.SaverProvingKeyUncompressed = SaverProvingKeyUncompressed;
/**
 * Key used to create the snark proof during encryption
 */
class SaverProvingKey extends bytearray_wrapper_1.BytearrayWrapper {
    decompress() {
        return new SaverProvingKeyUncompressed((0, crypto_wasm_1.saverDecompressSnarkPk)(this.value));
    }
    /**
     * Get compressed verifying key from this proving key
     */
    getVerifyingKey() {
        return new SaverVerifyingKey((0, crypto_wasm_1.saverGetSnarkVkFromPk)(this.value, false));
    }
    /**
     * Get the uncompressed verifying key from this proving key
     */
    getVerifyingKeyUncompressed() {
        return new SaverVerifyingKeyUncompressed((0, crypto_wasm_1.saverGetSnarkVkFromPk)(this.value, true));
    }
}
exports.SaverProvingKey = SaverProvingKey;
/**
 * Same as `SaverVerifyingKey` but in uncompressed form.
 */
class SaverVerifyingKeyUncompressed extends bytearray_wrapper_1.BytearrayWrapper {
}
exports.SaverVerifyingKeyUncompressed = SaverVerifyingKeyUncompressed;
/**
 * Key used to verify the snark proof created during encryption
 */
class SaverVerifyingKey extends bytearray_wrapper_1.BytearrayWrapper {
    decompress() {
        return new SaverVerifyingKeyUncompressed((0, crypto_wasm_1.saverDecompressSnarkVk)(this.value));
    }
}
exports.SaverVerifyingKey = SaverVerifyingKey;
/**
 * The decrypted message and the commitment to the randomness in the ciphertext.
 */
class Decrypted {
    constructor(message, nu) {
        this.message = message;
        this.nu = nu;
    }
}
exports.Decrypted = Decrypted;
// TODO: The following exposes too many details like proving key, encryption key, decryption key. Consider abstracting
// them in a small number of objects such that the caller does not have to be aware of these details.
/**
 * Actions done by the decryptor
 */
class SaverDecryptor {
    /**
     * Create the secret key, encryption and decryption keys and the setup the SNARK.
     * @param encGens
     * @param chunkBitSize - A number that is either 4 or 8 or 16. The higher numbers make for faster encryption
     * and proving but slower decryption. Since decryption is less common and usually done by less resource constrained
     * devices, 16 is the default choice and should be good for most applications
     */
    static setup(encGens, chunkBitSize) {
        const c = (0, util_1.getChunkBitSize)(chunkBitSize);
        const [snarkPk, sk, ek, dk] = (0, crypto_wasm_1.saverDecryptorSetup)(c, encGens.value, false);
        return [
            new SaverProvingKey(snarkPk),
            new SaverSecretKey(sk),
            new SaverEncryptionKey(ek),
            new SaverDecryptionKey(dk)
        ];
    }
    /**
     * Decrypt the ciphertext using uncompressed public parameters.
     * @param ciphertext
     * @param secretKey
     * @param decryptionKey
     * @param snarkVk
     * @param chunkBitSize - Must be same as the one used during setup to create the parameters.
     */
    static decryptCiphertext(ciphertext, secretKey, decryptionKey, snarkVk, chunkBitSize) {
        return new Decrypted(...(0, crypto_wasm_1.saverDecryptCiphertextUsingSnarkVk)(ciphertext.value, secretKey.value, decryptionKey.value, snarkVk.value, (0, util_1.getChunkBitSize)(chunkBitSize), true));
    }
    /**
     * Same as `decryptCiphertext` but uses compressed parameters.
     * @param ciphertext
     * @param secretKey
     * @param decryptionKey
     * @param snarkVk
     * @param chunkBitSize - Must be same as the one used during setup to create the parameters.
     */
    static decryptCiphertextUsingCompressedParams(ciphertext, secretKey, decryptionKey, snarkVk, chunkBitSize) {
        return new Decrypted(...(0, crypto_wasm_1.saverDecryptCiphertextUsingSnarkVk)(ciphertext.value, secretKey, decryptionKey.value, snarkVk.value, (0, util_1.getChunkBitSize)(chunkBitSize), false));
    }
}
exports.SaverDecryptor = SaverDecryptor;
//# sourceMappingURL=decryptor.js.map