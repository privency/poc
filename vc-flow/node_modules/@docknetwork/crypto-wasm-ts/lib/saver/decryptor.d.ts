import { ICompressed, IUncompressed } from '../ICompressed';
import { BytearrayWrapper } from '../bytearray-wrapper';
import { SaverCiphertext } from './ciphertext';
/**
 * Secret key for the decryptor
 */
export declare class SaverSecretKey extends BytearrayWrapper {
}
/**
 * Same as `SaverEncryptionGens` but uncompressed
 */
export declare class SaverEncryptionGensUncompressed extends BytearrayWrapper implements IUncompressed {
}
/**
 * Generators for creating secret, encryption and decryption keys and the SNARK setup.
 */
export declare class SaverEncryptionGens extends BytearrayWrapper implements ICompressed<SaverEncryptionGensUncompressed> {
    static generate(label?: Uint8Array): SaverEncryptionGens;
    decompress(): SaverEncryptionGensUncompressed;
}
/**
 * Same as `SaverEncryptionKey` but in uncompressed form.
 */
export declare class SaverEncryptionKeyUncompressed extends BytearrayWrapper implements IUncompressed {
}
/**
 * Key used to encrypt the message and prove and verify the encryption
 */
export declare class SaverEncryptionKey extends BytearrayWrapper implements ICompressed<SaverEncryptionKeyUncompressed> {
    decompress(): SaverEncryptionKeyUncompressed;
}
/**
 * Same as `SaverDecryptionKey` but in uncompressed form.
 */
export declare class SaverDecryptionKeyUncompressed extends BytearrayWrapper implements IUncompressed {
}
/**
 * Key used to decrypt the message and verify the decryption
 */
export declare class SaverDecryptionKey extends BytearrayWrapper implements ICompressed<SaverDecryptionKeyUncompressed> {
    decompress(): SaverDecryptionKeyUncompressed;
}
/**
 * Same as `SaverProvingKey` but in uncompressed form.
 */
export declare class SaverProvingKeyUncompressed extends BytearrayWrapper implements IUncompressed {
}
/**
 * Key used to create the snark proof during encryption
 */
export declare class SaverProvingKey extends BytearrayWrapper implements ICompressed<SaverProvingKeyUncompressed> {
    decompress(): SaverProvingKeyUncompressed;
    /**
     * Get compressed verifying key from this proving key
     */
    getVerifyingKey(): SaverVerifyingKey;
    /**
     * Get the uncompressed verifying key from this proving key
     */
    getVerifyingKeyUncompressed(): SaverVerifyingKeyUncompressed;
}
/**
 * Same as `SaverVerifyingKey` but in uncompressed form.
 */
export declare class SaverVerifyingKeyUncompressed extends BytearrayWrapper implements IUncompressed {
}
/**
 * Key used to verify the snark proof created during encryption
 */
export declare class SaverVerifyingKey extends BytearrayWrapper implements ICompressed<SaverVerifyingKeyUncompressed> {
    decompress(): SaverVerifyingKeyUncompressed;
}
/**
 * The decrypted message and the commitment to the randomness in the ciphertext.
 */
export declare class Decrypted {
    message: Uint8Array;
    nu: Uint8Array;
    constructor(message: Uint8Array, nu: Uint8Array);
}
/**
 * Actions done by the decryptor
 */
export declare class SaverDecryptor {
    /**
     * Create the secret key, encryption and decryption keys and the setup the SNARK.
     * @param encGens
     * @param chunkBitSize - A number that is either 4 or 8 or 16. The higher numbers make for faster encryption
     * and proving but slower decryption. Since decryption is less common and usually done by less resource constrained
     * devices, 16 is the default choice and should be good for most applications
     */
    static setup(encGens: SaverEncryptionGens, chunkBitSize?: number): [SaverProvingKey, SaverSecretKey, SaverEncryptionKey, SaverDecryptionKey];
    /**
     * Decrypt the ciphertext using uncompressed public parameters.
     * @param ciphertext
     * @param secretKey
     * @param decryptionKey
     * @param snarkVk
     * @param chunkBitSize - Must be same as the one used during setup to create the parameters.
     */
    static decryptCiphertext(ciphertext: SaverCiphertext, secretKey: SaverSecretKey, decryptionKey: SaverDecryptionKeyUncompressed, snarkVk: SaverVerifyingKeyUncompressed, chunkBitSize: number): Decrypted;
    /**
     * Same as `decryptCiphertext` but uses compressed parameters.
     * @param ciphertext
     * @param secretKey
     * @param decryptionKey
     * @param snarkVk
     * @param chunkBitSize - Must be same as the one used during setup to create the parameters.
     */
    static decryptCiphertextUsingCompressedParams(ciphertext: SaverCiphertext, secretKey: Uint8Array, decryptionKey: SaverDecryptionKey, snarkVk: SaverVerifyingKey, chunkBitSize: number): Decrypted;
}
//# sourceMappingURL=decryptor.d.ts.map