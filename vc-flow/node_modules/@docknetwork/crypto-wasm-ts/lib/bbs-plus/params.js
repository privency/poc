"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SignatureParamsG2 = exports.SignatureParamsG1 = exports.SignatureParams = void 0;
const crypto_wasm_1 = require("@docknetwork/crypto-wasm");
/**
 * Signature parameters.
 */
class SignatureParams {
    constructor(params, label) {
        this.value = params;
        this.label = label;
    }
    /**
     * Number of messages that these params support and can be signed. If less or more messages are to be signed, use
     * `adapt`
     */
    supportedMessageCount() {
        return this.value.h.length;
    }
    /**
     * Is message index valid as per the params
     * @param index
     */
    isValidIndex(index) {
        return index >= 0 && index < this.supportedMessageCount();
    }
    /**
     * Get params, i.e. generator from `this.value.h` for certain indices
     * @param indices
     */
    getParamsForIndices(indices) {
        const p = [];
        p.push(this.value.h_0);
        for (const i of indices) {
            if (!this.isValidIndex(i)) {
                throw new Error(`Invalid index ${i} for params with supported message count ${this.supportedMessageCount()}`);
            }
            p.push(this.value.h[i]);
        }
        return p;
    }
    toJSON() {
        return JSON.stringify({
            value: {
                g1: Array.from(this.value.g1),
                g2: Array.from(this.value.g2),
                h_0: Array.from(this.value.h_0),
                h: this.value.h.map((h) => Array.from(h))
            },
            label: this.label
        });
    }
}
exports.SignatureParams = SignatureParams;
class SignatureParamsG1 extends SignatureParams {
    static generate(numMessages, label) {
        const params = (0, crypto_wasm_1.generateSignatureParamsG1)(numMessages, label);
        return new SignatureParamsG1(params, label);
    }
    static generateAsBytes(numMessages, label) {
        return SignatureParamsG1.generate(numMessages, label).toBytes();
    }
    toBytes() {
        return (0, crypto_wasm_1.bbsSignatureParamsG1ToBytes)(this.value);
    }
    isValid() {
        return (0, crypto_wasm_1.isSignatureParamsG1Valid)(this.value);
    }
    static valueFromBytes(bytes) {
        return (0, crypto_wasm_1.bbsSignatureParamsG1FromBytes)(bytes);
    }
    /**
     * Transform current signature params to sign a different number of messages. Needs the `label` field to be present
     * @param newMsgCount
     */
    adapt(newMsgCount) {
        if (this.label === undefined) {
            throw new Error(`Label should be present`);
        }
        let newParams;
        if (newMsgCount <= this.supportedMessageCount()) {
            newParams = {
                g1: this.value.g1,
                g2: this.value.g2,
                h_0: this.value.h_0,
                h: this.value.h.slice(0, newMsgCount)
            };
        }
        else {
            newParams = (0, crypto_wasm_1.bbsAdaptSigParamsG1ForMsgCount)(this.value, this.label, newMsgCount);
        }
        return new SignatureParamsG1(newParams, this.label);
    }
    /**
     * Commit to given messages and return the pair [blinding, commitment]
     * @param messageToCommit
     * @param encodeMessages
     * @param blinding - If not provided, a random blinding is generated
     */
    commitToMessages(messageToCommit, encodeMessages, blinding) {
        const b = blinding === undefined ? (0, crypto_wasm_1.generateRandomFieldElement)() : blinding;
        const commitment = (0, crypto_wasm_1.bbsCommitMsgsInG1)(messageToCommit, b, this.value, encodeMessages);
        return [commitment, b];
    }
}
exports.SignatureParamsG1 = SignatureParamsG1;
class SignatureParamsG2 extends SignatureParams {
    static generate(numMessages, label) {
        const params = (0, crypto_wasm_1.generateSignatureParamsG2)(numMessages, label);
        return new SignatureParamsG2(params, label);
    }
    static generateAsBytes(numMessages, label) {
        return SignatureParamsG2.generate(numMessages, label).toBytes();
    }
    isValid() {
        return (0, crypto_wasm_1.isSignatureParamsG2Valid)(this.value);
    }
    toBytes() {
        return (0, crypto_wasm_1.bbsSignatureParamsG2ToBytes)(this.value);
    }
    static valueFromBytes(bytes) {
        return (0, crypto_wasm_1.bbsSignatureParamsG2FromBytes)(bytes);
    }
    /**
     * Transform current signature params to sign a different number of messages. Needs the `label` field to be present
     * @param newMsgCount
     */
    adapt(newMsgCount) {
        if (this.label === undefined) {
            throw new Error(`Label should be present`);
        }
        const newParams = (0, crypto_wasm_1.bbsAdaptSigParamsG2ForMsgCount)(this.value, this.label, newMsgCount);
        return new SignatureParamsG2(newParams, this.label);
    }
}
exports.SignatureParamsG2 = SignatureParamsG2;
//# sourceMappingURL=params.js.map