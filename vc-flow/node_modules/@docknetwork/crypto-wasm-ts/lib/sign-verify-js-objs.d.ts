import { BBSPlusPublicKeyG2, BBSPlusSecretKey, BlindSignatureG1, BlindSignatureRequest, Encoder, SignatureG1, SignatureParamsG1, WitnessEqualityMetaStatement } from './index';
import { VerifyResult } from '@docknetwork/crypto-wasm';
export declare type MessageStructure = Record<string, null | MessageStructure>;
export declare function flattenMessageStructure(msgStructure: MessageStructure): object;
export declare function getAdaptedSignatureParamsForMessages(params: SignatureParamsG1, msgStructure: MessageStructure): SignatureParamsG1;
export declare class SigParamsGetter {
    defaultLabel?: Uint8Array;
    constructor(defaultLabel?: Uint8Array);
    getSigParamsOfRequiredSize(msgCount: number, labelOrParams?: Uint8Array | SignatureParamsG1): SignatureParamsG1;
}
/**
 * Gives `SignatureParamsG1` that can sign `msgCount` number of messages.
 * @param msgCount
 * @param labelOrParams
 */
export declare function getSigParamsOfRequiredSize(msgCount: number, labelOrParams: Uint8Array | SignatureParamsG1): SignatureParamsG1;
export declare function getSigParamsForMsgStructure(msgStructure: MessageStructure, labelOrParams: Uint8Array | SignatureParamsG1): SignatureParamsG1;
export interface SignedMessages {
    encodedMessages: {
        [key: string]: Uint8Array;
    };
    signature: SignatureG1;
}
export interface BlindSignedMessages {
    encodedMessages: {
        [key: string]: Uint8Array;
    };
    signature: BlindSignatureG1;
}
/**
 * Takes messages as a JS object, flattens it, encodes the values and creates a BBS+ signature in group G1. Returns the
 * encoded messages and the signature.
 * @param messages
 * @param secretKey
 * @param labelOrParams
 * @param encoder
 */
export declare function signMessageObject(messages: object, secretKey: BBSPlusSecretKey, labelOrParams: Uint8Array | SignatureParamsG1, encoder: Encoder): SignedMessages;
/**
 * Verifies the signature on the given messages. Takes the messages as a JS object, flattens it, encodes the values similar
 * to signing and then verifies the signature.
 * @param messages
 * @param signature
 * @param publicKey
 * @param labelOrParams
 * @param encoder
 */
export declare function verifyMessageObject(messages: object, signature: SignatureG1, publicKey: BBSPlusPublicKeyG2, labelOrParams: Uint8Array | SignatureParamsG1, encoder: Encoder): VerifyResult;
/**
 * Given the messages as a JS object and the names (use "." for nested property names) of the messages to reveal, returns
 * the encoded messages to reveal and hide as separate maps with the key being the index of the message when the object is
 * flattened.
 * @param messages
 * @param revealedMsgNames
 * @param encoder
 */
export declare function getRevealedAndUnrevealed(messages: object, revealedMsgNames: Set<string>, encoder: Encoder): [Map<number, Uint8Array>, Map<number, Uint8Array>, object];
/**
 * Used by the verifier to encode the revealed messages given by the prover.
 * @param revealedMsgsRaw - Revealed messages given by the prover.
 * @param msgStructure - Message structure, i.e. the structure of JS object with key names but values redacted.
 * @param encoder
 */
export declare function encodeRevealedMsgs(revealedMsgsRaw: object, msgStructure: MessageStructure, encoder: Encoder): Map<number, Uint8Array>;
/**
 * Generate a request for getting a blind signature from a signer, i.e. some messages are hidden from signer.
 * Returns the blinding, the request to be sent to the signer and the witness to be used in the proof
 * @param hiddenMsgNames - The names of messages being hidden from signer
 * @param messages - All the message, i.e. known + hidden.
 * @param labelOrParams
 * @param encoder
 * @param blinding - Optional, if not provided, its generated randomly
 */
export declare function genBlindSigRequestAndWitness(hiddenMsgNames: Set<string>, messages: object, labelOrParams: Uint8Array | SignatureParamsG1, encoder: Encoder, blinding?: Uint8Array): [Uint8Array, BlindSignatureRequest, Uint8Array];
/**
 * Get the statement to be used in composite proof for the blind signature request
 * @param request
 * @param sigParams
 */
export declare function getStatementForBlindSigRequest(request: BlindSignatureRequest, sigParams: SignatureParamsG1): Uint8Array;
/**
 * Used by the signer to create a blind signature
 * @param blindSigRequest - The blind sig request sent by user.
 * @param knownMessages - The messages known to the signer
 * @param secretKey
 * @param msgStructure
 * @param labelOrParams
 * @param encoder
 */
export declare function blindSignMessageObject(blindSigRequest: BlindSignatureRequest, knownMessages: object, secretKey: BBSPlusSecretKey, msgStructure: MessageStructure, labelOrParams: Uint8Array | SignatureParamsG1, encoder: Encoder): BlindSignedMessages;
/**
 * Check if the given structure is compatible with the given messages object.
 * @param messages
 * @param msgStructure
 */
export declare function isValidMsgStructure(messages: object, msgStructure: MessageStructure): boolean;
/**
 * Flattens the object `msgStructure` and returns the indices of names given in `msgNames`
 * @param msgNames
 * @param msgStructure
 * @returns Returns in same order as given names in `msgNames`
 */
export declare function getIndicesForMsgNames(msgNames: string[], msgStructure: MessageStructure): number[];
/**
 * Takes an equality of messages across statements and returns the `MetaStatement` to be used in the proof.
 * @param equality - Map with key as the statement index and value as the message names of that statement
 * that are to be proved equal and the message structure.
 */
export declare function createWitnessEqualityMetaStatement(equality: Map<number, [msgNames: string[], msgStructure: MessageStructure]>): WitnessEqualityMetaStatement;
//# sourceMappingURL=sign-verify-js-objs.d.ts.map