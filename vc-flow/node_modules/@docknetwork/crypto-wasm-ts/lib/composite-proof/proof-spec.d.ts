import { MetaStatements, Statements } from './statement';
import { SetupParam } from './setup-param';
/**
 * The specification used to construct the proof. This contains all the statements and the meta statements.
 * If you have a lot of `Statements` or `SetupParam`s or they have a large size like for SNARKs, use `QuasiProofSpecG1`
 */
export declare class ProofSpecG1 {
    value: Uint8Array;
    constructor(statements: Statements, metaStatements: MetaStatements, setupParams?: SetupParam[], context?: Uint8Array);
    /**
     * Check if the proof spec is valid.
     * @returns
     */
    isValid(): boolean;
}
/**
 * The specification used to construct the proof. This contains all the statements and the meta statements.
 * The difference between this and `ProofSpecG1` that this does not call WASM to generate a `ProofSpecG1` object that
 * corresponds to the `ProofSpec` struct in Rust. This WASM call be expensive due to the serialization overhead and thus
 * it's advised to use this when there are a lot of `Statements` or `SetupParam`s.
 */
export declare class QuasiProofSpecG1 {
    statements: Statements;
    metaStatements: MetaStatements;
    setupParams: SetupParam[];
    context?: Uint8Array;
    constructor(statements?: Statements, metaStatements?: MetaStatements, setupParams?: SetupParam[], context?: Uint8Array);
    addStatement(statement: Uint8Array): number;
    addMetaStatement(metaStatement: Uint8Array): number;
    addSetupParam(setupParam: SetupParam): number;
    setContext(context: Uint8Array): void;
    toProofSpec(): ProofSpecG1;
}
//# sourceMappingURL=proof-spec.d.ts.map