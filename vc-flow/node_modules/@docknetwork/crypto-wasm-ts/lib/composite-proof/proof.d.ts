import { MetaStatements, Statements } from './statement';
import { VerifyResult } from '@docknetwork/crypto-wasm';
import { Witnesses } from './witness';
import { SetupParam } from './setup-param';
import { SaverCiphertext } from '../saver';
import { ProofSpecG1, QuasiProofSpecG1 } from './proof-spec';
import { BytearrayWrapper } from '../bytearray-wrapper';
/**
 * A proof of 1 or more statements and meta statements.
 */
export declare class CompositeProofG1 extends BytearrayWrapper {
    /**
     * Generate the composite proof using a `ProofSpec`
     * @param proofSpec
     * @param witnesses
     * @param nonce
     */
    static generate(proofSpec: ProofSpecG1, witnesses: Witnesses, nonce?: Uint8Array): CompositeProofG1;
    /**
     * Generate the composite proof using a `QuasiProofSpecG1`
     * @param proofSpec
     * @param witnesses
     * @param nonce
     */
    static generateUsingQuasiProofSpec(proofSpec: QuasiProofSpecG1, witnesses: Witnesses, nonce?: Uint8Array): CompositeProofG1;
    /**
     * Verify this composite proof using a `ProofSpec`
     * @param proofSpec
     * @param nonce
     */
    verify(proofSpec: ProofSpecG1, nonce?: Uint8Array): VerifyResult;
    /**
     * Verify this composite proof using a `QuasiProofSpecG1`
     * @param proofSpec
     * @param nonce
     */
    verifyUsingQuasiProofSpec(proofSpec: QuasiProofSpecG1, nonce?: Uint8Array): VerifyResult;
    /**
     * Get the ciphertext for the SAVER statement at index `statementIndex`. The proof involving any SAVER statement also
     * contains the ciphertext corresponding to that statement. Will throw an error if it could not find the ciphertext or
     * statement at that index
     * @param statementIndex
     */
    getSaverCiphertext(statementIndex: number): SaverCiphertext;
    getSaverCiphertexts(statementIndices: number[]): SaverCiphertext[];
    static generateWithDeconstructedProofSpec(statements: Statements, metaStatements: MetaStatements, witnesses: Witnesses, setupParams?: SetupParam[], context?: Uint8Array, nonce?: Uint8Array): CompositeProofG1;
    verifyWithDeconstructedProofSpec(statements: Statements, metaStatements: MetaStatements, setupParams?: SetupParam[], context?: Uint8Array, nonce?: Uint8Array): VerifyResult;
}
//# sourceMappingURL=proof.d.ts.map