"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetaStatements = exports.Statements = exports.MetaStatement = exports.WitnessEqualityMetaStatement = exports.Statement = void 0;
const crypto_wasm_1 = require("@docknetwork/crypto-wasm");
const saver_1 = require("../saver");
const util_1 = require("../util");
const r1cs_1 = require("../r1cs");
/**
 * Relation which needs to be proven. Contains any public data that needs to be known to both prover and verifier
 */
class Statement {
    /**
     * Create statement for proving knowledge of opening of Pedersen commitment with commitment key and commitment in G1
     * @param commitmentKey - commitment key used to create the commitment
     * @param commitment
     */
    static pedersenCommitmentG1(commitmentKey, commitment) {
        return (0, crypto_wasm_1.generatePedersenCommitmentG1Statement)(commitmentKey, commitment);
    }
    /**
     * Same as `Statement.pedersenCommitmentG1` but does not take the commitment key directly but a reference to it
     * @param commitmentKeyRef
     * @param commitment
     */
    static pedersenCommitmentG1FromSetupParamRef(commitmentKeyRef, commitment) {
        return (0, crypto_wasm_1.generatePedersenCommitmentG1StatementFromParamRefs)(commitmentKeyRef, commitment);
    }
    /**
     * Create statement for proving knowledge of BBS+ signature
     * @param sigParams
     * @param publicKey
     * @param revealedMessages
     * @param encodeMessages
     */
    static bbsSignature(sigParams, publicKey, revealedMessages, encodeMessages) {
        return (0, crypto_wasm_1.generatePoKBBSSignatureStatement)(sigParams.value, publicKey.value, revealedMessages, encodeMessages);
    }
    /**
     * Same as `Statement.bbsSignature` but does not take the parameters directly but a reference to them as indices in the
     * array of `SetupParam`
     * @param sigParamsRef
     * @param publicKeyRef
     * @param revealedMessages
     * @param encodeMessages
     */
    static bbsSignatureFromSetupParamRefs(sigParamsRef, publicKeyRef, revealedMessages, encodeMessages) {
        return (0, crypto_wasm_1.generatePoKBBSSignatureStatementFromParamRefs)(sigParamsRef, publicKeyRef, revealedMessages, encodeMessages);
    }
    /**
     * Create statement for proving knowledge of accumulator membership
     * @param params
     * @param publicKey
     * @param provingKey
     * @param accumulated
     */
    static accumulatorMembership(params, publicKey, provingKey, accumulated) {
        return (0, crypto_wasm_1.generateAccumulatorMembershipStatement)(params.value, publicKey.value, provingKey.value, accumulated);
    }
    /**
     * Same as `Statement.accumulatorMembership` but does not take the parameters directly but a reference to them as indices in the
     * array of `SetupParam`
     * @param params
     * @param publicKey
     * @param provingKey
     * @param accumulated
     */
    static accumulatorMembershipFromSetupParamRefs(params, publicKey, provingKey, accumulated) {
        return (0, crypto_wasm_1.generateAccumulatorMembershipStatementFromParamRefs)(params, publicKey, provingKey, accumulated);
    }
    /**
     * Create statement for proving knowledge of accumulator non-membership
     * @param params
     * @param publicKey
     * @param provingKey
     * @param accumulated
     */
    static accumulatorNonMembership(params, publicKey, provingKey, accumulated) {
        return (0, crypto_wasm_1.generateAccumulatorNonMembershipStatement)(params.value, publicKey.value, provingKey.value, accumulated);
    }
    /**
     * Same as `Statement.accumulatorNonMembership` but does not take the parameters directly but a reference to them as indices in the
     * array of `SetupParam`
     * @param params
     * @param publicKey
     * @param provingKey
     * @param accumulated
     */
    static accumulatorNonMembershipFromSetupParamRefs(params, publicKey, provingKey, accumulated) {
        return (0, crypto_wasm_1.generateAccumulatorNonMembershipStatementFromParamRefs)(params, publicKey, provingKey, accumulated);
    }
    /**
     * Create statement for verifiable encryption of a message using SAVER, for the prover. Accepts the parameters in uncompressed form.
     * @param encGens
     * @param commGens
     * @param encryptionKey
     * @param snarkPk
     * @param chunkBitSize - Must be same as the one used by the decryptor to create the parameters.
     */
    static saverProver(encGens, commGens, encryptionKey, snarkPk, chunkBitSize) {
        return (0, crypto_wasm_1.generateSaverProverStatement)((0, saver_1.getChunkBitSize)(chunkBitSize), encGens.value, commGens.value, encryptionKey.value, snarkPk.value, true);
    }
    /**
     * Same as `Statement.saverProver` except that it takes compressed parameters.
     * @param encGens
     * @param commGens
     * @param encryptionKey
     * @param snarkPk
     * @param chunkBitSize - Must be same as the one used by the decryptor to create the parameters.
     */
    static saverProverFromCompressedParams(encGens, commGens, encryptionKey, snarkPk, chunkBitSize) {
        return (0, crypto_wasm_1.generateSaverProverStatement)((0, saver_1.getChunkBitSize)(chunkBitSize), encGens.value, commGens.value, encryptionKey.value, snarkPk.value, false);
    }
    /**
     * Same as `Statement.saverProver` but does not take the parameters directly but a reference to them as indices in the
     * array of `SetupParam`
     * @param encGensRef
     * @param commGensRef
     * @param encryptionKeyRef
     * @param snarkPkRef
     * @param chunkBitSize - Must be same as the one used by the decryptor to create the parameters.
     */
    static saverProverFromSetupParamRefs(encGensRef, commGensRef, encryptionKeyRef, snarkPkRef, chunkBitSize) {
        return (0, crypto_wasm_1.generateSaverProverStatementFromParamRefs)((0, saver_1.getChunkBitSize)(chunkBitSize), encGensRef, commGensRef, encryptionKeyRef, snarkPkRef);
    }
    /**
     * Create statement for verifiable encryption of a message using SAVER, for the verifier. Accepts the parameters in uncompressed form.
     * @param encGens
     * @param commGens
     * @param encryptionKey
     * @param snarkVk,
     * @param chunkBitSize - Must be same as the one used by the decryptor to create the parameters
     */
    static saverVerifier(encGens, commGens, encryptionKey, snarkVk, chunkBitSize) {
        return (0, crypto_wasm_1.generateSaverVerifierStatement)((0, saver_1.getChunkBitSize)(chunkBitSize), encGens.value, commGens.value, encryptionKey.value, snarkVk.value, true);
    }
    /**
     * Same as `Statement.saverVerifier` except that it takes compressed parameters.
     * @param encGens
     * @param commGens
     * @param encryptionKey
     * @param snarkVk
     * @param chunkBitSize - Must be same as the one used by the decryptor to create the parameters.
     */
    static saverVerifierFromCompressedParams(encGens, commGens, encryptionKey, snarkVk, chunkBitSize) {
        return (0, crypto_wasm_1.generateSaverVerifierStatement)((0, saver_1.getChunkBitSize)(chunkBitSize), encGens.value, commGens.value, encryptionKey.value, snarkVk.value, false);
    }
    /**
     * Same as `Statement.saverVerifier` but does not take the parameters directly but a reference to them as indices in the
     * array of `SetupParam`
     * @param encGensRef
     * @param commGensRef
     * @param encryptionKeyRef
     * @param snarkVkRef
     * @param chunkBitSize
     */
    static saverVerifierFromSetupParamRefs(encGensRef, commGensRef, encryptionKeyRef, snarkVkRef, chunkBitSize) {
        return (0, crypto_wasm_1.generateSaverVerifierStatementFromParamRefs)((0, saver_1.getChunkBitSize)(chunkBitSize), encGensRef, commGensRef, encryptionKeyRef, snarkVkRef);
    }
    /**
     * Create statement for proving bounds of a message using LegoGroth 16, for the prover.
     * @param min - Inclusive lower bound on the message, must be a positive integer.
     * @param max - Inclusive upper bound on the message, must be a positive integer.
     * @param snarkPk - Proving key for LegoGroth16
     */
    static boundCheckProver(min, max, snarkPk) {
        return (0, crypto_wasm_1.generateBoundCheckLegoProverStatement)(min, max, snarkPk.value, true);
    }
    /**
     * Same as `Statement.boundCheckProver` except that it takes compressed parameters.
     * @param min - Inclusive lower bound on the message.
     * @param max - Inclusive upper bound on the message.
     * @param snarkPk - Proving key for LegoGroth16
     */
    static boundCheckProverFromCompressedParams(min, max, snarkPk) {
        return (0, crypto_wasm_1.generateBoundCheckLegoProverStatement)(min, max, snarkPk.value, false);
    }
    /**
     * Same as `Statement.boundCheckProver` but does not take the parameters directly but a reference to them as indices in the
     * array of `SetupParam`
     * @param min - Inclusive lower bound on the message.
     * @param max - Inclusive upper bound on the message.
     * @param snarkPkRef - Index of proving key in array of `SetupParam`
     */
    static boundCheckProverFromSetupParamRefs(min, max, snarkPkRef) {
        return (0, crypto_wasm_1.generateBoundCheckLegoProverStatementFromParamRefs)(min, max, snarkPkRef);
    }
    /**
     * Create statement for proving bounds of a message using LegoGroth 16, for the verifier.
     * @param min - Inclusive lower bound on the message, must be a positive integer.
     * @param max - Inclusive upper bound on the message, must be a positive integer.
     * @param snarkVk - Verifying key for LegoGroth16
     */
    static boundCheckVerifier(min, max, snarkVk) {
        return (0, crypto_wasm_1.generateBoundCheckLegoVerifierStatement)(min, max, snarkVk.value, true);
    }
    /**
     * Same as `Statement.boundCheckVerifier` except that it takes compressed parameters.
     * @param min - Inclusive lower bound on the message.
     * @param max - Inclusive upper bound on the message.
     * @param snarkVk - Verifying key for LegoGroth16
     */
    static boundCheckVerifierFromCompressedParams(min, max, snarkVk) {
        return (0, crypto_wasm_1.generateBoundCheckLegoVerifierStatement)(min, max, snarkVk.value, false);
    }
    /**
     * Same as `Statement.boundCheckVerifier` but does not take the parameters directly but a reference to them as indices in the
     * array of `SetupParam`
     * @param min - Inclusive lower bound on the message.
     * @param max - Inclusive upper bound on the message.
     * @param snarkVkRef - Index of verifying key in array of `SetupParam`
     */
    static boundCheckVerifierFromSetupParamRefs(min, max, snarkVkRef) {
        return (0, crypto_wasm_1.generateBoundCheckLegoVerifierStatementFromParamRefs)(min, max, snarkVkRef);
    }
    /**
     * Statement for proving knowledge of secret key behind pseudonym
     * @param pseudonym
     * @param base
     */
    static pseudonym(pseudonym, base) {
        return Statement.pedersenCommitmentG1([base], pseudonym.value);
    }
    /**
     * Statement for proving knowledge of secret key and attributes behind pseudonym
     * @param pseudonym
     * @param basesForAttributes
     * @param baseForSecretKey
     */
    static attributeBoundPseudonym(pseudonym, basesForAttributes, baseForSecretKey) {
        const b = [...basesForAttributes];
        if (baseForSecretKey !== undefined) {
            b.push(baseForSecretKey);
        }
        return Statement.pedersenCommitmentG1(b, pseudonym.value);
    }
    static r1csCircomProver(r1cs, wasmBytes, snarkPk) {
        let processedR1cs = (0, r1cs_1.getR1CS)(r1cs);
        return (0, crypto_wasm_1.generateR1CSCircomProverStatement)(processedR1cs.curveName, processedR1cs.numPublic, processedR1cs.numPrivate, processedR1cs.constraints, wasmBytes, snarkPk.value, true);
    }
    static r1csCircomProverFromCompressedParams(r1cs, wasmBytes, snarkPk) {
        let processedR1cs = (0, r1cs_1.getR1CS)(r1cs);
        return (0, crypto_wasm_1.generateR1CSCircomProverStatement)(processedR1cs.curveName, processedR1cs.numPublic, processedR1cs.numPrivate, processedR1cs.constraints, wasmBytes, snarkPk.value, false);
    }
    static r1csCircomProverFromSetupParamRefs(processedR1cs, wasmBytes, snarkPkRef) {
        return (0, crypto_wasm_1.generateR1CSCircomProverStatementFromParamRefs)(processedR1cs, wasmBytes, snarkPkRef);
    }
    static r1csCircomVerifier(publicInputs, snarkVk) {
        return (0, crypto_wasm_1.generateR1CSCircomVerifierStatement)(publicInputs, snarkVk.value, true);
    }
    static r1csCircomVerifierFromCompressedParams(publicInputs, snarkVk) {
        return (0, crypto_wasm_1.generateR1CSCircomVerifierStatement)(publicInputs, snarkVk.value, false);
    }
    static r1csCircomVerifierFromSetupParamRefs(publicInputsRef, snarkVkRef) {
        return (0, crypto_wasm_1.generateR1CSCircomVerifierStatementFromParamRefs)(publicInputsRef, snarkVkRef);
    }
}
exports.Statement = Statement;
/**
 * Meta statement used to express equality between witnesses of several statements or of the same statement.
 * Each witness is known by a pair of indices, the first index is the statement index and second is witness index in a particular
 * statement.
 */
class WitnessEqualityMetaStatement {
    constructor() {
        this.witnessRefs = new Set();
    }
    /**
     * Add a witness reference
     * @param statementIndex
     * @param witnessIndex
     */
    addWitnessRef(statementIndex, witnessIndex) {
        if (!(0, util_1.isPositiveInteger)(statementIndex)) {
            throw new Error(`Statement index should be a positive integer but was ${statementIndex}`);
        }
        if (!(0, util_1.isPositiveInteger)(witnessIndex)) {
            throw new Error(`Witness index should be a positive integer but was ${witnessIndex}`);
        }
        this.witnessRefs.add([statementIndex, witnessIndex]);
    }
}
exports.WitnessEqualityMetaStatement = WitnessEqualityMetaStatement;
class MetaStatement {
    static witnessEquality(eq) {
        return (0, crypto_wasm_1.generateWitnessEqualityMetaStatement)(eq.witnessRefs);
    }
}
exports.MetaStatement = MetaStatement;
/**
 * A collection of statements
 */
class Statements {
    constructor() {
        this.values = [];
    }
    /**
     * Add a new statement. Returns the index (id) of the added statement. This index is part of the witness reference.
     * @param statement
     */
    add(statement) {
        this.values.push(statement);
        return this.values.length - 1;
    }
}
exports.Statements = Statements;
/**
 * Expresses a relation between 1 or more statement or several witnesses of the same statement
 */
class MetaStatements {
    constructor() {
        this.values = [];
    }
    /**
     * Add a new meta statement.
     * @param metaStatement
     */
    add(metaStatement) {
        this.values.push(metaStatement);
        return this.values.length - 1;
    }
    addWitnessEquality(wq) {
        this.values.push(MetaStatement.witnessEquality(wq));
        return this.values.length - 1;
    }
}
exports.MetaStatements = MetaStatements;
//# sourceMappingURL=statement.js.map