"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CompositeProofG1 = void 0;
const crypto_wasm_1 = require("@docknetwork/crypto-wasm");
const saver_1 = require("../saver");
const bytearray_wrapper_1 = require("../bytearray-wrapper");
/**
 * A proof of 1 or more statements and meta statements.
 */
class CompositeProofG1 extends bytearray_wrapper_1.BytearrayWrapper {
    /**
     * Generate the composite proof using a `ProofSpec`
     * @param proofSpec
     * @param witnesses
     * @param nonce
     */
    static generate(proofSpec, witnesses, nonce) {
        const proof = (0, crypto_wasm_1.generateCompositeProofG1)(proofSpec.value, witnesses.values, nonce);
        return new CompositeProofG1(proof);
    }
    /**
     * Generate the composite proof using a `QuasiProofSpecG1`
     * @param proofSpec
     * @param witnesses
     * @param nonce
     */
    static generateUsingQuasiProofSpec(proofSpec, witnesses, nonce) {
        return CompositeProofG1.generateWithDeconstructedProofSpec(proofSpec.statements, proofSpec.metaStatements, witnesses, proofSpec.setupParams, proofSpec.context, nonce);
    }
    /**
     * Verify this composite proof using a `ProofSpec`
     * @param proofSpec
     * @param nonce
     */
    verify(proofSpec, nonce) {
        return (0, crypto_wasm_1.verifyCompositeProofG1)(this.value, proofSpec.value, nonce);
    }
    /**
     * Verify this composite proof using a `QuasiProofSpecG1`
     * @param proofSpec
     * @param nonce
     */
    verifyUsingQuasiProofSpec(proofSpec, nonce) {
        return this.verifyWithDeconstructedProofSpec(proofSpec.statements, proofSpec.metaStatements, proofSpec.setupParams, proofSpec.context, nonce);
    }
    /**
     * Get the ciphertext for the SAVER statement at index `statementIndex`. The proof involving any SAVER statement also
     * contains the ciphertext corresponding to that statement. Will throw an error if it could not find the ciphertext or
     * statement at that index
     * @param statementIndex
     */
    getSaverCiphertext(statementIndex) {
        return new saver_1.SaverCiphertext((0, crypto_wasm_1.saverGetCiphertextFromProof)(this.value, statementIndex));
    }
    getSaverCiphertexts(statementIndices) {
        const cts = (0, crypto_wasm_1.saverGetCiphertextsFromProof)(this.value, statementIndices);
        return cts.map((ct) => new saver_1.SaverCiphertext(ct));
    }
    static generateWithDeconstructedProofSpec(statements, metaStatements, witnesses, setupParams, context, nonce) {
        const params = (setupParams !== null && setupParams !== void 0 ? setupParams : new Array()).map((s) => s.value);
        const proof = (0, crypto_wasm_1.generateCompositeProofG1WithDeconstructedProofSpec)(statements.values, metaStatements.values, params, witnesses.values, context, nonce);
        return new CompositeProofG1(proof);
    }
    verifyWithDeconstructedProofSpec(statements, metaStatements, setupParams, context, nonce) {
        const params = (setupParams !== null && setupParams !== void 0 ? setupParams : new Array()).map((s) => s.value);
        return (0, crypto_wasm_1.verifyCompositeProofG1WithDeconstructedProofSpec)(this.value, statements.values, metaStatements.values, params, context, nonce);
    }
}
exports.CompositeProofG1 = CompositeProofG1;
//# sourceMappingURL=proof.js.map