"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Witnesses = exports.Witness = void 0;
const crypto_wasm_1 = require("@docknetwork/crypto-wasm");
/**
 * Private data known only to the prover whose knowledge is being proved in a proof.
 */
class Witness {
    /**
     * Opening of the Pedersen commitment
     * @param elements
     */
    static pedersenCommitment(elements) {
        return (0, crypto_wasm_1.generatePedersenCommitmentWitness)(elements);
    }
    /**
     * Signature and messages of BBS+ signature
     * @param signature
     * @param unrevealedMessages
     * @param encodeMessages
     */
    static bbsSignature(signature, unrevealedMessages, encodeMessages) {
        return (0, crypto_wasm_1.generatePoKBBSSignatureWitness)(signature.value, unrevealedMessages, encodeMessages);
    }
    /**
     * Accumulator member and its witness
     * @param member
     * @param accumulatorWitness
     */
    static accumulatorMembership(member, accumulatorWitness) {
        return (0, crypto_wasm_1.generateAccumulatorMembershipWitness)(member, accumulatorWitness.value);
    }
    /**
     * Accumulator non-member and its witness
     * @param nonMember
     * @param accumulatorWitness
     */
    static accumulatorNonMembership(nonMember, accumulatorWitness) {
        return (0, crypto_wasm_1.generateAccumulatorNonMembershipWitness)(nonMember, accumulatorWitness.value);
    }
    /**
     * Witness for verifiable encryption using SAVER
     * @param message - Message being encrypted
     */
    static saver(message) {
        return (0, crypto_wasm_1.generateSaverWitness)(message);
    }
    /**
     * Witness for bound check using LegoGroth16
     * @param message - Message whose bounds are being proven using LegoGroth16
     */
    static boundCheckLegoGroth16(message) {
        return (0, crypto_wasm_1.generateBoundCheckWitness)(message);
    }
    static pseudonym(secretKey) {
        return Witness.pedersenCommitment([secretKey]);
    }
    static attributeBoundPseudonym(attributes, secretKey) {
        const a = [...attributes];
        if (secretKey !== undefined) {
            a.push(secretKey);
        }
        return Witness.pedersenCommitment(a);
    }
    static r1csCircomWitness(inputs) {
        return (0, crypto_wasm_1.generateR1CSCircomWitness)(inputs.wires, inputs.privates, inputs.publics);
    }
}
exports.Witness = Witness;
/**
 * A collection of witnesses.
 */
class Witnesses {
    constructor() {
        this.values = [];
    }
    /**
     * Add a new witness. Returns the index (id) of the added witness. This index is part of the witness reference.
     * @param witness
     */
    add(witness) {
        this.values.push(witness);
        return this.values.length - 1;
    }
}
exports.Witnesses = Witnesses;
//# sourceMappingURL=witness.js.map