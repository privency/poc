"use strict";
// Utilities for signing and proving when working with messages as JS objects.
Object.defineProperty(exports, "__esModule", { value: true });
exports.createWitnessEqualityMetaStatement = exports.getIndicesForMsgNames = exports.isValidMsgStructure = exports.blindSignMessageObject = exports.getStatementForBlindSigRequest = exports.genBlindSigRequestAndWitness = exports.encodeRevealedMsgs = exports.getRevealedAndUnrevealed = exports.verifyMessageObject = exports.signMessageObject = exports.getSigParamsForMsgStructure = exports.getSigParamsOfRequiredSize = exports.SigParamsGetter = exports.getAdaptedSignatureParamsForMessages = exports.flattenMessageStructure = void 0;
const flat_1 = require("flat");
const index_1 = require("./index");
function flattenMessageStructure(msgStructure) {
    return (0, flat_1.flatten)(msgStructure);
}
exports.flattenMessageStructure = flattenMessageStructure;
function getAdaptedSignatureParamsForMessages(params, msgStructure) {
    const flattened = flattenMessageStructure(msgStructure);
    return params.adapt(Object.keys(flattened).length);
}
exports.getAdaptedSignatureParamsForMessages = getAdaptedSignatureParamsForMessages;
class SigParamsGetter {
    constructor(defaultLabel) {
        this.defaultLabel = defaultLabel;
    }
    getSigParamsOfRequiredSize(msgCount, labelOrParams) {
        if (labelOrParams === undefined && this.defaultLabel === undefined) {
            throw new Error(`No default label or argument to create signature params of size of size ${msgCount}`);
        }
        let sigParams;
        if (labelOrParams instanceof index_1.SignatureParamsG1) {
            if (labelOrParams.supportedMessageCount() !== msgCount) {
                if (labelOrParams.label === undefined) {
                    throw new Error(`Signature params mismatch, needed ${msgCount}, got ${labelOrParams.supportedMessageCount()}`);
                }
                else {
                    sigParams = labelOrParams.adapt(msgCount);
                }
            }
            else {
                sigParams = labelOrParams;
            }
        }
        else if (labelOrParams !== undefined) {
            sigParams = index_1.SignatureParamsG1.generate(msgCount, labelOrParams);
        }
        else {
            sigParams = index_1.SignatureParamsG1.generate(msgCount, this.defaultLabel);
        }
        return sigParams;
    }
}
exports.SigParamsGetter = SigParamsGetter;
/**
 * Gives `SignatureParamsG1` that can sign `msgCount` number of messages.
 * @param msgCount
 * @param labelOrParams
 */
function getSigParamsOfRequiredSize(msgCount, labelOrParams) {
    let sigParams;
    if (labelOrParams instanceof index_1.SignatureParamsG1) {
        if (labelOrParams.supportedMessageCount() !== msgCount) {
            if (labelOrParams.label === undefined) {
                throw new Error(`Signature params mismatch, needed ${msgCount}, got ${labelOrParams.supportedMessageCount()}`);
            }
            else {
                sigParams = labelOrParams.adapt(msgCount);
            }
        }
        else {
            sigParams = labelOrParams;
        }
    }
    else {
        sigParams = index_1.SignatureParamsG1.generate(msgCount, labelOrParams);
    }
    return sigParams;
}
exports.getSigParamsOfRequiredSize = getSigParamsOfRequiredSize;
function getSigParamsForMsgStructure(msgStructure, labelOrParams) {
    const msgCount = Object.keys(flattenMessageStructure(msgStructure)).length;
    return getSigParamsOfRequiredSize(msgCount, labelOrParams);
}
exports.getSigParamsForMsgStructure = getSigParamsForMsgStructure;
/**
 * Takes messages as a JS object, flattens it, encodes the values and creates a BBS+ signature in group G1. Returns the
 * encoded messages and the signature.
 * @param messages
 * @param secretKey
 * @param labelOrParams
 * @param encoder
 */
function signMessageObject(messages, secretKey, labelOrParams, encoder) {
    const [names, encodedValues] = encoder.encodeMessageObject(messages);
    const msgCount = names.length;
    const sigParams = getSigParamsOfRequiredSize(msgCount, labelOrParams);
    const signature = index_1.SignatureG1.generate(encodedValues, secretKey, sigParams, false);
    // Encoded message as an object with key as the flattened name
    const encodedMessages = {};
    for (let i = 0; i < msgCount; i++) {
        encodedMessages[names[i]] = encodedValues[i];
    }
    return {
        encodedMessages,
        signature
    };
}
exports.signMessageObject = signMessageObject;
/**
 * Verifies the signature on the given messages. Takes the messages as a JS object, flattens it, encodes the values similar
 * to signing and then verifies the signature.
 * @param messages
 * @param signature
 * @param publicKey
 * @param labelOrParams
 * @param encoder
 */
function verifyMessageObject(messages, signature, publicKey, labelOrParams, encoder) {
    const [_, encodedValues] = encoder.encodeMessageObject(messages);
    const msgCount = encodedValues.length;
    const sigParams = getSigParamsOfRequiredSize(msgCount, labelOrParams);
    return signature.verify(encodedValues, publicKey, sigParams, false);
}
exports.verifyMessageObject = verifyMessageObject;
/**
 * Given the messages as a JS object and the names (use "." for nested property names) of the messages to reveal, returns
 * the encoded messages to reveal and hide as separate maps with the key being the index of the message when the object is
 * flattened.
 * @param messages
 * @param revealedMsgNames
 * @param encoder
 */
function getRevealedAndUnrevealed(messages, revealedMsgNames, encoder) {
    const [names, encodedValues] = encoder.encodeMessageObject(messages);
    const revealedMsgs = new Map();
    const unrevealedMsgs = new Map();
    let found = 0;
    for (let i = 0; i < names.length; i++) {
        if (revealedMsgNames.has(names[i])) {
            revealedMsgs.set(i, encodedValues[i]);
            found++;
        }
        else {
            unrevealedMsgs.set(i, encodedValues[i]);
        }
    }
    if (revealedMsgNames.size !== found) {
        throw new Error(`Some of the revealed message names were not found in the given messages object, ${revealedMsgNames.size - found} extra names found`);
    }
    // This will be given to the verifier to encode independently.
    const revealedMsgsRaw = {};
    const flattened = (0, flat_1.flatten)(messages);
    // @ts-ignore
    revealedMsgNames.forEach((n) => (revealedMsgsRaw[n] = flattened[n]));
    return [revealedMsgs, unrevealedMsgs, (0, flat_1.unflatten)(revealedMsgsRaw)];
}
exports.getRevealedAndUnrevealed = getRevealedAndUnrevealed;
/**
 * Used by the verifier to encode the revealed messages given by the prover.
 * @param revealedMsgsRaw - Revealed messages given by the prover.
 * @param msgStructure - Message structure, i.e. the structure of JS object with key names but values redacted.
 * @param encoder
 */
function encodeRevealedMsgs(revealedMsgsRaw, msgStructure, encoder) {
    const revealed = new Map();
    const names = Object.keys(flattenMessageStructure(msgStructure)).sort();
    const flattenedRevealed = (0, flat_1.flatten)(revealedMsgsRaw);
    Object.entries(flattenedRevealed).forEach(([n, v]) => {
        const i = names.indexOf(n);
        if (i === -1) {
            throw new Error(`Message name ${n} was not found`);
        }
        revealed.set(i, encoder.encodeMessage(n, v));
    });
    return revealed;
}
exports.encodeRevealedMsgs = encodeRevealedMsgs;
/**
 * Generate a request for getting a blind signature from a signer, i.e. some messages are hidden from signer.
 * Returns the blinding, the request to be sent to the signer and the witness to be used in the proof
 * @param hiddenMsgNames - The names of messages being hidden from signer
 * @param messages - All the message, i.e. known + hidden.
 * @param labelOrParams
 * @param encoder
 * @param blinding - Optional, if not provided, its generated randomly
 */
function genBlindSigRequestAndWitness(hiddenMsgNames, messages, labelOrParams, encoder, blinding) {
    const [names, encodedValues] = encoder.encodeMessageObject(messages);
    const hiddenMsgs = new Map();
    let found = 0;
    hiddenMsgNames.forEach((n) => {
        const i = names.indexOf(n);
        if (i !== -1) {
            hiddenMsgs.set(i, encodedValues[i]);
            found++;
        }
    });
    if (hiddenMsgNames.size !== found) {
        throw new Error(`Some of the hidden message names were not found in the given messages object, ${hiddenMsgNames.size - found} missing names`);
    }
    const sigParams = getSigParamsOfRequiredSize(names.length, labelOrParams);
    const [blinding_, request] = index_1.BlindSignatureG1.generateRequest(hiddenMsgs, sigParams, false, blinding);
    const committeds = [blinding_];
    for (const i of request.blindedIndices) {
        committeds.push(hiddenMsgs.get(i));
    }
    const witness = index_1.Witness.pedersenCommitment(committeds);
    return [blinding_, request, witness];
}
exports.genBlindSigRequestAndWitness = genBlindSigRequestAndWitness;
/**
 * Get the statement to be used in composite proof for the blind signature request
 * @param request
 * @param sigParams
 */
function getStatementForBlindSigRequest(request, sigParams) {
    const commKey = sigParams.getParamsForIndices(request.blindedIndices);
    return index_1.Statement.pedersenCommitmentG1(commKey, request.commitment);
}
exports.getStatementForBlindSigRequest = getStatementForBlindSigRequest;
/**
 * Used by the signer to create a blind signature
 * @param blindSigRequest - The blind sig request sent by user.
 * @param knownMessages - The messages known to the signer
 * @param secretKey
 * @param msgStructure
 * @param labelOrParams
 * @param encoder
 */
function blindSignMessageObject(blindSigRequest, knownMessages, secretKey, msgStructure, labelOrParams, encoder) {
    const flattenedAllNames = Object.keys(flattenMessageStructure(msgStructure)).sort();
    const [flattenedUnblindedNames, encodedValues] = encoder.encodeMessageObject(knownMessages);
    const knownMessagesEncoded = new Map();
    const encodedMessages = {};
    flattenedAllNames.forEach((n, i) => {
        const j = flattenedUnblindedNames.indexOf(n);
        if (j > -1) {
            knownMessagesEncoded.set(i, encodedValues[j]);
            encodedMessages[n] = encodedValues[j];
        }
    });
    if (flattenedUnblindedNames.length !== knownMessagesEncoded.size) {
        throw new Error(`Message structure incompatible with knownMessages. Got ${flattenedUnblindedNames.length} to encode but encoded only ${knownMessagesEncoded.size}`);
    }
    if (flattenedAllNames.length !== knownMessagesEncoded.size + blindSigRequest.blindedIndices.length) {
        throw new Error(`Message structure likely incompatible with knownMessages and blindSigRequest. ${flattenedAllNames.length} != (${knownMessagesEncoded.size} + ${blindSigRequest.blindedIndices.length})`);
    }
    const sigParams = getSigParamsOfRequiredSize(flattenedAllNames.length, labelOrParams);
    const blindSig = index_1.BlindSignatureG1.generate(blindSigRequest.commitment, knownMessagesEncoded, secretKey, sigParams, false);
    return {
        encodedMessages: encodedMessages,
        signature: blindSig
    };
}
exports.blindSignMessageObject = blindSignMessageObject;
/**
 * Check if the given structure is compatible with the given messages object.
 * @param messages
 * @param msgStructure
 */
function isValidMsgStructure(messages, msgStructure) {
    const namesInStruct = Object.keys(flattenMessageStructure(msgStructure)).sort();
    const namesInMsgs = Object.keys((0, flat_1.flatten)(messages)).sort();
    return (namesInMsgs.length === namesInStruct.length &&
        (() => {
            for (let i = 0; i <= namesInMsgs.length; i++) {
                if (namesInStruct[i] !== namesInMsgs[i]) {
                    return false;
                }
            }
            return true;
        })());
}
exports.isValidMsgStructure = isValidMsgStructure;
/**
 * Flattens the object `msgStructure` and returns the indices of names given in `msgNames`
 * @param msgNames
 * @param msgStructure
 * @returns Returns in same order as given names in `msgNames`
 */
function getIndicesForMsgNames(msgNames, msgStructure) {
    const allNames = Object.keys(flattenMessageStructure(msgStructure)).sort();
    return msgNames.map((n) => {
        const i = allNames.indexOf(n);
        if (i === -1) {
            throw new Error(`Message name ${n} was not found`);
        }
        return i;
    });
}
exports.getIndicesForMsgNames = getIndicesForMsgNames;
/**
 * Takes an equality of messages across statements and returns the `MetaStatement` to be used in the proof.
 * @param equality - Map with key as the statement index and value as the message names of that statement
 * that are to be proved equal and the message structure.
 */
function createWitnessEqualityMetaStatement(equality) {
    const ms = new index_1.WitnessEqualityMetaStatement();
    for (const [sIdx, [names, struct]] of equality.entries()) {
        const indices = getIndicesForMsgNames(names, struct);
        indices.forEach((i) => ms.addWitnessRef(sIdx, i));
    }
    return ms;
}
exports.createWitnessEqualityMetaStatement = createWitnessEqualityMetaStatement;
//# sourceMappingURL=sign-verify-js-objs.js.map