'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

let wasm;

const heap = new Array(32).fill(undefined);

heap.push(undefined, null, true, false);

function getObject(idx) { return heap[idx]; }

let heap_next = heap.length;

function dropObject(idx) {
    if (idx < 36) return;
    heap[idx] = heap_next;
    heap_next = idx;
}

function takeObject(idx) {
    const ret = getObject(idx);
    dropObject(idx);
    return ret;
}

const cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });

cachedTextDecoder.decode();

let cachedUint8Memory0 = new Uint8Array();

function getUint8Memory0() {
    if (cachedUint8Memory0.byteLength === 0) {
        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
    }
    return cachedUint8Memory0;
}

function getStringFromWasm0(ptr, len) {
    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}

function addHeapObject(obj) {
    if (heap_next === heap.length) heap.push(heap.length + 1);
    const idx = heap_next;
    heap_next = heap[idx];

    heap[idx] = obj;
    return idx;
}

let WASM_VECTOR_LEN = 0;

const cachedTextEncoder = new TextEncoder('utf-8');

const encodeString = (typeof cachedTextEncoder.encodeInto === 'function'
    ? function (arg, view) {
    return cachedTextEncoder.encodeInto(arg, view);
}
    : function (arg, view) {
    const buf = cachedTextEncoder.encode(arg);
    view.set(buf);
    return {
        read: arg.length,
        written: buf.length
    };
});

function passStringToWasm0(arg, malloc, realloc) {

    if (realloc === undefined) {
        const buf = cachedTextEncoder.encode(arg);
        const ptr = malloc(buf.length);
        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);
        WASM_VECTOR_LEN = buf.length;
        return ptr;
    }

    let len = arg.length;
    let ptr = malloc(len);

    const mem = getUint8Memory0();

    let offset = 0;

    for (; offset < len; offset++) {
        const code = arg.charCodeAt(offset);
        if (code > 0x7F) break;
        mem[ptr + offset] = code;
    }

    if (offset !== len) {
        if (offset !== 0) {
            arg = arg.slice(offset);
        }
        ptr = realloc(ptr, len, len = offset + arg.length * 3);
        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
        const ret = encodeString(arg, view);

        offset += ret.written;
    }

    WASM_VECTOR_LEN = offset;
    return ptr;
}

function isLikeNone(x) {
    return x === undefined || x === null;
}

let cachedInt32Memory0 = new Int32Array();

function getInt32Memory0() {
    if (cachedInt32Memory0.byteLength === 0) {
        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
    }
    return cachedInt32Memory0;
}

let cachedFloat64Memory0 = new Float64Array();

function getFloat64Memory0() {
    if (cachedFloat64Memory0.byteLength === 0) {
        cachedFloat64Memory0 = new Float64Array(wasm.memory.buffer);
    }
    return cachedFloat64Memory0;
}

function debugString(val) {
    // primitive types
    const type = typeof val;
    if (type == 'number' || type == 'boolean' || val == null) {
        return  `${val}`;
    }
    if (type == 'string') {
        return `"${val}"`;
    }
    if (type == 'symbol') {
        const description = val.description;
        if (description == null) {
            return 'Symbol';
        } else {
            return `Symbol(${description})`;
        }
    }
    if (type == 'function') {
        const name = val.name;
        if (typeof name == 'string' && name.length > 0) {
            return `Function(${name})`;
        } else {
            return 'Function';
        }
    }
    // objects
    if (Array.isArray(val)) {
        const length = val.length;
        let debug = '[';
        if (length > 0) {
            debug += debugString(val[0]);
        }
        for(let i = 1; i < length; i++) {
            debug += ', ' + debugString(val[i]);
        }
        debug += ']';
        return debug;
    }
    // Test for built-in
    const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val));
    let className;
    if (builtInMatches.length > 1) {
        className = builtInMatches[1];
    } else {
        // Failed to match the standard '[object ClassName]'
        return toString.call(val);
    }
    if (className == 'Object') {
        // we're a user defined class or Object
        // JSON.stringify avoids problems with cycles, and is generally much
        // easier than looping through ownProperties of `val`.
        try {
            return 'Object(' + JSON.stringify(val) + ')';
        } catch (_) {
            return 'Object';
        }
    }
    // errors
    if (val instanceof Error) {
        return `${val.name}: ${val.message}\n${val.stack}`;
    }
    // TODO we could test for more things here, like `Set`s and `Map`s.
    return className;
}

function passArray8ToWasm0(arg, malloc) {
    const ptr = malloc(arg.length * 1);
    getUint8Memory0().set(arg, ptr / 1);
    WASM_VECTOR_LEN = arg.length;
    return ptr;
}
/**
* @param {Uint8Array | undefined} label
* @returns {Uint8Array}
*/
function saverGenerateEncryptionGenerators(label) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        var ptr0 = isLikeNone(label) ? 0 : passArray8ToWasm0(label, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.saverGenerateEncryptionGenerators(retptr, ptr0, len0);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array | undefined} label
* @returns {Uint8Array}
*/
function saverGenerateChunkedCommitmentGenerators(label) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        var ptr0 = isLikeNone(label) ? 0 : passArray8ToWasm0(label, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.saverGenerateChunkedCommitmentGenerators(retptr, ptr0, len0);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* Does setup for decryptor for the given chunk size and encryption generators. Creates snark SRS, secret key,
* encryption key and decryption key and returns them in an array of size 4.
* @param {number} chunk_bit_size
* @param {Uint8Array} enc_gens
* @param {boolean} return_uncompressed_snark_pk
* @returns {Array<any>}
*/
function saverDecryptorSetup(chunk_bit_size, enc_gens, return_uncompressed_snark_pk) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.saverDecryptorSetup(retptr, chunk_bit_size, addHeapObject(enc_gens), return_uncompressed_snark_pk);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* Takes compressed encryption generators and returns their uncompressed form
* @param {Uint8Array} enc_gens
* @returns {Uint8Array}
*/
function saverDecompressEncryptionGenerators(enc_gens) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.saverDecompressEncryptionGenerators(retptr, addHeapObject(enc_gens));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* Takes compressed chunked commitment generators and returns their uncompressed form
* @param {Uint8Array} comm_gens
* @returns {Uint8Array}
*/
function saverDecompressChunkedCommitmentGenerators(comm_gens) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.saverDecompressChunkedCommitmentGenerators(retptr, addHeapObject(comm_gens));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* Takes compressed encryption key and returns its uncompressed form
* @param {Uint8Array} enc_key
* @returns {Uint8Array}
*/
function saverDecompressEncryptionKey(enc_key) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.saverDecompressEncryptionKey(retptr, addHeapObject(enc_key));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* Takes compressed decryption key and returns its uncompressed form
* @param {Uint8Array} dec_key
* @returns {Uint8Array}
*/
function saverDecompressDecryptionKey(dec_key) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.saverDecompressDecryptionKey(retptr, addHeapObject(dec_key));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* Takes a compressed proving key for SAVER's snark and return the uncompressed proving key
* @param {Uint8Array} snark_pk
* @returns {Uint8Array}
*/
function saverDecompressSnarkPk(snark_pk) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.saverDecompressSnarkPk(retptr, addHeapObject(snark_pk));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* Return the compressed or uncompressed SNARK verification key from compressed proving key
* @param {Uint8Array} snark_pk
* @param {boolean} return_uncompressed
* @returns {Uint8Array}
*/
function saverGetSnarkVkFromPk(snark_pk, return_uncompressed) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.saverGetSnarkVkFromPk(retptr, addHeapObject(snark_pk), return_uncompressed);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* Takes a compressed verifying key for SAVER's snark and return the uncompressed verifying key
* @param {Uint8Array} snark_vk
* @returns {Uint8Array}
*/
function saverDecompressSnarkVk(snark_vk) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.saverDecompressSnarkVk(retptr, addHeapObject(snark_vk));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* Decrypt the ciphertext using snark verification key. If `uncompressed_public_params` is true, it
* expects all relevant parameters in their uncompressed form else it expects them compressed.
* Returns the message and the commitment to the randomness
* @param {Uint8Array} ciphertext
* @param {Uint8Array} secret_key
* @param {Uint8Array} decryption_key
* @param {Uint8Array} snark_vk
* @param {number} chunk_bit_size
* @param {boolean} uncompressed_public_params
* @returns {Array<any>}
*/
function saverDecryptCiphertextUsingSnarkVk(ciphertext, secret_key, decryption_key, snark_vk, chunk_bit_size, uncompressed_public_params) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.saverDecryptCiphertextUsingSnarkVk(retptr, addHeapObject(ciphertext), addHeapObject(secret_key), addHeapObject(decryption_key), addHeapObject(snark_vk), chunk_bit_size, uncompressed_public_params);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* Save as `saver_decrypt_ciphertext_using_snark_vk` but takes the snark proving key instead
* of verification key
* @param {Uint8Array} ciphertext
* @param {Uint8Array} secret_key
* @param {Uint8Array} decryption_key
* @param {Uint8Array} snark_pk
* @param {number} chunk_bit_size
* @param {boolean} uncompressed_public_params
* @returns {Array<any>}
*/
function saverDecryptCiphertextUsingSnarkPk(ciphertext, secret_key, decryption_key, snark_pk, chunk_bit_size, uncompressed_public_params) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.saverDecryptCiphertextUsingSnarkPk(retptr, addHeapObject(ciphertext), addHeapObject(secret_key), addHeapObject(decryption_key), addHeapObject(snark_pk), chunk_bit_size, uncompressed_public_params);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* Verify that the ciphertext did actually decrypt to the given decrypted message. If
* `uncompressed_public_params` is true, it expects all relevant parameters in their uncompressed
* form else it expects them compressed.
* @param {Uint8Array} ciphertext
* @param {Uint8Array} decrypted_message
* @param {Uint8Array} nu
* @param {Uint8Array} decryption_key
* @param {Uint8Array} snark_vk
* @param {Uint8Array} enc_gens
* @param {number} chunk_bit_size
* @param {boolean} uncompressed_public_params
* @returns {any}
*/
function saverVerifyDecryptionUsingSnarkVk(ciphertext, decrypted_message, nu, decryption_key, snark_vk, enc_gens, chunk_bit_size, uncompressed_public_params) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.saverVerifyDecryptionUsingSnarkVk(retptr, addHeapObject(ciphertext), addHeapObject(decrypted_message), addHeapObject(nu), addHeapObject(decryption_key), addHeapObject(snark_vk), addHeapObject(enc_gens), chunk_bit_size, uncompressed_public_params);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* Same as `saver_verify_decryption_using_snark_vk` but takes the snark proving key instead
* of verification key
* @param {Uint8Array} ciphertext
* @param {Uint8Array} decrypted_message
* @param {Uint8Array} nu
* @param {Uint8Array} decryption_key
* @param {Uint8Array} snark_pk
* @param {Uint8Array} enc_gens
* @param {number} chunk_bit_size
* @param {boolean} uncompressed_public_params
* @returns {any}
*/
function saverVerifyDecryptionUsingSnarkPk(ciphertext, decrypted_message, nu, decryption_key, snark_pk, enc_gens, chunk_bit_size, uncompressed_public_params) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.saverVerifyDecryptionUsingSnarkPk(retptr, addHeapObject(ciphertext), addHeapObject(decrypted_message), addHeapObject(nu), addHeapObject(decryption_key), addHeapObject(snark_pk), addHeapObject(enc_gens), chunk_bit_size, uncompressed_public_params);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array | undefined} seed
* @returns {Uint8Array}
*/
function generateRandomG1Element(seed) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        var ptr0 = isLikeNone(seed) ? 0 : passArray8ToWasm0(seed, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.generateRandomG1Element(retptr, ptr0, len0);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array | undefined} seed
* @returns {Uint8Array}
*/
function generateRandomG2Element(seed) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        var ptr0 = isLikeNone(seed) ? 0 : passArray8ToWasm0(seed, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.generateRandomG2Element(retptr, ptr0, len0);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array | undefined} seed
* @returns {Uint8Array}
*/
function generateRandomFieldElement(seed) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        var ptr0 = isLikeNone(seed) ? 0 : passArray8ToWasm0(seed, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.generateRandomFieldElement(retptr, ptr0, len0);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {number} number
* @returns {Uint8Array}
*/
function generateFieldElementFromNumber(number) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.generateFieldElementFromNumber(retptr, addHeapObject(number));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array} bytes
* @returns {Uint8Array}
*/
function generateChallengeFromBytes(bytes) {
    const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.generateChallengeFromBytes(ptr0, len0);
    return takeObject(ret);
}

/**
* Hashes given bytes to get the field element thus can accept arbitrary sized bytearray.
* @param {Uint8Array} bytes
* @returns {Uint8Array}
*/
function generateFieldElementFromBytes(bytes) {
    const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.generateChallengeFromBytes(ptr0, len0);
    return takeObject(ret);
}

/**
* @param {Uint8Array} element
* @param {boolean} element_is_secret
* @returns {Uint8Array}
*/
function fieldElementAsBytes(element, element_is_secret) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.fieldElementAsBytes(retptr, addHeapObject(element), element_is_secret);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* Create a Pedersen commitment in group G1
* @param {Array<any>} bases
* @param {Array<any>} messages
* @returns {Uint8Array}
*/
function pedersenCommitmentG1(bases, messages) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.pedersenCommitmentG1(retptr, addHeapObject(bases), addHeapObject(messages));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* Create a Pedersen commitment in group G2
* @param {Array<any>} bases
* @param {Array<any>} messages
* @returns {Uint8Array}
*/
function pedersenCommitmentG2(bases, messages) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.pedersenCommitmentG2(retptr, addHeapObject(bases), addHeapObject(messages));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {number} message_count
* @param {Uint8Array | undefined} label
* @returns {any}
*/
function generateSignatureParamsG1(message_count, label) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        var ptr0 = isLikeNone(label) ? 0 : passArray8ToWasm0(label, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.generateSignatureParamsG1(retptr, message_count, ptr0, len0);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {any} params
* @returns {boolean}
*/
function isSignatureParamsG1Valid(params) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.isSignatureParamsG1Valid(retptr, addHeapObject(params));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return r0 !== 0;
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {any} params
* @returns {number}
*/
function bbsSignatureParamsG1MaxSupportedMsgs(params) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.bbsSignatureParamsG1MaxSupportedMsgs(retptr, addHeapObject(params));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return r0 >>> 0;
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {number} message_count
* @param {Uint8Array | undefined} label
* @returns {any}
*/
function generateSignatureParamsG2(message_count, label) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        var ptr0 = isLikeNone(label) ? 0 : passArray8ToWasm0(label, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.generateSignatureParamsG2(retptr, message_count, ptr0, len0);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {any} params
* @returns {boolean}
*/
function isSignatureParamsG2Valid(params) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.isSignatureParamsG2Valid(retptr, addHeapObject(params));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return r0 !== 0;
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {any} params
* @returns {number}
*/
function bbsSignatureParamsG2MaxSupportedMsgs(params) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.bbsSignatureParamsG2MaxSupportedMsgs(retptr, addHeapObject(params));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return r0 >>> 0;
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {any} params
* @returns {Uint8Array}
*/
function bbsSignatureParamsG1ToBytes(params) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.bbsSignatureParamsG1ToBytes(retptr, addHeapObject(params));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array} bytes
* @returns {any}
*/
function bbsSignatureParamsG1FromBytes(bytes) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.bbsSignatureParamsG1FromBytes(retptr, addHeapObject(bytes));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {any} params
* @returns {Uint8Array}
*/
function bbsSignatureParamsG2ToBytes(params) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.bbsSignatureParamsG2ToBytes(retptr, addHeapObject(params));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array} bytes
* @returns {any}
*/
function bbsSignatureParamsG2FromBytes(bytes) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.bbsSignatureParamsG2FromBytes(retptr, addHeapObject(bytes));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array | undefined} seed
* @returns {Uint8Array}
*/
function generateBBSSigningKey(seed) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        var ptr0 = isLikeNone(seed) ? 0 : passArray8ToWasm0(seed, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.generateBBSSigningKey(retptr, ptr0, len0);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array} secret_key
* @param {any} params
* @returns {Uint8Array}
*/
function generateBBSPublicKeyG1(secret_key, params) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.generateBBSPublicKeyG1(retptr, addHeapObject(secret_key), addHeapObject(params));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array} public_key
* @returns {boolean}
*/
function isBBSPublicKeyG1Valid(public_key) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.isBBSPublicKeyG1Valid(retptr, addHeapObject(public_key));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return r0 !== 0;
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array} secret_key
* @param {any} params
* @returns {Uint8Array}
*/
function generateBBSPublicKeyG2(secret_key, params) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.generateBBSPublicKeyG2(retptr, addHeapObject(secret_key), addHeapObject(params));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array} public_key
* @returns {boolean}
*/
function isBBSPublicKeyG2Valid(public_key) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.isBBSPublicKeyG2Valid(retptr, addHeapObject(public_key));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return r0 !== 0;
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {any} params
* @param {Uint8Array | undefined} seed
* @returns {any}
*/
function generateBBSKeyPairG1(params, seed) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        var ptr0 = isLikeNone(seed) ? 0 : passArray8ToWasm0(seed, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.generateBBSKeyPairG1(retptr, addHeapObject(params), ptr0, len0);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {any} params
* @param {Uint8Array | undefined} seed
* @returns {any}
*/
function generateBBSKeyPairG2(params, seed) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        var ptr0 = isLikeNone(seed) ? 0 : passArray8ToWasm0(seed, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.generateBBSKeyPairG2(retptr, addHeapObject(params), ptr0, len0);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {any} params
* @param {Array<any>} indices_to_commit
* @returns {Array<any>}
*/
function bbsGetBasesForCommitmentG1(params, indices_to_commit) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.bbsGetBasesForCommitmentG1(retptr, addHeapObject(params), addHeapObject(indices_to_commit));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {any} params
* @param {Array<any>} indices_to_commit
* @returns {Array<any>}
*/
function bbsGetBasesForCommitmentG2(params, indices_to_commit) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.bbsGetBasesForCommitmentG2(retptr, addHeapObject(params), addHeapObject(indices_to_commit));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array} message
* @returns {Uint8Array}
*/
function bbsEncodeMessageForSigning(message) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        const ptr0 = passArray8ToWasm0(message, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.bbsEncodeMessageForSigning(retptr, ptr0, len0);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Array<any>} messages
* @param {Array<any>} indices_to_encode
* @returns {Array<any>}
*/
function bbsEncodeMessagesForSigning(messages, indices_to_encode) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.bbsEncodeMessagesForSigning(retptr, addHeapObject(messages), addHeapObject(indices_to_encode));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Map<any, any>} messages_to_commit
* @param {Uint8Array} blinding
* @param {any} params
* @param {boolean} encode_messages
* @returns {Uint8Array}
*/
function bbsCommitMsgsInG1(messages_to_commit, blinding, params, encode_messages) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.bbsCommitMsgsInG1(retptr, addHeapObject(messages_to_commit), addHeapObject(blinding), addHeapObject(params), encode_messages);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Map<any, any>} messages_to_commit
* @param {Uint8Array} blinding
* @param {any} params
* @param {boolean} encode_messages
* @returns {Uint8Array}
*/
function bbsCommitMsgsInG2(messages_to_commit, blinding, params, encode_messages) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.bbsCommitMsgsInG2(retptr, addHeapObject(messages_to_commit), addHeapObject(blinding), addHeapObject(params), encode_messages);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Array<any>} messages
* @param {Uint8Array} secret_key
* @param {any} params
* @param {boolean} encode_messages
* @returns {Uint8Array}
*/
function bbsSignG1(messages, secret_key, params, encode_messages) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.bbsSignG1(retptr, addHeapObject(messages), addHeapObject(secret_key), addHeapObject(params), encode_messages);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array} commitment
* @param {Map<any, any>} uncommitted_messages
* @param {Uint8Array} secret_key
* @param {any} params
* @param {boolean} encode_messages
* @returns {Uint8Array}
*/
function bbsBlindSignG1(commitment, uncommitted_messages, secret_key, params, encode_messages) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.bbsBlindSignG1(retptr, addHeapObject(commitment), addHeapObject(uncommitted_messages), addHeapObject(secret_key), addHeapObject(params), encode_messages);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array} blind_signature
* @param {Uint8Array} blinding
* @returns {Uint8Array}
*/
function bbsUnblindSigG1(blind_signature, blinding) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.bbsUnblindSigG1(retptr, addHeapObject(blind_signature), addHeapObject(blinding));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Array<any>} messages
* @param {Uint8Array} signature
* @param {Uint8Array} public_key
* @param {any} params
* @param {boolean} encode_messages
* @returns {any}
*/
function bbsVerifyG1(messages, signature, public_key, params, encode_messages) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.bbsVerifyG1(retptr, addHeapObject(messages), addHeapObject(signature), addHeapObject(public_key), addHeapObject(params), encode_messages);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Array<any>} messages
* @param {Uint8Array} secret_key
* @param {any} params
* @param {boolean} encode_messages
* @returns {Uint8Array}
*/
function bbsSignG2(messages, secret_key, params, encode_messages) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.bbsSignG2(retptr, addHeapObject(messages), addHeapObject(secret_key), addHeapObject(params), encode_messages);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array} commitment
* @param {Map<any, any>} uncommitted_messages
* @param {Uint8Array} secret_key
* @param {any} params
* @param {boolean} encode_messages
* @returns {Uint8Array}
*/
function bbsBlindSignG2(commitment, uncommitted_messages, secret_key, params, encode_messages) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.bbsBlindSignG2(retptr, addHeapObject(commitment), addHeapObject(uncommitted_messages), addHeapObject(secret_key), addHeapObject(params), encode_messages);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array} blind_signature
* @param {Uint8Array} blinding
* @returns {Uint8Array}
*/
function bbsUnblindSigG2(blind_signature, blinding) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.bbsUnblindSigG2(retptr, addHeapObject(blind_signature), addHeapObject(blinding));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Array<any>} messages
* @param {Uint8Array} signature
* @param {Uint8Array} public_key
* @param {any} params
* @param {boolean} encode_messages
* @returns {any}
*/
function bbsVerifyG2(messages, signature, public_key, params, encode_messages) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.bbsVerifyG2(retptr, addHeapObject(messages), addHeapObject(signature), addHeapObject(public_key), addHeapObject(params), encode_messages);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array} signature
* @param {any} params
* @param {Array<any>} messages
* @param {Map<any, any>} blindings
* @param {Set<any>} revealed_indices
* @param {boolean} encode_messages
* @returns {any}
*/
function bbsInitializeProofOfKnowledgeOfSignature(signature, params, messages, blindings, revealed_indices, encode_messages) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.bbsInitializeProofOfKnowledgeOfSignature(retptr, addHeapObject(signature), addHeapObject(params), addHeapObject(messages), addHeapObject(blindings), addHeapObject(revealed_indices), encode_messages);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {any} protocol
* @param {Uint8Array} challenge
* @returns {Uint8Array}
*/
function bbsGenProofOfKnowledgeOfSignature(protocol, challenge) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.bbsGenProofOfKnowledgeOfSignature(retptr, addHeapObject(protocol), addHeapObject(challenge));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array} proof
* @param {Map<any, any>} revealed_msgs
* @param {Uint8Array} challenge
* @param {Uint8Array} public_key
* @param {any} params
* @param {boolean} encode_messages
* @returns {any}
*/
function bbsVerifyProofOfKnowledgeOfSignature(proof, revealed_msgs, challenge, public_key, params, encode_messages) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.bbsVerifyProofOfKnowledgeOfSignature(retptr, addHeapObject(proof), addHeapObject(revealed_msgs), addHeapObject(challenge), addHeapObject(public_key), addHeapObject(params), encode_messages);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {any} protocol
* @param {Map<any, any>} revealed_msgs
* @param {any} params
* @param {boolean} encode_messages
* @returns {Uint8Array}
*/
function bbsChallengeContributionFromProtocol(protocol, revealed_msgs, params, encode_messages) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.bbsChallengeContributionFromProtocol(retptr, addHeapObject(protocol), addHeapObject(revealed_msgs), addHeapObject(params), encode_messages);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array} proof
* @param {Map<any, any>} revealed_msgs
* @param {any} params
* @param {boolean} encode_messages
* @returns {Uint8Array}
*/
function bbsChallengeContributionFromProof(proof, revealed_msgs, params, encode_messages) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.bbsChallengeContributionFromProof(retptr, addHeapObject(proof), addHeapObject(revealed_msgs), addHeapObject(params), encode_messages);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {any} params
* @param {Uint8Array} generating_label
* @param {number} new_count
* @returns {any}
*/
function bbsAdaptSigParamsG1ForMsgCount(params, generating_label, new_count) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.bbsAdaptSigParamsG1ForMsgCount(retptr, addHeapObject(params), addHeapObject(generating_label), new_count);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {any} params
* @param {Uint8Array} generating_label
* @param {number} new_count
* @returns {any}
*/
function bbsAdaptSigParamsG2ForMsgCount(params, generating_label, new_count) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.bbsAdaptSigParamsG2ForMsgCount(retptr, addHeapObject(params), addHeapObject(generating_label), new_count);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array} signature
* @param {Map<any, any>} unrevealed_msgs
* @param {boolean} encode_messages
* @returns {any}
*/
function generatePoKBBSSignatureWitness(signature, unrevealed_msgs, encode_messages) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.generatePoKBBSSignatureWitness(retptr, addHeapObject(signature), addHeapObject(unrevealed_msgs), encode_messages);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array} element
* @param {any} accum_witness
* @returns {any}
*/
function generateAccumulatorMembershipWitness(element, accum_witness) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.generateAccumulatorMembershipWitness(retptr, addHeapObject(element), addHeapObject(accum_witness));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array} element
* @param {any} accum_witness
* @returns {any}
*/
function generateAccumulatorNonMembershipWitness(element, accum_witness) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.generateAccumulatorNonMembershipWitness(retptr, addHeapObject(element), addHeapObject(accum_witness));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Array<any>} elements
* @returns {any}
*/
function generatePedersenCommitmentWitness(elements) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.generatePedersenCommitmentWitness(retptr, addHeapObject(elements));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Array<any>} statements
* @param {Array<any>} meta_statements
* @param {Array<any>} setup_params
* @param {Uint8Array | undefined} context
* @returns {Uint8Array}
*/
function generateProofSpecG1(statements, meta_statements, setup_params, context) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        var ptr0 = isLikeNone(context) ? 0 : passArray8ToWasm0(context, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.generateProofSpecG1(retptr, addHeapObject(statements), addHeapObject(meta_statements), addHeapObject(setup_params), ptr0, len0);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array} proof_spec
* @returns {boolean}
*/
function isProofSpecG1Valid(proof_spec) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.isProofSpecG1Valid(retptr, addHeapObject(proof_spec));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return r0 !== 0;
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Array<any>} statements
* @param {Array<any>} meta_statements
* @param {Array<any>} setup_params
* @param {Uint8Array | undefined} context
* @returns {Uint8Array}
*/
function generateProofSpecG2(statements, meta_statements, setup_params, context) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        var ptr0 = isLikeNone(context) ? 0 : passArray8ToWasm0(context, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.generateProofSpecG2(retptr, addHeapObject(statements), addHeapObject(meta_statements), addHeapObject(setup_params), ptr0, len0);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array} proof_spec
* @returns {boolean}
*/
function isProofSpecG2Valid(proof_spec) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.isProofSpecG2Valid(retptr, addHeapObject(proof_spec));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return r0 !== 0;
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array} proof_spec
* @param {Array<any>} witnesses
* @param {Uint8Array | undefined} nonce
* @returns {Uint8Array}
*/
function generateCompositeProofG1(proof_spec, witnesses, nonce) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        var ptr0 = isLikeNone(nonce) ? 0 : passArray8ToWasm0(nonce, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.generateCompositeProofG1(retptr, addHeapObject(proof_spec), addHeapObject(witnesses), ptr0, len0);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array} proof_spec
* @param {Array<any>} witnesses
* @param {Uint8Array | undefined} nonce
* @returns {Uint8Array}
*/
function generateCompositeProofG2(proof_spec, witnesses, nonce) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        var ptr0 = isLikeNone(nonce) ? 0 : passArray8ToWasm0(nonce, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.generateCompositeProofG2(retptr, addHeapObject(proof_spec), addHeapObject(witnesses), ptr0, len0);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* Same as `generate_composite_proof_g1` but takes the statements, meta-statements, setup params, context and nonce
* separately rather than in a `ProofSpec`. Use this to save the serialization and deserialization cost of
* creating a `ProofSpec`.
* @param {Array<any>} statements
* @param {Array<any>} meta_statements
* @param {Array<any>} setup_params
* @param {Array<any>} witnesses
* @param {Uint8Array | undefined} context
* @param {Uint8Array | undefined} nonce
* @returns {Uint8Array}
*/
function generateCompositeProofG1WithDeconstructedProofSpec(statements, meta_statements, setup_params, witnesses, context, nonce) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        var ptr0 = isLikeNone(context) ? 0 : passArray8ToWasm0(context, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        var ptr1 = isLikeNone(nonce) ? 0 : passArray8ToWasm0(nonce, wasm.__wbindgen_malloc);
        var len1 = WASM_VECTOR_LEN;
        wasm.generateCompositeProofG1WithDeconstructedProofSpec(retptr, addHeapObject(statements), addHeapObject(meta_statements), addHeapObject(setup_params), addHeapObject(witnesses), ptr0, len0, ptr1, len1);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array} proof
* @param {Uint8Array} proof_spec
* @param {Uint8Array | undefined} nonce
* @returns {any}
*/
function verifyCompositeProofG1(proof, proof_spec, nonce) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        var ptr0 = isLikeNone(nonce) ? 0 : passArray8ToWasm0(nonce, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.verifyCompositeProofG1(retptr, addHeapObject(proof), addHeapObject(proof_spec), ptr0, len0);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array} proof
* @param {Uint8Array} proof_spec
* @param {Uint8Array | undefined} nonce
* @returns {any}
*/
function verifyCompositeProofG2(proof, proof_spec, nonce) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        var ptr0 = isLikeNone(nonce) ? 0 : passArray8ToWasm0(nonce, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.verifyCompositeProofG2(retptr, addHeapObject(proof), addHeapObject(proof_spec), ptr0, len0);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* Same as `verify_composite_proof_g1` but takes the statements, meta-statements, setup params, context and nonce
* separately rather than in a `ProofSpec`. Use this to save the serialization and deserialization cost of
* creating a `ProofSpec`.
* @param {Uint8Array} proof
* @param {Array<any>} statements
* @param {Array<any>} meta_statements
* @param {Array<any>} setup_params
* @param {Uint8Array | undefined} context
* @param {Uint8Array | undefined} nonce
* @returns {any}
*/
function verifyCompositeProofG1WithDeconstructedProofSpec(proof, statements, meta_statements, setup_params, context, nonce) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        var ptr0 = isLikeNone(context) ? 0 : passArray8ToWasm0(context, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        var ptr1 = isLikeNone(nonce) ? 0 : passArray8ToWasm0(nonce, wasm.__wbindgen_malloc);
        var len1 = WASM_VECTOR_LEN;
        wasm.verifyCompositeProofG1WithDeconstructedProofSpec(retptr, addHeapObject(proof), addHeapObject(statements), addHeapObject(meta_statements), addHeapObject(setup_params), ptr0, len0, ptr1, len1);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array} message
* @returns {any}
*/
function generateSaverWitness(message) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.generateSaverWitness(retptr, addHeapObject(message));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* From the composite proof, get the ciphertext for the statement at index `statement_index`
* @param {Uint8Array} proof
* @param {number} statement_index
* @returns {Uint8Array}
*/
function saverGetCiphertextFromProof(proof, statement_index) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.saverGetCiphertextFromProof(retptr, addHeapObject(proof), statement_index);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

let cachedUint32Memory0 = new Uint32Array();

function getUint32Memory0() {
    if (cachedUint32Memory0.byteLength === 0) {
        cachedUint32Memory0 = new Uint32Array(wasm.memory.buffer);
    }
    return cachedUint32Memory0;
}

function passArray32ToWasm0(arg, malloc) {
    const ptr = malloc(arg.length * 4);
    getUint32Memory0().set(arg, ptr / 4);
    WASM_VECTOR_LEN = arg.length;
    return ptr;
}
/**
* From the composite proof, get the ciphertext for the statement indices `statement_indices`
* @param {Uint8Array} proof
* @param {Uint32Array} statement_indices
* @returns {Array<any>}
*/
function saverGetCiphertextsFromProof(proof, statement_indices) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        const ptr0 = passArray32ToWasm0(statement_indices, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.saverGetCiphertextsFromProof(retptr, addHeapObject(proof), ptr0, len0);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array} message
* @returns {any}
*/
function generateBoundCheckWitness(message) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.generateBoundCheckWitness(retptr, addHeapObject(message));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Map<any, any>} input_wires
* @param {Array<any>} privates
* @param {Array<any>} publics
* @returns {any}
*/
function generateR1CSCircomWitness(input_wires, privates, publics) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.generateR1CSCircomWitness(retptr, addHeapObject(input_wires), addHeapObject(privates), addHeapObject(publics));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* Takes a compressed proving key for Legosnark and return the uncompressed proving key
* @param {Uint8Array} snark_pk
* @returns {Uint8Array}
*/
function legosnarkDecompressPk(snark_pk) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.legosnarkDecompressPk(retptr, addHeapObject(snark_pk));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* Return the compressed or uncompressed SNARK verification key from compressed proving key
* @param {Uint8Array} snark_pk
* @param {boolean} return_uncompressed
* @returns {Uint8Array}
*/
function legosnarkVkFromPk(snark_pk, return_uncompressed) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.legosnarkVkFromPk(retptr, addHeapObject(snark_pk), return_uncompressed);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* Takes a compressed verifying key for Legosnark and return the uncompressed verifying key
* @param {Uint8Array} snark_vk
* @returns {Uint8Array}
*/
function legosnarkDecompressVk(snark_vk) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.legosnarkDecompressVk(retptr, addHeapObject(snark_vk));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* Generate accumulator parameters. They are needed to generate public key and initialize the accumulator.
* Pass the `label` argument to generate parameters deterministically.
* @param {Uint8Array | undefined} label
* @returns {Uint8Array}
*/
function generateAccumulatorParams(label) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        var ptr0 = isLikeNone(label) ? 0 : passArray8ToWasm0(label, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.generateAccumulatorParams(retptr, ptr0, len0);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* Check if parameters are valid. Before verifying witness or using for proof verification,
* make sure the params are valid.
* @param {Uint8Array} params
* @returns {boolean}
*/
function isAccumulatorParamsValid(params) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.isAccumulatorParamsValid(retptr, addHeapObject(params));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return r0 !== 0;
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* Generate secret key for the accumulator manager who updates the accumulator and creates witnesses.
* Pass the `seed` argument to generate key deterministically.
* @param {Uint8Array | undefined} seed
* @returns {any}
*/
function generateAccumulatorSecretKey(seed) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        var ptr0 = isLikeNone(seed) ? 0 : passArray8ToWasm0(seed, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.generateAccumulatorSecretKey(retptr, ptr0, len0);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* Generate public key from given params and secret key.
* @param {any} secret_key
* @param {Uint8Array} params
* @returns {Uint8Array}
*/
function generateAccumulatorPublicKey(secret_key, params) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.generateAccumulatorPublicKey(retptr, addHeapObject(secret_key), addHeapObject(params));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* Check if public key is valid. Before verifying witness or using for proof verification,
* make sure the public key is valid.
* @param {Uint8Array} public_key
* @returns {boolean}
*/
function isAccumulatorPublicKeyValid(public_key) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.isAccumulatorPublicKeyValid(retptr, addHeapObject(public_key));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return r0 !== 0;
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* Generate private and public key from given params and optional `seed`.
* Pass the `seed` argument to generate keys deterministically.
* @param {Uint8Array} params
* @param {Uint8Array | undefined} seed
* @returns {any}
*/
function generateAccumulatorKeyPair(params, seed) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        var ptr0 = isLikeNone(seed) ? 0 : passArray8ToWasm0(seed, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.generateAccumulatorKeyPair(retptr, addHeapObject(params), ptr0, len0);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* To add arbitrary bytes as an accumulator member, they should be first converted to
* a field element. This function will prefix the given bytes with a constant string as
* domain separator and then generate a field element using IETF standard.
* @param {Uint8Array} bytes
* @returns {any}
*/
function accumulatorGetElementFromBytes(bytes) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.accumulatorGetElementFromBytes(retptr, ptr0, len0);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* Initialize a positive accumulator
* @param {Uint8Array} params
* @returns {any}
*/
function positiveAccumulatorInitialize(params) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.positiveAccumulatorInitialize(retptr, addHeapObject(params));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* Get the accumulated value from given positive accumulator
* @param {any} accum
* @returns {Uint8Array}
*/
function positiveAccumulatorGetAccumulated(accum) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.positiveAccumulatorGetAccumulated(retptr, addHeapObject(accum));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {any} existing_accum
* @param {Uint8Array} element
* @param {any} secret_key
* @returns {any}
*/
function positiveAccumulatorAdd(existing_accum, element, secret_key) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.positiveAccumulatorAdd(retptr, addHeapObject(existing_accum), addHeapObject(element), addHeapObject(secret_key));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {any} existing_accum
* @param {Uint8Array} element
* @param {any} secret_key
* @returns {any}
*/
function positiveAccumulatorRemove(existing_accum, element, secret_key) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.positiveAccumulatorRemove(retptr, addHeapObject(existing_accum), addHeapObject(element), addHeapObject(secret_key));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {any} accum
* @param {Uint8Array} element
* @param {any} secret_key
* @returns {any}
*/
function positiveAccumulatorMembershipWitness(accum, element, secret_key) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.positiveAccumulatorMembershipWitness(retptr, addHeapObject(accum), addHeapObject(element), addHeapObject(secret_key));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array} accumulated
* @param {Uint8Array} element
* @param {any} witness
* @param {Uint8Array} public_key
* @param {Uint8Array} params
* @returns {boolean}
*/
function positiveAccumulatorVerifyMembership(accumulated, element, witness, public_key, params) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.positiveAccumulatorVerifyMembership(retptr, addHeapObject(accumulated), addHeapObject(element), addHeapObject(witness), addHeapObject(public_key), addHeapObject(params));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return r0 !== 0;
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* Creates the initial elements that depend on the order of the curve and thus can be considered fixed.
* This function generates them for the BLS12-381 curve *only*.
* @returns {Array<any>}
*/
function universalAccumulatorFixedInitialElements() {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.universalAccumulatorFixedInitialElements(retptr);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Array<any>} initial_elements
* @param {any} secret_key
* @returns {Uint8Array}
*/
function universalAccumulatorComputeInitialFv(initial_elements, secret_key) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.universalAccumulatorComputeInitialFv(retptr, addHeapObject(initial_elements), addHeapObject(secret_key));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Array<any>} initial_f_vs
* @returns {Uint8Array}
*/
function universalAccumulatorCombineMultipleInitialFv(initial_f_vs) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.universalAccumulatorCombineMultipleInitialFv(retptr, addHeapObject(initial_f_vs));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array} f_v
* @param {Uint8Array} params
* @param {number} max_size
* @returns {any}
*/
function universalAccumulatorInitialiseGivenFv(f_v, params, max_size) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.universalAccumulatorInitialiseGivenFv(retptr, addHeapObject(f_v), addHeapObject(params), max_size);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {any} accum
* @returns {Uint8Array}
*/
function universalAccumulatorGetAccumulated(accum) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.universalAccumulatorGetAccumulated(retptr, addHeapObject(accum));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {any} existing_accum
* @param {Uint8Array} element
* @param {any} secret_key
* @returns {any}
*/
function universalAccumulatorAdd(existing_accum, element, secret_key) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.universalAccumulatorAdd(retptr, addHeapObject(existing_accum), addHeapObject(element), addHeapObject(secret_key));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {any} existing_accum
* @param {Uint8Array} element
* @param {any} secret_key
* @returns {any}
*/
function universalAccumulatorRemove(existing_accum, element, secret_key) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.universalAccumulatorRemove(retptr, addHeapObject(existing_accum), addHeapObject(element), addHeapObject(secret_key));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {any} accum
* @param {Uint8Array} element
* @param {any} secret_key
* @returns {any}
*/
function universalAccumulatorMembershipWitness(accum, element, secret_key) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.universalAccumulatorMembershipWitness(retptr, addHeapObject(accum), addHeapObject(element), addHeapObject(secret_key));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array} accumulated
* @param {Uint8Array} member
* @param {any} witness
* @param {Uint8Array} public_key
* @param {Uint8Array} params
* @returns {boolean}
*/
function universalAccumulatorVerifyMembership(accumulated, member, witness, public_key, params) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.universalAccumulatorVerifyMembership(retptr, addHeapObject(accumulated), addHeapObject(member), addHeapObject(witness), addHeapObject(public_key), addHeapObject(params));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return r0 !== 0;
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array} non_member
* @param {Array<any>} members
* @returns {Uint8Array}
*/
function universalAccumulatorComputeD(non_member, members) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.universalAccumulatorComputeD(retptr, addHeapObject(non_member), addHeapObject(members));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Array<any>} ds
* @returns {Uint8Array}
*/
function universalAccumulatorCombineMultipleD(ds) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.universalAccumulatorCombineMultipleD(retptr, addHeapObject(ds));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {any} accum
* @param {Uint8Array} d
* @param {Uint8Array} non_member
* @param {any} secret_key
* @param {Uint8Array} params
* @returns {any}
*/
function universalAccumulatorNonMembershipWitness(accum, d, non_member, secret_key, params) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.universalAccumulatorNonMembershipWitness(retptr, addHeapObject(accum), addHeapObject(d), addHeapObject(non_member), addHeapObject(secret_key), addHeapObject(params));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array} accumulated
* @param {Uint8Array} non_member
* @param {any} witness
* @param {Uint8Array} public_key
* @param {Uint8Array} params
* @returns {boolean}
*/
function universalAccumulatorVerifyNonMembership(accumulated, non_member, witness, public_key, params) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.universalAccumulatorVerifyNonMembership(retptr, addHeapObject(accumulated), addHeapObject(non_member), addHeapObject(witness), addHeapObject(public_key), addHeapObject(params));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return r0 !== 0;
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {any} existing_accum
* @param {Array<any>} elements
* @param {any} secret_key
* @returns {any}
*/
function positiveAccumulatorAddBatch(existing_accum, elements, secret_key) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.positiveAccumulatorAddBatch(retptr, addHeapObject(existing_accum), addHeapObject(elements), addHeapObject(secret_key));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {any} existing_accum
* @param {Array<any>} elements
* @param {any} secret_key
* @returns {any}
*/
function positiveAccumulatorRemoveBatch(existing_accum, elements, secret_key) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.positiveAccumulatorRemoveBatch(retptr, addHeapObject(existing_accum), addHeapObject(elements), addHeapObject(secret_key));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {any} existing_accum
* @param {Array<any>} additions
* @param {Array<any>} removals
* @param {any} secret_key
* @returns {any}
*/
function positiveAccumulatorBatchUpdates(existing_accum, additions, removals, secret_key) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.positiveAccumulatorBatchUpdates(retptr, addHeapObject(existing_accum), addHeapObject(additions), addHeapObject(removals), addHeapObject(secret_key));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {any} accum
* @param {Array<any>} elements
* @param {any} secret_key
* @returns {Array<any>}
*/
function positiveAccumulatorMembershipWitnessesForBatch(accum, elements, secret_key) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.positiveAccumulatorMembershipWitnessesForBatch(retptr, addHeapObject(accum), addHeapObject(elements), addHeapObject(secret_key));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {any} existing_accum
* @param {Array<any>} elements
* @param {any} secret_key
* @returns {any}
*/
function universalAccumulatorAddBatch(existing_accum, elements, secret_key) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.universalAccumulatorAddBatch(retptr, addHeapObject(existing_accum), addHeapObject(elements), addHeapObject(secret_key));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {any} existing_accum
* @param {Array<any>} elements
* @param {any} secret_key
* @returns {any}
*/
function universalAccumulatorRemoveBatch(existing_accum, elements, secret_key) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.universalAccumulatorRemoveBatch(retptr, addHeapObject(existing_accum), addHeapObject(elements), addHeapObject(secret_key));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {any} existing_accum
* @param {Array<any>} additions
* @param {Array<any>} removals
* @param {any} secret_key
* @returns {any}
*/
function universalAccumulatorBatchUpdates(existing_accum, additions, removals, secret_key) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.universalAccumulatorBatchUpdates(retptr, addHeapObject(existing_accum), addHeapObject(additions), addHeapObject(removals), addHeapObject(secret_key));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {any} accum
* @param {Array<any>} elements
* @param {any} secret_key
* @returns {Array<any>}
*/
function universalAccumulatorMembershipWitnessesForBatch(accum, elements, secret_key) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.universalAccumulatorMembershipWitnessesForBatch(retptr, addHeapObject(accum), addHeapObject(elements), addHeapObject(secret_key));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Array<any>} non_members
* @param {Array<any>} members
* @returns {Array<any>}
*/
function universalAccumulatorComputeDForBatch(non_members, members) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.universalAccumulatorComputeDForBatch(retptr, addHeapObject(non_members), addHeapObject(members));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Array<any>} ds
* @returns {Array<any>}
*/
function universalAccumulatorCombineMultipleDForBatch(ds) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.universalAccumulatorCombineMultipleDForBatch(retptr, addHeapObject(ds));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {any} accum
* @param {Array<any>} d
* @param {Array<any>} non_members
* @param {any} secret_key
* @param {Uint8Array} params
* @returns {Array<any>}
*/
function universalAccumulatorNonMembershipWitnessesForBatch(accum, d, non_members, secret_key, params) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.universalAccumulatorNonMembershipWitnessesForBatch(retptr, addHeapObject(accum), addHeapObject(d), addHeapObject(non_members), addHeapObject(secret_key), addHeapObject(params));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {any} witness
* @param {Uint8Array} member
* @param {Uint8Array} addition
* @param {Uint8Array} old_accumulated
* @returns {any}
*/
function updateMembershipWitnessPostAdd(witness, member, addition, old_accumulated) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.updateMembershipWitnessPostAdd(retptr, addHeapObject(witness), addHeapObject(member), addHeapObject(addition), addHeapObject(old_accumulated));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {any} witness
* @param {Uint8Array} member
* @param {Uint8Array} removal
* @param {Uint8Array} new_accumulated
* @returns {any}
*/
function updateMembershipWitnessPostRemove(witness, member, removal, new_accumulated) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.updateMembershipWitnessPostRemove(retptr, addHeapObject(witness), addHeapObject(member), addHeapObject(removal), addHeapObject(new_accumulated));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {any} witness
* @param {Uint8Array} non_member
* @param {Uint8Array} addition
* @param {Uint8Array} old_accumulated
* @returns {any}
*/
function updateNonMembershipWitnessPostAdd(witness, non_member, addition, old_accumulated) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.updateNonMembershipWitnessPostAdd(retptr, addHeapObject(witness), addHeapObject(non_member), addHeapObject(addition), addHeapObject(old_accumulated));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {any} witness
* @param {Uint8Array} non_member
* @param {Uint8Array} removal
* @param {Uint8Array} new_accumulated
* @returns {any}
*/
function updateNonMembershipWitnessPostRemove(witness, non_member, removal, new_accumulated) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.updateNonMembershipWitnessPostRemove(retptr, addHeapObject(witness), addHeapObject(non_member), addHeapObject(removal), addHeapObject(new_accumulated));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Array<any>} witnesses
* @param {Array<any>} members
* @param {Array<any>} additions
* @param {Array<any>} removals
* @param {Uint8Array} old_accumulated
* @param {any} secret_key
* @returns {Array<any>}
*/
function updateMembershipWitnessesPostBatchUpdates(witnesses, members, additions, removals, old_accumulated, secret_key) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.updateMembershipWitnessesPostBatchUpdates(retptr, addHeapObject(witnesses), addHeapObject(members), addHeapObject(additions), addHeapObject(removals), addHeapObject(old_accumulated), addHeapObject(secret_key));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Array<any>} witnesses
* @param {Array<any>} non_members
* @param {Array<any>} additions
* @param {Array<any>} removals
* @param {Uint8Array} old_accumulated
* @param {any} secret_key
* @returns {Array<any>}
*/
function updateNonMembershipWitnessesPostBatchUpdates(witnesses, non_members, additions, removals, old_accumulated, secret_key) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.updateNonMembershipWitnessesPostBatchUpdates(retptr, addHeapObject(witnesses), addHeapObject(non_members), addHeapObject(additions), addHeapObject(removals), addHeapObject(old_accumulated), addHeapObject(secret_key));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array} old_accumulated
* @param {Array<any>} additions
* @param {Array<any>} removals
* @param {any} secret_key
* @returns {Uint8Array}
*/
function publicInfoForWitnessUpdate(old_accumulated, additions, removals, secret_key) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.publicInfoForWitnessUpdate(retptr, addHeapObject(old_accumulated), addHeapObject(additions), addHeapObject(removals), addHeapObject(secret_key));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {any} witness
* @param {Uint8Array} member
* @param {Array<any>} additions
* @param {Array<any>} removals
* @param {Uint8Array} public_info
* @returns {any}
*/
function updateMembershipWitnessUsingPublicInfoAfterBatchUpdate(witness, member, additions, removals, public_info) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.updateMembershipWitnessUsingPublicInfoAfterBatchUpdate(retptr, addHeapObject(witness), addHeapObject(member), addHeapObject(additions), addHeapObject(removals), addHeapObject(public_info));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {any} witness
* @param {Uint8Array} member
* @param {Array<any>} additions
* @param {Array<any>} removals
* @param {Array<any>} public_info
* @returns {any}
*/
function updateMembershipWitnessUsingPublicInfoAfterMultipleBatchUpdates(witness, member, additions, removals, public_info) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.updateMembershipWitnessUsingPublicInfoAfterMultipleBatchUpdates(retptr, addHeapObject(witness), addHeapObject(member), addHeapObject(additions), addHeapObject(removals), addHeapObject(public_info));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {any} witness
* @param {Uint8Array} non_member
* @param {Array<any>} additions
* @param {Array<any>} removals
* @param {Uint8Array} public_info
* @returns {any}
*/
function updateNonMembershipWitnessUsingPublicInfoAfterBatchUpdate(witness, non_member, additions, removals, public_info) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.updateNonMembershipWitnessUsingPublicInfoAfterBatchUpdate(retptr, addHeapObject(witness), addHeapObject(non_member), addHeapObject(additions), addHeapObject(removals), addHeapObject(public_info));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {any} witness
* @param {Uint8Array} non_member
* @param {Array<any>} additions
* @param {Array<any>} removals
* @param {Array<any>} public_info
* @returns {any}
*/
function updateNonMembershipWitnessUsingPublicInfoAfterMultipleBatchUpdates(witness, non_member, additions, removals, public_info) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.updateNonMembershipWitnessUsingPublicInfoAfterMultipleBatchUpdates(retptr, addHeapObject(witness), addHeapObject(non_member), addHeapObject(additions), addHeapObject(removals), addHeapObject(public_info));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array | undefined} label
* @returns {Uint8Array}
*/
function generateMembershipProvingKey(label) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        var ptr0 = isLikeNone(label) ? 0 : passArray8ToWasm0(label, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.generateMembershipProvingKey(retptr, ptr0, len0);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array | undefined} label
* @returns {Uint8Array}
*/
function generateNonMembershipProvingKey(label) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        var ptr0 = isLikeNone(label) ? 0 : passArray8ToWasm0(label, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.generateNonMembershipProvingKey(retptr, ptr0, len0);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array} proving_key
* @returns {Uint8Array}
*/
function accumulatorDeriveMembershipProvingKeyFromNonMembershipKey(proving_key) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.accumulatorDeriveMembershipProvingKeyFromNonMembershipKey(retptr, addHeapObject(proving_key));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array} member
* @param {Uint8Array} blinding
* @param {any} witness
* @param {Uint8Array} public_key
* @param {Uint8Array} params
* @param {Uint8Array} proving_key
* @returns {any}
*/
function accumulatorInitializeMembershipProof(member, blinding, witness, public_key, params, proving_key) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.accumulatorInitializeMembershipProof(retptr, addHeapObject(member), addHeapObject(blinding), addHeapObject(witness), addHeapObject(public_key), addHeapObject(params), addHeapObject(proving_key));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {any} protocol
* @param {Uint8Array} challenge
* @returns {any}
*/
function accumulatorGenMembershipProof(protocol, challenge) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.accumulatorGenMembershipProof(retptr, addHeapObject(protocol), addHeapObject(challenge));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {any} proof
* @param {Uint8Array} accumulated
* @param {Uint8Array} challenge
* @param {Uint8Array} public_key
* @param {Uint8Array} params
* @param {Uint8Array} proving_key
* @returns {any}
*/
function accumulatorVerifyMembershipProof(proof, accumulated, challenge, public_key, params, proving_key) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.accumulatorVerifyMembershipProof(retptr, addHeapObject(proof), addHeapObject(accumulated), addHeapObject(challenge), addHeapObject(public_key), addHeapObject(params), addHeapObject(proving_key));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {any} protocol
* @param {Uint8Array} accumulated
* @param {Uint8Array} public_key
* @param {Uint8Array} params
* @param {Uint8Array} proving_key
* @returns {Uint8Array}
*/
function accumulatorChallengeContributionFromMembershipProtocol(protocol, accumulated, public_key, params, proving_key) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.accumulatorChallengeContributionFromMembershipProtocol(retptr, addHeapObject(protocol), addHeapObject(accumulated), addHeapObject(public_key), addHeapObject(params), addHeapObject(proving_key));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {any} proof
* @param {Uint8Array} accumulated
* @param {Uint8Array} public_key
* @param {Uint8Array} params
* @param {Uint8Array} proving_key
* @returns {Uint8Array}
*/
function accumulatorChallengeContributionFromMembershipProof(proof, accumulated, public_key, params, proving_key) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.accumulatorChallengeContributionFromMembershipProof(retptr, addHeapObject(proof), addHeapObject(accumulated), addHeapObject(public_key), addHeapObject(params), addHeapObject(proving_key));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array} non_member
* @param {Uint8Array} blinding
* @param {any} witness
* @param {Uint8Array} public_key
* @param {Uint8Array} params
* @param {Uint8Array} proving_key
* @returns {any}
*/
function accumulatorInitializeNonMembershipProof(non_member, blinding, witness, public_key, params, proving_key) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.accumulatorInitializeNonMembershipProof(retptr, addHeapObject(non_member), addHeapObject(blinding), addHeapObject(witness), addHeapObject(public_key), addHeapObject(params), addHeapObject(proving_key));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {any} protocol
* @param {Uint8Array} challenge
* @returns {any}
*/
function accumulatorGenNonMembershipProof(protocol, challenge) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.accumulatorGenNonMembershipProof(retptr, addHeapObject(protocol), addHeapObject(challenge));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {any} proof
* @param {Uint8Array} accumulated
* @param {Uint8Array} challenge
* @param {Uint8Array} public_key
* @param {Uint8Array} params
* @param {Uint8Array} proving_key
* @returns {any}
*/
function accumulatorVerifyNonMembershipProof(proof, accumulated, challenge, public_key, params, proving_key) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.accumulatorVerifyNonMembershipProof(retptr, addHeapObject(proof), addHeapObject(accumulated), addHeapObject(challenge), addHeapObject(public_key), addHeapObject(params), addHeapObject(proving_key));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {any} protocol
* @param {Uint8Array} accumulated
* @param {Uint8Array} public_key
* @param {Uint8Array} params
* @param {Uint8Array} proving_key
* @returns {Uint8Array}
*/
function accumulatorChallengeContributionFromNonMembershipProtocol(protocol, accumulated, public_key, params, proving_key) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.accumulatorChallengeContributionFromNonMembershipProtocol(retptr, addHeapObject(protocol), addHeapObject(accumulated), addHeapObject(public_key), addHeapObject(params), addHeapObject(proving_key));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {any} proof
* @param {Uint8Array} accumulated
* @param {Uint8Array} public_key
* @param {Uint8Array} params
* @param {Uint8Array} proving_key
* @returns {Uint8Array}
*/
function accumulatorChallengeContributionFromNonMembershipProof(proof, accumulated, public_key, params, proving_key) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.accumulatorChallengeContributionFromNonMembershipProof(retptr, addHeapObject(proof), addHeapObject(accumulated), addHeapObject(public_key), addHeapObject(params), addHeapObject(proving_key));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {any} params
* @returns {Uint8Array}
*/
function generateSetupParamForBBSSignatureParametersG1(params) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.generateSetupParamForBBSSignatureParametersG1(retptr, addHeapObject(params));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array} public_key
* @returns {Uint8Array}
*/
function generateSetupParamForBBSPublicKeyG2(public_key) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.generateSetupParamForBBSPublicKeyG2(retptr, addHeapObject(public_key));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array} params
* @returns {Uint8Array}
*/
function generateSetupParamForVbAccumulatorParams(params) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.generateSetupParamForVbAccumulatorParams(retptr, addHeapObject(params));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array} public_key
* @returns {Uint8Array}
*/
function generateSetupParamForVbAccumulatorPublicKey(public_key) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.generateSetupParamForVbAccumulatorPublicKey(retptr, addHeapObject(public_key));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array} key
* @returns {Uint8Array}
*/
function generateSetupParamForVbAccumulatorMemProvingKey(key) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.generateSetupParamForVbAccumulatorMemProvingKey(retptr, addHeapObject(key));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array} key
* @returns {Uint8Array}
*/
function generateSetupParamForVbAccumulatorNonMemProvingKey(key) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.generateSetupParamForVbAccumulatorNonMemProvingKey(retptr, addHeapObject(key));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Array<any>} commitment_key
* @returns {Uint8Array}
*/
function generateSetupParamForPedersenCommitmentKeyG1(commitment_key) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.generateSetupParamForPedersenCommitmentKeyG1(retptr, addHeapObject(commitment_key));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Array<any>} commitment_key
* @returns {Uint8Array}
*/
function generateSetupParamForPedersenCommitmentKeyG2(commitment_key) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.generateSetupParamForPedersenCommitmentKeyG2(retptr, addHeapObject(commitment_key));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* If `uncompressed` is true, expects the encryption generators to be in uncompressed form else
* they should be compressed.
* @param {Uint8Array} enc_gens
* @param {boolean} uncompressed
* @returns {Uint8Array}
*/
function generateSetupParamForSaverEncryptionGens(enc_gens, uncompressed) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.generateSetupParamForSaverEncryptionGens(retptr, addHeapObject(enc_gens), uncompressed);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* If `uncompressed` is true, expects the commitment generators to be in uncompressed form else
* they should be compressed.
* @param {Uint8Array} comm_gens
* @param {boolean} uncompressed
* @returns {Uint8Array}
*/
function generateSetupParamForSaverCommitmentGens(comm_gens, uncompressed) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.generateSetupParamForSaverCommitmentGens(retptr, addHeapObject(comm_gens), uncompressed);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* If `uncompressed` is true, expects the encryption key to be in uncompressed form else
* it should be compressed.
* @param {Uint8Array} key
* @param {boolean} uncompressed
* @returns {Uint8Array}
*/
function generateSetupParamForSaverEncryptionKey(key, uncompressed) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.generateSetupParamForSaverEncryptionKey(retptr, addHeapObject(key), uncompressed);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* If `uncompressed` is true, expects the snark proving key to be in uncompressed form else
* it should be compressed.
* @param {Uint8Array} key
* @param {boolean} uncompressed
* @returns {Uint8Array}
*/
function generateSetupParamForSaverProvingKey(key, uncompressed) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.generateSetupParamForSaverProvingKey(retptr, addHeapObject(key), uncompressed);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* If `uncompressed` is true, expects the snark verifying key to be in uncompressed form else
* it should be compressed.
* @param {Uint8Array} key
* @param {boolean} uncompressed
* @returns {Uint8Array}
*/
function generateSetupParamForSaverVerifyingKey(key, uncompressed) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.generateSetupParamForSaverVerifyingKey(retptr, addHeapObject(key), uncompressed);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* If `uncompressed` is true, expects the legosnark proving key to be in uncompressed form else
* it should be compressed.
* @param {Uint8Array} key
* @param {boolean} uncompressed
* @returns {Uint8Array}
*/
function generateSetupParamForLegoProvingKey(key, uncompressed) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.generateSetupParamForLegoProvingKey(retptr, addHeapObject(key), uncompressed);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* If `uncompressed` is true, expects the legosnark verifying key to be in uncompressed form else
* it should be compressed.
* @param {Uint8Array} key
* @param {boolean} uncompressed
* @returns {Uint8Array}
*/
function generateSetupParamForLegoVerifyingKey(key, uncompressed) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.generateSetupParamForLegoVerifyingKey(retptr, addHeapObject(key), uncompressed);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {string} curve_name
* @param {number} num_public
* @param {number} num_private
* @param {Array<any>} constraints
* @returns {Uint8Array}
*/
function generateSetupParamForR1CS(curve_name, num_public, num_private, constraints) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        const ptr0 = passStringToWasm0(curve_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.generateSetupParamForR1CS(retptr, ptr0, len0, num_public, num_private, addHeapObject(constraints));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array} bytes
* @returns {Uint8Array}
*/
function generateSetupParamForBytes(bytes) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.generateSetupParamForBytes(retptr, addHeapObject(bytes));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Array<any>} arr
* @returns {Uint8Array}
*/
function generateSetupParamForFieldElemVec(arr) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.generateSetupParamForFieldElemVec(retptr, addHeapObject(arr));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* Setup snark and generate compressed or uncompressed SNARK proving key
* @param {boolean} return_uncompressed
* @returns {Uint8Array}
*/
function boundCheckSnarkSetup(return_uncompressed) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.boundCheckSnarkSetup(retptr, return_uncompressed);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {any} params
* @param {Uint8Array} public_key
* @param {Map<any, any>} revealed_msgs
* @param {boolean} encode_messages
* @returns {Uint8Array}
*/
function generatePoKBBSSignatureStatement(params, public_key, revealed_msgs, encode_messages) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.generatePoKBBSSignatureStatement(retptr, addHeapObject(params), addHeapObject(public_key), addHeapObject(revealed_msgs), encode_messages);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {number} params
* @param {number} public_key
* @param {Map<any, any>} revealed_msgs
* @param {boolean} encode_messages
* @returns {Uint8Array}
*/
function generatePoKBBSSignatureStatementFromParamRefs(params, public_key, revealed_msgs, encode_messages) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.generatePoKBBSSignatureStatementFromParamRefs(retptr, params, public_key, addHeapObject(revealed_msgs), encode_messages);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array} params
* @param {Uint8Array} public_key
* @param {Uint8Array} proving_key
* @param {Uint8Array} accumulated
* @returns {Uint8Array}
*/
function generateAccumulatorMembershipStatement(params, public_key, proving_key, accumulated) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.generateAccumulatorMembershipStatement(retptr, addHeapObject(params), addHeapObject(public_key), addHeapObject(proving_key), addHeapObject(accumulated));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {number} params
* @param {number} public_key
* @param {number} proving_key
* @param {Uint8Array} accumulated
* @returns {Uint8Array}
*/
function generateAccumulatorMembershipStatementFromParamRefs(params, public_key, proving_key, accumulated) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.generateAccumulatorMembershipStatementFromParamRefs(retptr, params, public_key, proving_key, addHeapObject(accumulated));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array} params
* @param {Uint8Array} public_key
* @param {Uint8Array} proving_key
* @param {Uint8Array} accumulated
* @returns {Uint8Array}
*/
function generateAccumulatorNonMembershipStatement(params, public_key, proving_key, accumulated) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.generateAccumulatorNonMembershipStatement(retptr, addHeapObject(params), addHeapObject(public_key), addHeapObject(proving_key), addHeapObject(accumulated));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {number} params
* @param {number} public_key
* @param {number} proving_key
* @param {Uint8Array} accumulated
* @returns {Uint8Array}
*/
function generateAccumulatorNonMembershipStatementFromParamRefs(params, public_key, proving_key, accumulated) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.generateAccumulatorNonMembershipStatementFromParamRefs(retptr, params, public_key, proving_key, addHeapObject(accumulated));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Array<any>} commitment_key
* @param {Uint8Array} commitment
* @returns {Uint8Array}
*/
function generatePedersenCommitmentG1Statement(commitment_key, commitment) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.generatePedersenCommitmentG1Statement(retptr, addHeapObject(commitment_key), addHeapObject(commitment));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {number} commitment_key
* @param {Uint8Array} commitment
* @returns {Uint8Array}
*/
function generatePedersenCommitmentG1StatementFromParamRefs(commitment_key, commitment) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.generatePedersenCommitmentG1StatementFromParamRefs(retptr, commitment_key, addHeapObject(commitment));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Array<any>} commitment_key
* @param {Uint8Array} commitment
* @returns {Uint8Array}
*/
function generatePedersenCommitmentG2Statement(commitment_key, commitment) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.generatePedersenCommitmentG2Statement(retptr, addHeapObject(commitment_key), addHeapObject(commitment));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {number} commitment_key
* @param {Uint8Array} commitment
* @returns {Uint8Array}
*/
function generatePedersenCommitmentG2StatementFromParamRefs(commitment_key, commitment) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.generatePedersenCommitmentG2StatementFromParamRefs(retptr, commitment_key, addHeapObject(commitment));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Set<any>} equality
* @returns {any}
*/
function generateWitnessEqualityMetaStatement(equality) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.generateWitnessEqualityMetaStatement(retptr, addHeapObject(equality));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {number} chunk_bit_size
* @param {Uint8Array} enc_gens
* @param {Uint8Array} chunked_comm_gens
* @param {Uint8Array} encryption_key
* @param {Uint8Array} snark_pk
* @param {boolean} uncompressed_public_params
* @returns {Uint8Array}
*/
function generateSaverProverStatement(chunk_bit_size, enc_gens, chunked_comm_gens, encryption_key, snark_pk, uncompressed_public_params) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.generateSaverProverStatement(retptr, chunk_bit_size, addHeapObject(enc_gens), addHeapObject(chunked_comm_gens), addHeapObject(encryption_key), addHeapObject(snark_pk), uncompressed_public_params);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {number} chunk_bit_size
* @param {number} enc_gens
* @param {number} chunked_comm_gens
* @param {number} encryption_key
* @param {number} snark_pk
* @returns {Uint8Array}
*/
function generateSaverProverStatementFromParamRefs(chunk_bit_size, enc_gens, chunked_comm_gens, encryption_key, snark_pk) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.generateSaverProverStatementFromParamRefs(retptr, chunk_bit_size, enc_gens, chunked_comm_gens, encryption_key, snark_pk);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {number} chunk_bit_size
* @param {Uint8Array} enc_gens
* @param {Uint8Array} chunked_comm_gens
* @param {Uint8Array} encryption_key
* @param {Uint8Array} snark_vk
* @param {boolean} uncompressed_public_params
* @returns {Uint8Array}
*/
function generateSaverVerifierStatement(chunk_bit_size, enc_gens, chunked_comm_gens, encryption_key, snark_vk, uncompressed_public_params) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.generateSaverVerifierStatement(retptr, chunk_bit_size, addHeapObject(enc_gens), addHeapObject(chunked_comm_gens), addHeapObject(encryption_key), addHeapObject(snark_vk), uncompressed_public_params);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {number} chunk_bit_size
* @param {number} enc_gens
* @param {number} chunked_comm_gens
* @param {number} encryption_key
* @param {number} snark_vk
* @returns {Uint8Array}
*/
function generateSaverVerifierStatementFromParamRefs(chunk_bit_size, enc_gens, chunked_comm_gens, encryption_key, snark_vk) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.generateSaverVerifierStatementFromParamRefs(retptr, chunk_bit_size, enc_gens, chunked_comm_gens, encryption_key, snark_vk);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* If `uncompressed` is true, expects the legosnark proving key to be in uncompressed form else
* it should be compressed.
* @param {number} min
* @param {number} max
* @param {Uint8Array} snark_pk
* @param {boolean} uncompressed_public_params
* @returns {Uint8Array}
*/
function generateBoundCheckLegoProverStatement(min, max, snark_pk, uncompressed_public_params) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.generateBoundCheckLegoProverStatement(retptr, addHeapObject(min), addHeapObject(max), addHeapObject(snark_pk), uncompressed_public_params);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {number} min
* @param {number} max
* @param {number} snark_pk
* @returns {Uint8Array}
*/
function generateBoundCheckLegoProverStatementFromParamRefs(min, max, snark_pk) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.generateBoundCheckLegoProverStatementFromParamRefs(retptr, addHeapObject(min), addHeapObject(max), snark_pk);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* If `uncompressed` is true, expects the legosnark verifying key to be in uncompressed form else
* it should be compressed.
* @param {number} min
* @param {number} max
* @param {Uint8Array} snark_vk
* @param {boolean} uncompressed_public_params
* @returns {Uint8Array}
*/
function generateBoundCheckLegoVerifierStatement(min, max, snark_vk, uncompressed_public_params) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.generateBoundCheckLegoVerifierStatement(retptr, addHeapObject(min), addHeapObject(max), addHeapObject(snark_vk), uncompressed_public_params);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {number} min
* @param {number} max
* @param {number} snark_vk
* @returns {Uint8Array}
*/
function generateBoundCheckLegoVerifierStatementFromParamRefs(min, max, snark_vk) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.generateBoundCheckLegoVerifierStatementFromParamRefs(retptr, addHeapObject(min), addHeapObject(max), snark_vk);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {string} curve_name
* @param {number} num_public
* @param {number} num_private
* @param {Array<any>} constraints
* @param {Uint8Array} wasm_bytes
* @param {Uint8Array} snark_pk
* @param {boolean} uncompressed_public_params
* @returns {Uint8Array}
*/
function generateR1CSCircomProverStatement(curve_name, num_public, num_private, constraints, wasm_bytes, snark_pk, uncompressed_public_params) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        const ptr0 = passStringToWasm0(curve_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.generateR1CSCircomProverStatement(retptr, ptr0, len0, num_public, num_private, addHeapObject(constraints), addHeapObject(wasm_bytes), addHeapObject(snark_pk), uncompressed_public_params);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {number} r1cs
* @param {number} wasm_bytes
* @param {number} snark_pk
* @returns {Uint8Array}
*/
function generateR1CSCircomProverStatementFromParamRefs(r1cs, wasm_bytes, snark_pk) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.generateR1CSCircomProverStatementFromParamRefs(retptr, r1cs, wasm_bytes, snark_pk);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Array<any>} public_inputs
* @param {Uint8Array} snark_vk
* @param {boolean} uncompressed_public_params
* @returns {Uint8Array}
*/
function generateR1CSCircomVerifierStatement(public_inputs, snark_vk, uncompressed_public_params) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.generateR1CSCircomVerifierStatement(retptr, addHeapObject(public_inputs), addHeapObject(snark_vk), uncompressed_public_params);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {number} public_inputs
* @param {number} snark_vk
* @returns {Uint8Array}
*/
function generateR1CSCircomVerifierStatementFromParamRefs(public_inputs, snark_vk) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.generateR1CSCircomVerifierStatementFromParamRefs(retptr, public_inputs, snark_vk);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array} wasm_bytes
* @param {Map<any, any>} input_wires
* @returns {Array<any>}
*/
function r1csGenerateWires(wasm_bytes, input_wires) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.r1csGenerateWires(retptr, addHeapObject(wasm_bytes), addHeapObject(input_wires));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {string} curve_name
* @param {number} num_public
* @param {number} num_private
* @param {Array<any>} constraints
* @param {Uint8Array} wasm_bytes
* @param {Map<any, any>} input_wires
* @returns {boolean}
*/
function r1csCircuitSatisfied(curve_name, num_public, num_private, constraints, wasm_bytes, input_wires) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        const ptr0 = passStringToWasm0(curve_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.r1csCircuitSatisfied(retptr, ptr0, len0, num_public, num_private, addHeapObject(constraints), addHeapObject(wasm_bytes), addHeapObject(input_wires));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return r0 !== 0;
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {string} curve_name
* @param {number} num_public
* @param {number} num_private
* @param {Array<any>} constraints
* @param {number} commit_witness_count
* @param {boolean} return_uncompressed
* @returns {Uint8Array}
*/
function r1csSnarkSetup(curve_name, num_public, num_private, constraints, commit_witness_count, return_uncompressed) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        const ptr0 = passStringToWasm0(curve_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.r1csSnarkSetup(retptr, ptr0, len0, num_public, num_private, addHeapObject(constraints), commit_witness_count, return_uncompressed);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

function handleError(f, args) {
    try {
        return f.apply(this, args);
    } catch (e) {
        wasm.__wbindgen_exn_store(addHeapObject(e));
    }
}
/**
* A struct representing an aborted instruction execution, with a message
* indicating the cause.
*/
class WasmerRuntimeError {

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_wasmerruntimeerror_free(ptr);
    }
}

async function load(module, imports) {
    if (typeof Response === 'function' && module instanceof Response) {
        if (typeof WebAssembly.instantiateStreaming === 'function') {
            try {
                return await WebAssembly.instantiateStreaming(module, imports);

            } catch (e) {
                if (module.headers.get('Content-Type') != 'application/wasm') {
                    console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);

                } else {
                    throw e;
                }
            }
        }

        const bytes = await module.arrayBuffer();
        return await WebAssembly.instantiate(bytes, imports);

    } else {
        const instance = await WebAssembly.instantiate(module, imports);

        if (instance instanceof WebAssembly.Instance) {
            return { instance, module };

        } else {
            return instance;
        }
    }
}

function getImports() {
    const imports = {};
    imports.wbg = {};
    imports.wbg.__wbindgen_object_drop_ref = function(arg0) {
        takeObject(arg0);
    };
    imports.wbg.__wbindgen_string_new = function(arg0, arg1) {
        const ret = getStringFromWasm0(arg0, arg1);
        return addHeapObject(ret);
    };
    imports.wbg.__wbindgen_number_new = function(arg0) {
        const ret = arg0;
        return addHeapObject(ret);
    };
    imports.wbg.__wbindgen_ge = function(arg0, arg1) {
        const ret = getObject(arg0) >= getObject(arg1);
        return ret;
    };
    imports.wbg.__wbindgen_is_bigint = function(arg0) {
        const ret = typeof(getObject(arg0)) === 'bigint';
        return ret;
    };
    imports.wbg.__wbindgen_is_string = function(arg0) {
        const ret = typeof(getObject(arg0)) === 'string';
        return ret;
    };
    imports.wbg.__wbindgen_string_get = function(arg0, arg1) {
        const obj = getObject(arg1);
        const ret = typeof(obj) === 'string' ? obj : undefined;
        var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        getInt32Memory0()[arg0 / 4 + 1] = len0;
        getInt32Memory0()[arg0 / 4 + 0] = ptr0;
    };
    imports.wbg.__wbindgen_number_get = function(arg0, arg1) {
        const obj = getObject(arg1);
        const ret = typeof(obj) === 'number' ? obj : undefined;
        getFloat64Memory0()[arg0 / 8 + 1] = isLikeNone(ret) ? 0 : ret;
        getInt32Memory0()[arg0 / 4 + 0] = !isLikeNone(ret);
    };
    imports.wbg.__wbindgen_is_object = function(arg0) {
        const val = getObject(arg0);
        const ret = typeof(val) === 'object' && val !== null;
        return ret;
    };
    imports.wbg.__wbg_BigInt_1fab4952b6c4a499 = function(arg0) {
        const ret = BigInt(BigInt.asUintN(64, arg0));
        return addHeapObject(ret);
    };
    imports.wbg.__wbindgen_object_clone_ref = function(arg0) {
        const ret = getObject(arg0);
        return addHeapObject(ret);
    };
    imports.wbg.__wbindgen_is_null = function(arg0) {
        const ret = getObject(arg0) === null;
        return ret;
    };
    imports.wbg.__wbindgen_is_undefined = function(arg0) {
        const ret = getObject(arg0) === undefined;
        return ret;
    };
    imports.wbg.__wbg_BigInt_67359e71cae1c6c9 = function(arg0) {
        const ret = BigInt(getObject(arg0));
        return ret;
    };
    imports.wbg.__wbindgen_boolean_get = function(arg0) {
        const v = getObject(arg0);
        const ret = typeof(v) === 'boolean' ? (v ? 1 : 0) : 2;
        return ret;
    };
    imports.wbg.__wbg_get_2268d91a19a98b92 = function(arg0, arg1) {
        const ret = getObject(arg0)[takeObject(arg1)];
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_set_c943d600fa71e4dd = function(arg0, arg1, arg2) {
        getObject(arg0)[takeObject(arg1)] = takeObject(arg2);
    };
    imports.wbg.__wbg_instanceof_Global_71ffa48bd62833fb = function(arg0) {
        let result;
        try {
            result = getObject(arg0) instanceof WebAssembly.Global;
        } catch {
            result = false;
        }
        const ret = result;
        return ret;
    };
    imports.wbg.__wbg_randomFillSync_85b3f4c52c56c313 = function(arg0, arg1, arg2) {
        
    };
    imports.wbg.__wbg_getRandomValues_cd175915511f705e = function(arg0, arg1) {
        getObject(arg0).getRandomValues(getObject(arg1));
    };
    imports.wbg.__wbg_self_7eede1f4488bf346 = function() { return handleError(function () {
        const ret = self.self;
        return addHeapObject(ret);
    }, arguments) };
    imports.wbg.__wbg_crypto_c909fb428dcbddb6 = function(arg0) {
        const ret = getObject(arg0).crypto;
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_msCrypto_511eefefbfc70ae4 = function(arg0) {
        const ret = getObject(arg0).msCrypto;
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_static_accessor_MODULE_ef3aa2eb251158a5 = function() {
        const ret = module;
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_require_900d5c3984fe7703 = function(arg0, arg1, arg2) {
        const ret = getObject(arg0).require(getStringFromWasm0(arg1, arg2));
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_getRandomValues_307049345d0bd88c = function(arg0) {
        const ret = getObject(arg0).getRandomValues;
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_get_57245cc7d7c7619d = function(arg0, arg1) {
        const ret = getObject(arg0)[arg1 >>> 0];
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_length_6e3bbe7c8bd4dbd8 = function(arg0) {
        const ret = getObject(arg0).length;
        return ret;
    };
    imports.wbg.__wbg_new_1d9a920c6bfc44a8 = function() {
        const ret = new Array();
        return addHeapObject(ret);
    };
    imports.wbg.__wbindgen_is_function = function(arg0) {
        const ret = typeof(getObject(arg0)) === 'function';
        return ret;
    };
    imports.wbg.__wbg_new_268f7b7dd3430798 = function() {
        const ret = new Map();
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_next_579e583d33566a86 = function(arg0) {
        const ret = getObject(arg0).next;
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_next_aaef7c8aa5e212ac = function() { return handleError(function (arg0) {
        const ret = getObject(arg0).next();
        return addHeapObject(ret);
    }, arguments) };
    imports.wbg.__wbg_done_1b73b0672e15f234 = function(arg0) {
        const ret = getObject(arg0).done;
        return ret;
    };
    imports.wbg.__wbg_value_1ccc36bc03462d71 = function(arg0) {
        const ret = getObject(arg0).value;
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_iterator_6f9d4f28845f426c = function() {
        const ret = Symbol.iterator;
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_get_765201544a2b6869 = function() { return handleError(function (arg0, arg1) {
        const ret = Reflect.get(getObject(arg0), getObject(arg1));
        return addHeapObject(ret);
    }, arguments) };
    imports.wbg.__wbg_call_97ae9d8645dc388b = function() { return handleError(function (arg0, arg1) {
        const ret = getObject(arg0).call(getObject(arg1));
        return addHeapObject(ret);
    }, arguments) };
    imports.wbg.__wbg_new_0b9bfdd97583284e = function() {
        const ret = new Object();
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_newwithlength_7c42f7e738a9d5d3 = function(arg0) {
        const ret = new Array(arg0 >>> 0);
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_set_a68214f35c417fa9 = function(arg0, arg1, arg2) {
        getObject(arg0)[arg1 >>> 0] = takeObject(arg2);
    };
    imports.wbg.__wbg_from_7ce3cb27cb258569 = function(arg0) {
        const ret = Array.from(getObject(arg0));
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_isArray_27c46c67f498e15d = function(arg0) {
        const ret = Array.isArray(getObject(arg0));
        return ret;
    };
    imports.wbg.__wbg_push_740e4b286702d964 = function(arg0, arg1) {
        const ret = getObject(arg0).push(getObject(arg1));
        return ret;
    };
    imports.wbg.__wbg_instanceof_ArrayBuffer_e5e48f4762c5610b = function(arg0) {
        let result;
        try {
            result = getObject(arg0) instanceof ArrayBuffer;
        } catch {
            result = false;
        }
        const ret = result;
        return ret;
    };
    imports.wbg.__wbg_entries_5e3f03f9df6bb58a = function(arg0) {
        const ret = getObject(arg0).entries();
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_values_e42671acbf11ec04 = function(arg0) {
        const ret = getObject(arg0).values();
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_new_8d2af00bc1e329ee = function(arg0, arg1) {
        const ret = new Error(getStringFromWasm0(arg0, arg1));
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_instanceof_Function_056d5b3aef8aaa85 = function(arg0) {
        let result;
        try {
            result = getObject(arg0) instanceof Function;
        } catch {
            result = false;
        }
        const ret = result;
        return ret;
    };
    imports.wbg.__wbg_bind_ca24d624360a8ab1 = function(arg0, arg1, arg2) {
        const ret = getObject(arg0).bind(getObject(arg1), getObject(arg2));
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_name_da379f055623f0d3 = function(arg0) {
        const ret = getObject(arg0).name;
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_get_cff53376ea5c1658 = function(arg0, arg1) {
        const ret = getObject(arg0).get(getObject(arg1));
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_set_933729cf5b66ac11 = function(arg0, arg1, arg2) {
        const ret = getObject(arg0).set(getObject(arg1), getObject(arg2));
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_entries_ff7071308de9aaec = function(arg0) {
        const ret = getObject(arg0).entries();
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_isSafeInteger_dfa0593e8d7ac35a = function(arg0) {
        const ret = Number.isSafeInteger(getObject(arg0));
        return ret;
    };
    imports.wbg.__wbg_valueOf_6b6effad03e5c546 = function(arg0) {
        const ret = getObject(arg0).valueOf();
        return ret;
    };
    imports.wbg.__wbg_constructor_20fd216941fe9866 = function(arg0) {
        const ret = getObject(arg0).constructor;
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_entries_65a76a413fc91037 = function(arg0) {
        const ret = Object.entries(getObject(arg0));
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_getPrototypeOf_ca7be35aca69033c = function(arg0) {
        const ret = Object.getPrototypeOf(getObject(arg0));
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_is_40a66842732708e7 = function(arg0, arg1) {
        const ret = Object.is(getObject(arg0), getObject(arg1));
        return ret;
    };
    imports.wbg.__wbg_values_a47b21e7728c4958 = function(arg0) {
        const ret = getObject(arg0).values();
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_buffer_3f3d764d4747d564 = function(arg0) {
        const ret = getObject(arg0).buffer;
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_newwithbyteoffsetandlength_d9aa266703cb98be = function(arg0, arg1, arg2) {
        const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_new_8c3f0052272a457a = function(arg0) {
        const ret = new Uint8Array(getObject(arg0));
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_set_83db9690f9353e79 = function(arg0, arg1, arg2) {
        getObject(arg0).set(getObject(arg1), arg2 >>> 0);
    };
    imports.wbg.__wbg_length_9e1ae1900cb0fbd5 = function(arg0) {
        const ret = getObject(arg0).length;
        return ret;
    };
    imports.wbg.__wbg_instanceof_Uint8Array_971eeda69eb75003 = function(arg0) {
        let result;
        try {
            result = getObject(arg0) instanceof Uint8Array;
        } catch {
            result = false;
        }
        const ret = result;
        return ret;
    };
    imports.wbg.__wbg_newwithlength_f5933855e4f48a19 = function(arg0) {
        const ret = new Uint8Array(arg0 >>> 0);
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_subarray_58ad4efbb5bcb886 = function(arg0, arg1, arg2) {
        const ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_new_1c5d2ff1edfe6d73 = function() { return handleError(function (arg0, arg1) {
        const ret = new WebAssembly.Instance(getObject(arg0), getObject(arg1));
        return addHeapObject(ret);
    }, arguments) };
    imports.wbg.__wbg_exports_1f32da4bc6734cea = function(arg0) {
        const ret = getObject(arg0).exports;
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_new_2c576172346480cc = function() { return handleError(function (arg0) {
        const ret = new WebAssembly.Module(getObject(arg0));
        return addHeapObject(ret);
    }, arguments) };
    imports.wbg.__wbg_exports_4db28c393be16bc5 = function(arg0) {
        const ret = WebAssembly.Module.exports(getObject(arg0));
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_imports_5d97b92618ae2b69 = function(arg0) {
        const ret = WebAssembly.Module.imports(getObject(arg0));
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_instanceof_Table_aab62205c7444b79 = function(arg0) {
        let result;
        try {
            result = getObject(arg0) instanceof WebAssembly.Table;
        } catch {
            result = false;
        }
        const ret = result;
        return ret;
    };
    imports.wbg.__wbg_get_19328b9e516e0330 = function() { return handleError(function (arg0, arg1) {
        const ret = getObject(arg0).get(arg1 >>> 0);
        return addHeapObject(ret);
    }, arguments) };
    imports.wbg.__wbg_instanceof_Memory_f1dc0d9a83a9c8ea = function(arg0) {
        let result;
        try {
            result = getObject(arg0) instanceof WebAssembly.Memory;
        } catch {
            result = false;
        }
        const ret = result;
        return ret;
    };
    imports.wbg.__wbg_apply_75f7334893eef4ad = function() { return handleError(function (arg0, arg1, arg2) {
        const ret = Reflect.apply(getObject(arg0), getObject(arg1), getObject(arg2));
        return addHeapObject(ret);
    }, arguments) };
    imports.wbg.__wbg_set_bf3f89b92d5a34bf = function() { return handleError(function (arg0, arg1, arg2) {
        const ret = Reflect.set(getObject(arg0), getObject(arg1), getObject(arg2));
        return ret;
    }, arguments) };
    imports.wbg.__wbindgen_debug_string = function(arg0, arg1) {
        const ret = debugString(getObject(arg1));
        const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        getInt32Memory0()[arg0 / 4 + 1] = len0;
        getInt32Memory0()[arg0 / 4 + 0] = ptr0;
    };
    imports.wbg.__wbindgen_throw = function(arg0, arg1) {
        throw new Error(getStringFromWasm0(arg0, arg1));
    };
    imports.wbg.__wbindgen_memory = function() {
        const ret = wasm.memory;
        return addHeapObject(ret);
    };
    imports.wbg.__wbindgen_function_table = function() {
        const ret = wasm.__wbindgen_export_2;
        return addHeapObject(ret);
    };

    return imports;
}

function finalizeInit(instance, module) {
    wasm = instance.exports;
    init.__wbindgen_wasm_module = module;
    cachedFloat64Memory0 = new Float64Array();
    cachedInt32Memory0 = new Int32Array();
    cachedUint32Memory0 = new Uint32Array();
    cachedUint8Memory0 = new Uint8Array();


    return wasm;
}

function initSync(module) {
    const imports = getImports();

    if (!(module instanceof WebAssembly.Module)) {
        module = new WebAssembly.Module(module);
    }

    const instance = new WebAssembly.Instance(module, imports);

    return finalizeInit(instance, module);
}

async function init(input) {
    if (typeof input === 'undefined') {
        input = require("./dock_crypto_wasm_bs64.js");
    }
    const imports = getImports();

    if (typeof input === 'string' || (typeof Request === 'function' && input instanceof Request) || (typeof URL === 'function' && input instanceof URL)) {
        input = fetch(input);
    }

    const { instance, module } = await load(await input, imports);

    return finalizeInit(instance, module);
}

exports.WasmerRuntimeError = WasmerRuntimeError;
exports.accumulatorChallengeContributionFromMembershipProof = accumulatorChallengeContributionFromMembershipProof;
exports.accumulatorChallengeContributionFromMembershipProtocol = accumulatorChallengeContributionFromMembershipProtocol;
exports.accumulatorChallengeContributionFromNonMembershipProof = accumulatorChallengeContributionFromNonMembershipProof;
exports.accumulatorChallengeContributionFromNonMembershipProtocol = accumulatorChallengeContributionFromNonMembershipProtocol;
exports.accumulatorDeriveMembershipProvingKeyFromNonMembershipKey = accumulatorDeriveMembershipProvingKeyFromNonMembershipKey;
exports.accumulatorGenMembershipProof = accumulatorGenMembershipProof;
exports.accumulatorGenNonMembershipProof = accumulatorGenNonMembershipProof;
exports.accumulatorGetElementFromBytes = accumulatorGetElementFromBytes;
exports.accumulatorInitializeMembershipProof = accumulatorInitializeMembershipProof;
exports.accumulatorInitializeNonMembershipProof = accumulatorInitializeNonMembershipProof;
exports.accumulatorVerifyMembershipProof = accumulatorVerifyMembershipProof;
exports.accumulatorVerifyNonMembershipProof = accumulatorVerifyNonMembershipProof;
exports.bbsAdaptSigParamsG1ForMsgCount = bbsAdaptSigParamsG1ForMsgCount;
exports.bbsAdaptSigParamsG2ForMsgCount = bbsAdaptSigParamsG2ForMsgCount;
exports.bbsBlindSignG1 = bbsBlindSignG1;
exports.bbsBlindSignG2 = bbsBlindSignG2;
exports.bbsChallengeContributionFromProof = bbsChallengeContributionFromProof;
exports.bbsChallengeContributionFromProtocol = bbsChallengeContributionFromProtocol;
exports.bbsCommitMsgsInG1 = bbsCommitMsgsInG1;
exports.bbsCommitMsgsInG2 = bbsCommitMsgsInG2;
exports.bbsEncodeMessageForSigning = bbsEncodeMessageForSigning;
exports.bbsEncodeMessagesForSigning = bbsEncodeMessagesForSigning;
exports.bbsGenProofOfKnowledgeOfSignature = bbsGenProofOfKnowledgeOfSignature;
exports.bbsGetBasesForCommitmentG1 = bbsGetBasesForCommitmentG1;
exports.bbsGetBasesForCommitmentG2 = bbsGetBasesForCommitmentG2;
exports.bbsInitializeProofOfKnowledgeOfSignature = bbsInitializeProofOfKnowledgeOfSignature;
exports.bbsSignG1 = bbsSignG1;
exports.bbsSignG2 = bbsSignG2;
exports.bbsSignatureParamsG1FromBytes = bbsSignatureParamsG1FromBytes;
exports.bbsSignatureParamsG1MaxSupportedMsgs = bbsSignatureParamsG1MaxSupportedMsgs;
exports.bbsSignatureParamsG1ToBytes = bbsSignatureParamsG1ToBytes;
exports.bbsSignatureParamsG2FromBytes = bbsSignatureParamsG2FromBytes;
exports.bbsSignatureParamsG2MaxSupportedMsgs = bbsSignatureParamsG2MaxSupportedMsgs;
exports.bbsSignatureParamsG2ToBytes = bbsSignatureParamsG2ToBytes;
exports.bbsUnblindSigG1 = bbsUnblindSigG1;
exports.bbsUnblindSigG2 = bbsUnblindSigG2;
exports.bbsVerifyG1 = bbsVerifyG1;
exports.bbsVerifyG2 = bbsVerifyG2;
exports.bbsVerifyProofOfKnowledgeOfSignature = bbsVerifyProofOfKnowledgeOfSignature;
exports.boundCheckSnarkSetup = boundCheckSnarkSetup;
exports.default = init;
exports.fieldElementAsBytes = fieldElementAsBytes;
exports.generateAccumulatorKeyPair = generateAccumulatorKeyPair;
exports.generateAccumulatorMembershipStatement = generateAccumulatorMembershipStatement;
exports.generateAccumulatorMembershipStatementFromParamRefs = generateAccumulatorMembershipStatementFromParamRefs;
exports.generateAccumulatorMembershipWitness = generateAccumulatorMembershipWitness;
exports.generateAccumulatorNonMembershipStatement = generateAccumulatorNonMembershipStatement;
exports.generateAccumulatorNonMembershipStatementFromParamRefs = generateAccumulatorNonMembershipStatementFromParamRefs;
exports.generateAccumulatorNonMembershipWitness = generateAccumulatorNonMembershipWitness;
exports.generateAccumulatorParams = generateAccumulatorParams;
exports.generateAccumulatorPublicKey = generateAccumulatorPublicKey;
exports.generateAccumulatorSecretKey = generateAccumulatorSecretKey;
exports.generateBBSKeyPairG1 = generateBBSKeyPairG1;
exports.generateBBSKeyPairG2 = generateBBSKeyPairG2;
exports.generateBBSPublicKeyG1 = generateBBSPublicKeyG1;
exports.generateBBSPublicKeyG2 = generateBBSPublicKeyG2;
exports.generateBBSSigningKey = generateBBSSigningKey;
exports.generateBoundCheckLegoProverStatement = generateBoundCheckLegoProverStatement;
exports.generateBoundCheckLegoProverStatementFromParamRefs = generateBoundCheckLegoProverStatementFromParamRefs;
exports.generateBoundCheckLegoVerifierStatement = generateBoundCheckLegoVerifierStatement;
exports.generateBoundCheckLegoVerifierStatementFromParamRefs = generateBoundCheckLegoVerifierStatementFromParamRefs;
exports.generateBoundCheckWitness = generateBoundCheckWitness;
exports.generateChallengeFromBytes = generateChallengeFromBytes;
exports.generateCompositeProofG1 = generateCompositeProofG1;
exports.generateCompositeProofG1WithDeconstructedProofSpec = generateCompositeProofG1WithDeconstructedProofSpec;
exports.generateCompositeProofG2 = generateCompositeProofG2;
exports.generateFieldElementFromBytes = generateFieldElementFromBytes;
exports.generateFieldElementFromNumber = generateFieldElementFromNumber;
exports.generateMembershipProvingKey = generateMembershipProvingKey;
exports.generateNonMembershipProvingKey = generateNonMembershipProvingKey;
exports.generatePedersenCommitmentG1Statement = generatePedersenCommitmentG1Statement;
exports.generatePedersenCommitmentG1StatementFromParamRefs = generatePedersenCommitmentG1StatementFromParamRefs;
exports.generatePedersenCommitmentG2Statement = generatePedersenCommitmentG2Statement;
exports.generatePedersenCommitmentG2StatementFromParamRefs = generatePedersenCommitmentG2StatementFromParamRefs;
exports.generatePedersenCommitmentWitness = generatePedersenCommitmentWitness;
exports.generatePoKBBSSignatureStatement = generatePoKBBSSignatureStatement;
exports.generatePoKBBSSignatureStatementFromParamRefs = generatePoKBBSSignatureStatementFromParamRefs;
exports.generatePoKBBSSignatureWitness = generatePoKBBSSignatureWitness;
exports.generateProofSpecG1 = generateProofSpecG1;
exports.generateProofSpecG2 = generateProofSpecG2;
exports.generateR1CSCircomProverStatement = generateR1CSCircomProverStatement;
exports.generateR1CSCircomProverStatementFromParamRefs = generateR1CSCircomProverStatementFromParamRefs;
exports.generateR1CSCircomVerifierStatement = generateR1CSCircomVerifierStatement;
exports.generateR1CSCircomVerifierStatementFromParamRefs = generateR1CSCircomVerifierStatementFromParamRefs;
exports.generateR1CSCircomWitness = generateR1CSCircomWitness;
exports.generateRandomFieldElement = generateRandomFieldElement;
exports.generateRandomG1Element = generateRandomG1Element;
exports.generateRandomG2Element = generateRandomG2Element;
exports.generateSaverProverStatement = generateSaverProverStatement;
exports.generateSaverProverStatementFromParamRefs = generateSaverProverStatementFromParamRefs;
exports.generateSaverVerifierStatement = generateSaverVerifierStatement;
exports.generateSaverVerifierStatementFromParamRefs = generateSaverVerifierStatementFromParamRefs;
exports.generateSaverWitness = generateSaverWitness;
exports.generateSetupParamForBBSPublicKeyG2 = generateSetupParamForBBSPublicKeyG2;
exports.generateSetupParamForBBSSignatureParametersG1 = generateSetupParamForBBSSignatureParametersG1;
exports.generateSetupParamForBytes = generateSetupParamForBytes;
exports.generateSetupParamForFieldElemVec = generateSetupParamForFieldElemVec;
exports.generateSetupParamForLegoProvingKey = generateSetupParamForLegoProvingKey;
exports.generateSetupParamForLegoVerifyingKey = generateSetupParamForLegoVerifyingKey;
exports.generateSetupParamForPedersenCommitmentKeyG1 = generateSetupParamForPedersenCommitmentKeyG1;
exports.generateSetupParamForPedersenCommitmentKeyG2 = generateSetupParamForPedersenCommitmentKeyG2;
exports.generateSetupParamForR1CS = generateSetupParamForR1CS;
exports.generateSetupParamForSaverCommitmentGens = generateSetupParamForSaverCommitmentGens;
exports.generateSetupParamForSaverEncryptionGens = generateSetupParamForSaverEncryptionGens;
exports.generateSetupParamForSaverEncryptionKey = generateSetupParamForSaverEncryptionKey;
exports.generateSetupParamForSaverProvingKey = generateSetupParamForSaverProvingKey;
exports.generateSetupParamForSaverVerifyingKey = generateSetupParamForSaverVerifyingKey;
exports.generateSetupParamForVbAccumulatorMemProvingKey = generateSetupParamForVbAccumulatorMemProvingKey;
exports.generateSetupParamForVbAccumulatorNonMemProvingKey = generateSetupParamForVbAccumulatorNonMemProvingKey;
exports.generateSetupParamForVbAccumulatorParams = generateSetupParamForVbAccumulatorParams;
exports.generateSetupParamForVbAccumulatorPublicKey = generateSetupParamForVbAccumulatorPublicKey;
exports.generateSignatureParamsG1 = generateSignatureParamsG1;
exports.generateSignatureParamsG2 = generateSignatureParamsG2;
exports.generateWitnessEqualityMetaStatement = generateWitnessEqualityMetaStatement;
exports.initSync = initSync;
exports.isAccumulatorParamsValid = isAccumulatorParamsValid;
exports.isAccumulatorPublicKeyValid = isAccumulatorPublicKeyValid;
exports.isBBSPublicKeyG1Valid = isBBSPublicKeyG1Valid;
exports.isBBSPublicKeyG2Valid = isBBSPublicKeyG2Valid;
exports.isProofSpecG1Valid = isProofSpecG1Valid;
exports.isProofSpecG2Valid = isProofSpecG2Valid;
exports.isSignatureParamsG1Valid = isSignatureParamsG1Valid;
exports.isSignatureParamsG2Valid = isSignatureParamsG2Valid;
exports.legosnarkDecompressPk = legosnarkDecompressPk;
exports.legosnarkDecompressVk = legosnarkDecompressVk;
exports.legosnarkVkFromPk = legosnarkVkFromPk;
exports.pedersenCommitmentG1 = pedersenCommitmentG1;
exports.pedersenCommitmentG2 = pedersenCommitmentG2;
exports.positiveAccumulatorAdd = positiveAccumulatorAdd;
exports.positiveAccumulatorAddBatch = positiveAccumulatorAddBatch;
exports.positiveAccumulatorBatchUpdates = positiveAccumulatorBatchUpdates;
exports.positiveAccumulatorGetAccumulated = positiveAccumulatorGetAccumulated;
exports.positiveAccumulatorInitialize = positiveAccumulatorInitialize;
exports.positiveAccumulatorMembershipWitness = positiveAccumulatorMembershipWitness;
exports.positiveAccumulatorMembershipWitnessesForBatch = positiveAccumulatorMembershipWitnessesForBatch;
exports.positiveAccumulatorRemove = positiveAccumulatorRemove;
exports.positiveAccumulatorRemoveBatch = positiveAccumulatorRemoveBatch;
exports.positiveAccumulatorVerifyMembership = positiveAccumulatorVerifyMembership;
exports.publicInfoForWitnessUpdate = publicInfoForWitnessUpdate;
exports.r1csCircuitSatisfied = r1csCircuitSatisfied;
exports.r1csGenerateWires = r1csGenerateWires;
exports.r1csSnarkSetup = r1csSnarkSetup;
exports.saverDecompressChunkedCommitmentGenerators = saverDecompressChunkedCommitmentGenerators;
exports.saverDecompressDecryptionKey = saverDecompressDecryptionKey;
exports.saverDecompressEncryptionGenerators = saverDecompressEncryptionGenerators;
exports.saverDecompressEncryptionKey = saverDecompressEncryptionKey;
exports.saverDecompressSnarkPk = saverDecompressSnarkPk;
exports.saverDecompressSnarkVk = saverDecompressSnarkVk;
exports.saverDecryptCiphertextUsingSnarkPk = saverDecryptCiphertextUsingSnarkPk;
exports.saverDecryptCiphertextUsingSnarkVk = saverDecryptCiphertextUsingSnarkVk;
exports.saverDecryptorSetup = saverDecryptorSetup;
exports.saverGenerateChunkedCommitmentGenerators = saverGenerateChunkedCommitmentGenerators;
exports.saverGenerateEncryptionGenerators = saverGenerateEncryptionGenerators;
exports.saverGetCiphertextFromProof = saverGetCiphertextFromProof;
exports.saverGetCiphertextsFromProof = saverGetCiphertextsFromProof;
exports.saverGetSnarkVkFromPk = saverGetSnarkVkFromPk;
exports.saverVerifyDecryptionUsingSnarkPk = saverVerifyDecryptionUsingSnarkPk;
exports.saverVerifyDecryptionUsingSnarkVk = saverVerifyDecryptionUsingSnarkVk;
exports.universalAccumulatorAdd = universalAccumulatorAdd;
exports.universalAccumulatorAddBatch = universalAccumulatorAddBatch;
exports.universalAccumulatorBatchUpdates = universalAccumulatorBatchUpdates;
exports.universalAccumulatorCombineMultipleD = universalAccumulatorCombineMultipleD;
exports.universalAccumulatorCombineMultipleDForBatch = universalAccumulatorCombineMultipleDForBatch;
exports.universalAccumulatorCombineMultipleInitialFv = universalAccumulatorCombineMultipleInitialFv;
exports.universalAccumulatorComputeD = universalAccumulatorComputeD;
exports.universalAccumulatorComputeDForBatch = universalAccumulatorComputeDForBatch;
exports.universalAccumulatorComputeInitialFv = universalAccumulatorComputeInitialFv;
exports.universalAccumulatorFixedInitialElements = universalAccumulatorFixedInitialElements;
exports.universalAccumulatorGetAccumulated = universalAccumulatorGetAccumulated;
exports.universalAccumulatorInitialiseGivenFv = universalAccumulatorInitialiseGivenFv;
exports.universalAccumulatorMembershipWitness = universalAccumulatorMembershipWitness;
exports.universalAccumulatorMembershipWitnessesForBatch = universalAccumulatorMembershipWitnessesForBatch;
exports.universalAccumulatorNonMembershipWitness = universalAccumulatorNonMembershipWitness;
exports.universalAccumulatorNonMembershipWitnessesForBatch = universalAccumulatorNonMembershipWitnessesForBatch;
exports.universalAccumulatorRemove = universalAccumulatorRemove;
exports.universalAccumulatorRemoveBatch = universalAccumulatorRemoveBatch;
exports.universalAccumulatorVerifyMembership = universalAccumulatorVerifyMembership;
exports.universalAccumulatorVerifyNonMembership = universalAccumulatorVerifyNonMembership;
exports.updateMembershipWitnessPostAdd = updateMembershipWitnessPostAdd;
exports.updateMembershipWitnessPostRemove = updateMembershipWitnessPostRemove;
exports.updateMembershipWitnessUsingPublicInfoAfterBatchUpdate = updateMembershipWitnessUsingPublicInfoAfterBatchUpdate;
exports.updateMembershipWitnessUsingPublicInfoAfterMultipleBatchUpdates = updateMembershipWitnessUsingPublicInfoAfterMultipleBatchUpdates;
exports.updateMembershipWitnessesPostBatchUpdates = updateMembershipWitnessesPostBatchUpdates;
exports.updateNonMembershipWitnessPostAdd = updateNonMembershipWitnessPostAdd;
exports.updateNonMembershipWitnessPostRemove = updateNonMembershipWitnessPostRemove;
exports.updateNonMembershipWitnessUsingPublicInfoAfterBatchUpdate = updateNonMembershipWitnessUsingPublicInfoAfterBatchUpdate;
exports.updateNonMembershipWitnessUsingPublicInfoAfterMultipleBatchUpdates = updateNonMembershipWitnessUsingPublicInfoAfterMultipleBatchUpdates;
exports.updateNonMembershipWitnessesPostBatchUpdates = updateNonMembershipWitnessesPostBatchUpdates;
exports.verifyCompositeProofG1 = verifyCompositeProofG1;
exports.verifyCompositeProofG1WithDeconstructedProofSpec = verifyCompositeProofG1WithDeconstructedProofSpec;
exports.verifyCompositeProofG2 = verifyCompositeProofG2;
