/* tslint:disable */
/* eslint-disable */
/**
* @param {Uint8Array | undefined} label
* @returns {Uint8Array}
*/
export function saverGenerateEncryptionGenerators(label?: Uint8Array): Uint8Array;
/**
* @param {Uint8Array | undefined} label
* @returns {Uint8Array}
*/
export function saverGenerateChunkedCommitmentGenerators(label?: Uint8Array): Uint8Array;
/**
* Does setup for decryptor for the given chunk size and encryption generators. Creates snark SRS, secret key,
* encryption key and decryption key and returns them in an array of size 4.
* @param {number} chunk_bit_size
* @param {Uint8Array} enc_gens
* @param {boolean} return_uncompressed_snark_pk
* @returns {Array<any>}
*/
export function saverDecryptorSetup(chunk_bit_size: number, enc_gens: Uint8Array, return_uncompressed_snark_pk: boolean): Array<any>;
/**
* Takes compressed encryption generators and returns their uncompressed form
* @param {Uint8Array} enc_gens
* @returns {Uint8Array}
*/
export function saverDecompressEncryptionGenerators(enc_gens: Uint8Array): Uint8Array;
/**
* Takes compressed chunked commitment generators and returns their uncompressed form
* @param {Uint8Array} comm_gens
* @returns {Uint8Array}
*/
export function saverDecompressChunkedCommitmentGenerators(comm_gens: Uint8Array): Uint8Array;
/**
* Takes compressed encryption key and returns its uncompressed form
* @param {Uint8Array} enc_key
* @returns {Uint8Array}
*/
export function saverDecompressEncryptionKey(enc_key: Uint8Array): Uint8Array;
/**
* Takes compressed decryption key and returns its uncompressed form
* @param {Uint8Array} dec_key
* @returns {Uint8Array}
*/
export function saverDecompressDecryptionKey(dec_key: Uint8Array): Uint8Array;
/**
* Takes a compressed proving key for SAVER's snark and return the uncompressed proving key
* @param {Uint8Array} snark_pk
* @returns {Uint8Array}
*/
export function saverDecompressSnarkPk(snark_pk: Uint8Array): Uint8Array;
/**
* Return the compressed or uncompressed SNARK verification key from compressed proving key
* @param {Uint8Array} snark_pk
* @param {boolean} return_uncompressed
* @returns {Uint8Array}
*/
export function saverGetSnarkVkFromPk(snark_pk: Uint8Array, return_uncompressed: boolean): Uint8Array;
/**
* Takes a compressed verifying key for SAVER's snark and return the uncompressed verifying key
* @param {Uint8Array} snark_vk
* @returns {Uint8Array}
*/
export function saverDecompressSnarkVk(snark_vk: Uint8Array): Uint8Array;
/**
* Decrypt the ciphertext using snark verification key. If `uncompressed_public_params` is true, it
* expects all relevant parameters in their uncompressed form else it expects them compressed.
* Returns the message and the commitment to the randomness
* @param {Uint8Array} ciphertext
* @param {Uint8Array} secret_key
* @param {Uint8Array} decryption_key
* @param {Uint8Array} snark_vk
* @param {number} chunk_bit_size
* @param {boolean} uncompressed_public_params
* @returns {Array<any>}
*/
export function saverDecryptCiphertextUsingSnarkVk(ciphertext: Uint8Array, secret_key: Uint8Array, decryption_key: Uint8Array, snark_vk: Uint8Array, chunk_bit_size: number, uncompressed_public_params: boolean): Array<any>;
/**
* Save as `saver_decrypt_ciphertext_using_snark_vk` but takes the snark proving key instead
* of verification key
* @param {Uint8Array} ciphertext
* @param {Uint8Array} secret_key
* @param {Uint8Array} decryption_key
* @param {Uint8Array} snark_pk
* @param {number} chunk_bit_size
* @param {boolean} uncompressed_public_params
* @returns {Array<any>}
*/
export function saverDecryptCiphertextUsingSnarkPk(ciphertext: Uint8Array, secret_key: Uint8Array, decryption_key: Uint8Array, snark_pk: Uint8Array, chunk_bit_size: number, uncompressed_public_params: boolean): Array<any>;
/**
* Verify that the ciphertext did actually decrypt to the given decrypted message. If
* `uncompressed_public_params` is true, it expects all relevant parameters in their uncompressed
* form else it expects them compressed.
* @param {Uint8Array} ciphertext
* @param {Uint8Array} decrypted_message
* @param {Uint8Array} nu
* @param {Uint8Array} decryption_key
* @param {Uint8Array} snark_vk
* @param {Uint8Array} enc_gens
* @param {number} chunk_bit_size
* @param {boolean} uncompressed_public_params
* @returns {any}
*/
export function saverVerifyDecryptionUsingSnarkVk(ciphertext: Uint8Array, decrypted_message: Uint8Array, nu: Uint8Array, decryption_key: Uint8Array, snark_vk: Uint8Array, enc_gens: Uint8Array, chunk_bit_size: number, uncompressed_public_params: boolean): any;
/**
* Same as `saver_verify_decryption_using_snark_vk` but takes the snark proving key instead
* of verification key
* @param {Uint8Array} ciphertext
* @param {Uint8Array} decrypted_message
* @param {Uint8Array} nu
* @param {Uint8Array} decryption_key
* @param {Uint8Array} snark_pk
* @param {Uint8Array} enc_gens
* @param {number} chunk_bit_size
* @param {boolean} uncompressed_public_params
* @returns {any}
*/
export function saverVerifyDecryptionUsingSnarkPk(ciphertext: Uint8Array, decrypted_message: Uint8Array, nu: Uint8Array, decryption_key: Uint8Array, snark_pk: Uint8Array, enc_gens: Uint8Array, chunk_bit_size: number, uncompressed_public_params: boolean): any;
/**
* @param {Uint8Array | undefined} seed
* @returns {Uint8Array}
*/
export function generateRandomG1Element(seed?: Uint8Array): Uint8Array;
/**
* @param {Uint8Array | undefined} seed
* @returns {Uint8Array}
*/
export function generateRandomG2Element(seed?: Uint8Array): Uint8Array;
/**
* @param {Uint8Array | undefined} seed
* @returns {Uint8Array}
*/
export function generateRandomFieldElement(seed?: Uint8Array): Uint8Array;
/**
* @param {number} number
* @returns {Uint8Array}
*/
export function generateFieldElementFromNumber(number: number): Uint8Array;
/**
* @param {Uint8Array} bytes
* @returns {Uint8Array}
*/
export function generateChallengeFromBytes(bytes: Uint8Array): Uint8Array;
/**
* Hashes given bytes to get the field element thus can accept arbitrary sized bytearray.
* @param {Uint8Array} bytes
* @returns {Uint8Array}
*/
export function generateFieldElementFromBytes(bytes: Uint8Array): Uint8Array;
/**
* @param {Uint8Array} element
* @param {boolean} element_is_secret
* @returns {Uint8Array}
*/
export function fieldElementAsBytes(element: Uint8Array, element_is_secret: boolean): Uint8Array;
/**
* Create a Pedersen commitment in group G1
* @param {Array<any>} bases
* @param {Array<any>} messages
* @returns {Uint8Array}
*/
export function pedersenCommitmentG1(bases: Array<any>, messages: Array<any>): Uint8Array;
/**
* Create a Pedersen commitment in group G2
* @param {Array<any>} bases
* @param {Array<any>} messages
* @returns {Uint8Array}
*/
export function pedersenCommitmentG2(bases: Array<any>, messages: Array<any>): Uint8Array;
/**
* @param {number} message_count
* @param {Uint8Array | undefined} label
* @returns {any}
*/
export function generateSignatureParamsG1(message_count: number, label?: Uint8Array): any;
/**
* @param {any} params
* @returns {boolean}
*/
export function isSignatureParamsG1Valid(params: any): boolean;
/**
* @param {any} params
* @returns {number}
*/
export function bbsSignatureParamsG1MaxSupportedMsgs(params: any): number;
/**
* @param {number} message_count
* @param {Uint8Array | undefined} label
* @returns {any}
*/
export function generateSignatureParamsG2(message_count: number, label?: Uint8Array): any;
/**
* @param {any} params
* @returns {boolean}
*/
export function isSignatureParamsG2Valid(params: any): boolean;
/**
* @param {any} params
* @returns {number}
*/
export function bbsSignatureParamsG2MaxSupportedMsgs(params: any): number;
/**
* @param {any} params
* @returns {Uint8Array}
*/
export function bbsSignatureParamsG1ToBytes(params: any): Uint8Array;
/**
* @param {Uint8Array} bytes
* @returns {any}
*/
export function bbsSignatureParamsG1FromBytes(bytes: Uint8Array): any;
/**
* @param {any} params
* @returns {Uint8Array}
*/
export function bbsSignatureParamsG2ToBytes(params: any): Uint8Array;
/**
* @param {Uint8Array} bytes
* @returns {any}
*/
export function bbsSignatureParamsG2FromBytes(bytes: Uint8Array): any;
/**
* @param {Uint8Array | undefined} seed
* @returns {Uint8Array}
*/
export function generateBBSSigningKey(seed?: Uint8Array): Uint8Array;
/**
* @param {Uint8Array} secret_key
* @param {any} params
* @returns {Uint8Array}
*/
export function generateBBSPublicKeyG1(secret_key: Uint8Array, params: any): Uint8Array;
/**
* @param {Uint8Array} public_key
* @returns {boolean}
*/
export function isBBSPublicKeyG1Valid(public_key: Uint8Array): boolean;
/**
* @param {Uint8Array} secret_key
* @param {any} params
* @returns {Uint8Array}
*/
export function generateBBSPublicKeyG2(secret_key: Uint8Array, params: any): Uint8Array;
/**
* @param {Uint8Array} public_key
* @returns {boolean}
*/
export function isBBSPublicKeyG2Valid(public_key: Uint8Array): boolean;
/**
* @param {any} params
* @param {Uint8Array | undefined} seed
* @returns {any}
*/
export function generateBBSKeyPairG1(params: any, seed?: Uint8Array): any;
/**
* @param {any} params
* @param {Uint8Array | undefined} seed
* @returns {any}
*/
export function generateBBSKeyPairG2(params: any, seed?: Uint8Array): any;
/**
* @param {any} params
* @param {Array<any>} indices_to_commit
* @returns {Array<any>}
*/
export function bbsGetBasesForCommitmentG1(params: any, indices_to_commit: Array<any>): Array<any>;
/**
* @param {any} params
* @param {Array<any>} indices_to_commit
* @returns {Array<any>}
*/
export function bbsGetBasesForCommitmentG2(params: any, indices_to_commit: Array<any>): Array<any>;
/**
* @param {Uint8Array} message
* @returns {Uint8Array}
*/
export function bbsEncodeMessageForSigning(message: Uint8Array): Uint8Array;
/**
* @param {Array<any>} messages
* @param {Array<any>} indices_to_encode
* @returns {Array<any>}
*/
export function bbsEncodeMessagesForSigning(messages: Array<any>, indices_to_encode: Array<any>): Array<any>;
/**
* @param {Map<any, any>} messages_to_commit
* @param {Uint8Array} blinding
* @param {any} params
* @param {boolean} encode_messages
* @returns {Uint8Array}
*/
export function bbsCommitMsgsInG1(messages_to_commit: Map<any, any>, blinding: Uint8Array, params: any, encode_messages: boolean): Uint8Array;
/**
* @param {Map<any, any>} messages_to_commit
* @param {Uint8Array} blinding
* @param {any} params
* @param {boolean} encode_messages
* @returns {Uint8Array}
*/
export function bbsCommitMsgsInG2(messages_to_commit: Map<any, any>, blinding: Uint8Array, params: any, encode_messages: boolean): Uint8Array;
/**
* @param {Array<any>} messages
* @param {Uint8Array} secret_key
* @param {any} params
* @param {boolean} encode_messages
* @returns {Uint8Array}
*/
export function bbsSignG1(messages: Array<any>, secret_key: Uint8Array, params: any, encode_messages: boolean): Uint8Array;
/**
* @param {Uint8Array} commitment
* @param {Map<any, any>} uncommitted_messages
* @param {Uint8Array} secret_key
* @param {any} params
* @param {boolean} encode_messages
* @returns {Uint8Array}
*/
export function bbsBlindSignG1(commitment: Uint8Array, uncommitted_messages: Map<any, any>, secret_key: Uint8Array, params: any, encode_messages: boolean): Uint8Array;
/**
* @param {Uint8Array} blind_signature
* @param {Uint8Array} blinding
* @returns {Uint8Array}
*/
export function bbsUnblindSigG1(blind_signature: Uint8Array, blinding: Uint8Array): Uint8Array;
/**
* @param {Array<any>} messages
* @param {Uint8Array} signature
* @param {Uint8Array} public_key
* @param {any} params
* @param {boolean} encode_messages
* @returns {any}
*/
export function bbsVerifyG1(messages: Array<any>, signature: Uint8Array, public_key: Uint8Array, params: any, encode_messages: boolean): any;
/**
* @param {Array<any>} messages
* @param {Uint8Array} secret_key
* @param {any} params
* @param {boolean} encode_messages
* @returns {Uint8Array}
*/
export function bbsSignG2(messages: Array<any>, secret_key: Uint8Array, params: any, encode_messages: boolean): Uint8Array;
/**
* @param {Uint8Array} commitment
* @param {Map<any, any>} uncommitted_messages
* @param {Uint8Array} secret_key
* @param {any} params
* @param {boolean} encode_messages
* @returns {Uint8Array}
*/
export function bbsBlindSignG2(commitment: Uint8Array, uncommitted_messages: Map<any, any>, secret_key: Uint8Array, params: any, encode_messages: boolean): Uint8Array;
/**
* @param {Uint8Array} blind_signature
* @param {Uint8Array} blinding
* @returns {Uint8Array}
*/
export function bbsUnblindSigG2(blind_signature: Uint8Array, blinding: Uint8Array): Uint8Array;
/**
* @param {Array<any>} messages
* @param {Uint8Array} signature
* @param {Uint8Array} public_key
* @param {any} params
* @param {boolean} encode_messages
* @returns {any}
*/
export function bbsVerifyG2(messages: Array<any>, signature: Uint8Array, public_key: Uint8Array, params: any, encode_messages: boolean): any;
/**
* @param {Uint8Array} signature
* @param {any} params
* @param {Array<any>} messages
* @param {Map<any, any>} blindings
* @param {Set<any>} revealed_indices
* @param {boolean} encode_messages
* @returns {any}
*/
export function bbsInitializeProofOfKnowledgeOfSignature(signature: Uint8Array, params: any, messages: Array<any>, blindings: Map<any, any>, revealed_indices: Set<any>, encode_messages: boolean): any;
/**
* @param {any} protocol
* @param {Uint8Array} challenge
* @returns {Uint8Array}
*/
export function bbsGenProofOfKnowledgeOfSignature(protocol: any, challenge: Uint8Array): Uint8Array;
/**
* @param {Uint8Array} proof
* @param {Map<any, any>} revealed_msgs
* @param {Uint8Array} challenge
* @param {Uint8Array} public_key
* @param {any} params
* @param {boolean} encode_messages
* @returns {any}
*/
export function bbsVerifyProofOfKnowledgeOfSignature(proof: Uint8Array, revealed_msgs: Map<any, any>, challenge: Uint8Array, public_key: Uint8Array, params: any, encode_messages: boolean): any;
/**
* @param {any} protocol
* @param {Map<any, any>} revealed_msgs
* @param {any} params
* @param {boolean} encode_messages
* @returns {Uint8Array}
*/
export function bbsChallengeContributionFromProtocol(protocol: any, revealed_msgs: Map<any, any>, params: any, encode_messages: boolean): Uint8Array;
/**
* @param {Uint8Array} proof
* @param {Map<any, any>} revealed_msgs
* @param {any} params
* @param {boolean} encode_messages
* @returns {Uint8Array}
*/
export function bbsChallengeContributionFromProof(proof: Uint8Array, revealed_msgs: Map<any, any>, params: any, encode_messages: boolean): Uint8Array;
/**
* @param {any} params
* @param {Uint8Array} generating_label
* @param {number} new_count
* @returns {any}
*/
export function bbsAdaptSigParamsG1ForMsgCount(params: any, generating_label: Uint8Array, new_count: number): any;
/**
* @param {any} params
* @param {Uint8Array} generating_label
* @param {number} new_count
* @returns {any}
*/
export function bbsAdaptSigParamsG2ForMsgCount(params: any, generating_label: Uint8Array, new_count: number): any;
/**
* @param {Uint8Array} signature
* @param {Map<any, any>} unrevealed_msgs
* @param {boolean} encode_messages
* @returns {any}
*/
export function generatePoKBBSSignatureWitness(signature: Uint8Array, unrevealed_msgs: Map<any, any>, encode_messages: boolean): any;
/**
* @param {Uint8Array} element
* @param {any} accum_witness
* @returns {any}
*/
export function generateAccumulatorMembershipWitness(element: Uint8Array, accum_witness: any): any;
/**
* @param {Uint8Array} element
* @param {any} accum_witness
* @returns {any}
*/
export function generateAccumulatorNonMembershipWitness(element: Uint8Array, accum_witness: any): any;
/**
* @param {Array<any>} elements
* @returns {any}
*/
export function generatePedersenCommitmentWitness(elements: Array<any>): any;
/**
* @param {Array<any>} statements
* @param {Array<any>} meta_statements
* @param {Array<any>} setup_params
* @param {Uint8Array | undefined} context
* @returns {Uint8Array}
*/
export function generateProofSpecG1(statements: Array<any>, meta_statements: Array<any>, setup_params: Array<any>, context?: Uint8Array): Uint8Array;
/**
* @param {Uint8Array} proof_spec
* @returns {boolean}
*/
export function isProofSpecG1Valid(proof_spec: Uint8Array): boolean;
/**
* @param {Array<any>} statements
* @param {Array<any>} meta_statements
* @param {Array<any>} setup_params
* @param {Uint8Array | undefined} context
* @returns {Uint8Array}
*/
export function generateProofSpecG2(statements: Array<any>, meta_statements: Array<any>, setup_params: Array<any>, context?: Uint8Array): Uint8Array;
/**
* @param {Uint8Array} proof_spec
* @returns {boolean}
*/
export function isProofSpecG2Valid(proof_spec: Uint8Array): boolean;
/**
* @param {Uint8Array} proof_spec
* @param {Array<any>} witnesses
* @param {Uint8Array | undefined} nonce
* @returns {Uint8Array}
*/
export function generateCompositeProofG1(proof_spec: Uint8Array, witnesses: Array<any>, nonce?: Uint8Array): Uint8Array;
/**
* @param {Uint8Array} proof_spec
* @param {Array<any>} witnesses
* @param {Uint8Array | undefined} nonce
* @returns {Uint8Array}
*/
export function generateCompositeProofG2(proof_spec: Uint8Array, witnesses: Array<any>, nonce?: Uint8Array): Uint8Array;
/**
* Same as `generate_composite_proof_g1` but takes the statements, meta-statements, setup params, context and nonce
* separately rather than in a `ProofSpec`. Use this to save the serialization and deserialization cost of
* creating a `ProofSpec`.
* @param {Array<any>} statements
* @param {Array<any>} meta_statements
* @param {Array<any>} setup_params
* @param {Array<any>} witnesses
* @param {Uint8Array | undefined} context
* @param {Uint8Array | undefined} nonce
* @returns {Uint8Array}
*/
export function generateCompositeProofG1WithDeconstructedProofSpec(statements: Array<any>, meta_statements: Array<any>, setup_params: Array<any>, witnesses: Array<any>, context?: Uint8Array, nonce?: Uint8Array): Uint8Array;
/**
* @param {Uint8Array} proof
* @param {Uint8Array} proof_spec
* @param {Uint8Array | undefined} nonce
* @returns {any}
*/
export function verifyCompositeProofG1(proof: Uint8Array, proof_spec: Uint8Array, nonce?: Uint8Array): any;
/**
* @param {Uint8Array} proof
* @param {Uint8Array} proof_spec
* @param {Uint8Array | undefined} nonce
* @returns {any}
*/
export function verifyCompositeProofG2(proof: Uint8Array, proof_spec: Uint8Array, nonce?: Uint8Array): any;
/**
* Same as `verify_composite_proof_g1` but takes the statements, meta-statements, setup params, context and nonce
* separately rather than in a `ProofSpec`. Use this to save the serialization and deserialization cost of
* creating a `ProofSpec`.
* @param {Uint8Array} proof
* @param {Array<any>} statements
* @param {Array<any>} meta_statements
* @param {Array<any>} setup_params
* @param {Uint8Array | undefined} context
* @param {Uint8Array | undefined} nonce
* @returns {any}
*/
export function verifyCompositeProofG1WithDeconstructedProofSpec(proof: Uint8Array, statements: Array<any>, meta_statements: Array<any>, setup_params: Array<any>, context?: Uint8Array, nonce?: Uint8Array): any;
/**
* @param {Uint8Array} message
* @returns {any}
*/
export function generateSaverWitness(message: Uint8Array): any;
/**
* From the composite proof, get the ciphertext for the statement at index `statement_index`
* @param {Uint8Array} proof
* @param {number} statement_index
* @returns {Uint8Array}
*/
export function saverGetCiphertextFromProof(proof: Uint8Array, statement_index: number): Uint8Array;
/**
* From the composite proof, get the ciphertext for the statement indices `statement_indices`
* @param {Uint8Array} proof
* @param {Uint32Array} statement_indices
* @returns {Array<any>}
*/
export function saverGetCiphertextsFromProof(proof: Uint8Array, statement_indices: Uint32Array): Array<any>;
/**
* @param {Uint8Array} message
* @returns {any}
*/
export function generateBoundCheckWitness(message: Uint8Array): any;
/**
* @param {Map<any, any>} input_wires
* @param {Array<any>} privates
* @param {Array<any>} publics
* @returns {any}
*/
export function generateR1CSCircomWitness(input_wires: Map<any, any>, privates: Array<any>, publics: Array<any>): any;
/**
* Takes a compressed proving key for Legosnark and return the uncompressed proving key
* @param {Uint8Array} snark_pk
* @returns {Uint8Array}
*/
export function legosnarkDecompressPk(snark_pk: Uint8Array): Uint8Array;
/**
* Return the compressed or uncompressed SNARK verification key from compressed proving key
* @param {Uint8Array} snark_pk
* @param {boolean} return_uncompressed
* @returns {Uint8Array}
*/
export function legosnarkVkFromPk(snark_pk: Uint8Array, return_uncompressed: boolean): Uint8Array;
/**
* Takes a compressed verifying key for Legosnark and return the uncompressed verifying key
* @param {Uint8Array} snark_vk
* @returns {Uint8Array}
*/
export function legosnarkDecompressVk(snark_vk: Uint8Array): Uint8Array;
/**
* Generate accumulator parameters. They are needed to generate public key and initialize the accumulator.
* Pass the `label` argument to generate parameters deterministically.
* @param {Uint8Array | undefined} label
* @returns {Uint8Array}
*/
export function generateAccumulatorParams(label?: Uint8Array): Uint8Array;
/**
* Check if parameters are valid. Before verifying witness or using for proof verification,
* make sure the params are valid.
* @param {Uint8Array} params
* @returns {boolean}
*/
export function isAccumulatorParamsValid(params: Uint8Array): boolean;
/**
* Generate secret key for the accumulator manager who updates the accumulator and creates witnesses.
* Pass the `seed` argument to generate key deterministically.
* @param {Uint8Array | undefined} seed
* @returns {any}
*/
export function generateAccumulatorSecretKey(seed?: Uint8Array): any;
/**
* Generate public key from given params and secret key.
* @param {any} secret_key
* @param {Uint8Array} params
* @returns {Uint8Array}
*/
export function generateAccumulatorPublicKey(secret_key: any, params: Uint8Array): Uint8Array;
/**
* Check if public key is valid. Before verifying witness or using for proof verification,
* make sure the public key is valid.
* @param {Uint8Array} public_key
* @returns {boolean}
*/
export function isAccumulatorPublicKeyValid(public_key: Uint8Array): boolean;
/**
* Generate private and public key from given params and optional `seed`.
* Pass the `seed` argument to generate keys deterministically.
* @param {Uint8Array} params
* @param {Uint8Array | undefined} seed
* @returns {any}
*/
export function generateAccumulatorKeyPair(params: Uint8Array, seed?: Uint8Array): any;
/**
* To add arbitrary bytes as an accumulator member, they should be first converted to
* a field element. This function will prefix the given bytes with a constant string as
* domain separator and then generate a field element using IETF standard.
* @param {Uint8Array} bytes
* @returns {any}
*/
export function accumulatorGetElementFromBytes(bytes: Uint8Array): any;
/**
* Initialize a positive accumulator
* @param {Uint8Array} params
* @returns {any}
*/
export function positiveAccumulatorInitialize(params: Uint8Array): any;
/**
* Get the accumulated value from given positive accumulator
* @param {any} accum
* @returns {Uint8Array}
*/
export function positiveAccumulatorGetAccumulated(accum: any): Uint8Array;
/**
* @param {any} existing_accum
* @param {Uint8Array} element
* @param {any} secret_key
* @returns {any}
*/
export function positiveAccumulatorAdd(existing_accum: any, element: Uint8Array, secret_key: any): any;
/**
* @param {any} existing_accum
* @param {Uint8Array} element
* @param {any} secret_key
* @returns {any}
*/
export function positiveAccumulatorRemove(existing_accum: any, element: Uint8Array, secret_key: any): any;
/**
* @param {any} accum
* @param {Uint8Array} element
* @param {any} secret_key
* @returns {any}
*/
export function positiveAccumulatorMembershipWitness(accum: any, element: Uint8Array, secret_key: any): any;
/**
* @param {Uint8Array} accumulated
* @param {Uint8Array} element
* @param {any} witness
* @param {Uint8Array} public_key
* @param {Uint8Array} params
* @returns {boolean}
*/
export function positiveAccumulatorVerifyMembership(accumulated: Uint8Array, element: Uint8Array, witness: any, public_key: Uint8Array, params: Uint8Array): boolean;
/**
* Creates the initial elements that depend on the order of the curve and thus can be considered fixed.
* This function generates them for the BLS12-381 curve *only*.
* @returns {Array<any>}
*/
export function universalAccumulatorFixedInitialElements(): Array<any>;
/**
* @param {Array<any>} initial_elements
* @param {any} secret_key
* @returns {Uint8Array}
*/
export function universalAccumulatorComputeInitialFv(initial_elements: Array<any>, secret_key: any): Uint8Array;
/**
* @param {Array<any>} initial_f_vs
* @returns {Uint8Array}
*/
export function universalAccumulatorCombineMultipleInitialFv(initial_f_vs: Array<any>): Uint8Array;
/**
* @param {Uint8Array} f_v
* @param {Uint8Array} params
* @param {number} max_size
* @returns {any}
*/
export function universalAccumulatorInitialiseGivenFv(f_v: Uint8Array, params: Uint8Array, max_size: number): any;
/**
* @param {any} accum
* @returns {Uint8Array}
*/
export function universalAccumulatorGetAccumulated(accum: any): Uint8Array;
/**
* @param {any} existing_accum
* @param {Uint8Array} element
* @param {any} secret_key
* @returns {any}
*/
export function universalAccumulatorAdd(existing_accum: any, element: Uint8Array, secret_key: any): any;
/**
* @param {any} existing_accum
* @param {Uint8Array} element
* @param {any} secret_key
* @returns {any}
*/
export function universalAccumulatorRemove(existing_accum: any, element: Uint8Array, secret_key: any): any;
/**
* @param {any} accum
* @param {Uint8Array} element
* @param {any} secret_key
* @returns {any}
*/
export function universalAccumulatorMembershipWitness(accum: any, element: Uint8Array, secret_key: any): any;
/**
* @param {Uint8Array} accumulated
* @param {Uint8Array} member
* @param {any} witness
* @param {Uint8Array} public_key
* @param {Uint8Array} params
* @returns {boolean}
*/
export function universalAccumulatorVerifyMembership(accumulated: Uint8Array, member: Uint8Array, witness: any, public_key: Uint8Array, params: Uint8Array): boolean;
/**
* @param {Uint8Array} non_member
* @param {Array<any>} members
* @returns {Uint8Array}
*/
export function universalAccumulatorComputeD(non_member: Uint8Array, members: Array<any>): Uint8Array;
/**
* @param {Array<any>} ds
* @returns {Uint8Array}
*/
export function universalAccumulatorCombineMultipleD(ds: Array<any>): Uint8Array;
/**
* @param {any} accum
* @param {Uint8Array} d
* @param {Uint8Array} non_member
* @param {any} secret_key
* @param {Uint8Array} params
* @returns {any}
*/
export function universalAccumulatorNonMembershipWitness(accum: any, d: Uint8Array, non_member: Uint8Array, secret_key: any, params: Uint8Array): any;
/**
* @param {Uint8Array} accumulated
* @param {Uint8Array} non_member
* @param {any} witness
* @param {Uint8Array} public_key
* @param {Uint8Array} params
* @returns {boolean}
*/
export function universalAccumulatorVerifyNonMembership(accumulated: Uint8Array, non_member: Uint8Array, witness: any, public_key: Uint8Array, params: Uint8Array): boolean;
/**
* @param {any} existing_accum
* @param {Array<any>} elements
* @param {any} secret_key
* @returns {any}
*/
export function positiveAccumulatorAddBatch(existing_accum: any, elements: Array<any>, secret_key: any): any;
/**
* @param {any} existing_accum
* @param {Array<any>} elements
* @param {any} secret_key
* @returns {any}
*/
export function positiveAccumulatorRemoveBatch(existing_accum: any, elements: Array<any>, secret_key: any): any;
/**
* @param {any} existing_accum
* @param {Array<any>} additions
* @param {Array<any>} removals
* @param {any} secret_key
* @returns {any}
*/
export function positiveAccumulatorBatchUpdates(existing_accum: any, additions: Array<any>, removals: Array<any>, secret_key: any): any;
/**
* @param {any} accum
* @param {Array<any>} elements
* @param {any} secret_key
* @returns {Array<any>}
*/
export function positiveAccumulatorMembershipWitnessesForBatch(accum: any, elements: Array<any>, secret_key: any): Array<any>;
/**
* @param {any} existing_accum
* @param {Array<any>} elements
* @param {any} secret_key
* @returns {any}
*/
export function universalAccumulatorAddBatch(existing_accum: any, elements: Array<any>, secret_key: any): any;
/**
* @param {any} existing_accum
* @param {Array<any>} elements
* @param {any} secret_key
* @returns {any}
*/
export function universalAccumulatorRemoveBatch(existing_accum: any, elements: Array<any>, secret_key: any): any;
/**
* @param {any} existing_accum
* @param {Array<any>} additions
* @param {Array<any>} removals
* @param {any} secret_key
* @returns {any}
*/
export function universalAccumulatorBatchUpdates(existing_accum: any, additions: Array<any>, removals: Array<any>, secret_key: any): any;
/**
* @param {any} accum
* @param {Array<any>} elements
* @param {any} secret_key
* @returns {Array<any>}
*/
export function universalAccumulatorMembershipWitnessesForBatch(accum: any, elements: Array<any>, secret_key: any): Array<any>;
/**
* @param {Array<any>} non_members
* @param {Array<any>} members
* @returns {Array<any>}
*/
export function universalAccumulatorComputeDForBatch(non_members: Array<any>, members: Array<any>): Array<any>;
/**
* @param {Array<any>} ds
* @returns {Array<any>}
*/
export function universalAccumulatorCombineMultipleDForBatch(ds: Array<any>): Array<any>;
/**
* @param {any} accum
* @param {Array<any>} d
* @param {Array<any>} non_members
* @param {any} secret_key
* @param {Uint8Array} params
* @returns {Array<any>}
*/
export function universalAccumulatorNonMembershipWitnessesForBatch(accum: any, d: Array<any>, non_members: Array<any>, secret_key: any, params: Uint8Array): Array<any>;
/**
* @param {any} witness
* @param {Uint8Array} member
* @param {Uint8Array} addition
* @param {Uint8Array} old_accumulated
* @returns {any}
*/
export function updateMembershipWitnessPostAdd(witness: any, member: Uint8Array, addition: Uint8Array, old_accumulated: Uint8Array): any;
/**
* @param {any} witness
* @param {Uint8Array} member
* @param {Uint8Array} removal
* @param {Uint8Array} new_accumulated
* @returns {any}
*/
export function updateMembershipWitnessPostRemove(witness: any, member: Uint8Array, removal: Uint8Array, new_accumulated: Uint8Array): any;
/**
* @param {any} witness
* @param {Uint8Array} non_member
* @param {Uint8Array} addition
* @param {Uint8Array} old_accumulated
* @returns {any}
*/
export function updateNonMembershipWitnessPostAdd(witness: any, non_member: Uint8Array, addition: Uint8Array, old_accumulated: Uint8Array): any;
/**
* @param {any} witness
* @param {Uint8Array} non_member
* @param {Uint8Array} removal
* @param {Uint8Array} new_accumulated
* @returns {any}
*/
export function updateNonMembershipWitnessPostRemove(witness: any, non_member: Uint8Array, removal: Uint8Array, new_accumulated: Uint8Array): any;
/**
* @param {Array<any>} witnesses
* @param {Array<any>} members
* @param {Array<any>} additions
* @param {Array<any>} removals
* @param {Uint8Array} old_accumulated
* @param {any} secret_key
* @returns {Array<any>}
*/
export function updateMembershipWitnessesPostBatchUpdates(witnesses: Array<any>, members: Array<any>, additions: Array<any>, removals: Array<any>, old_accumulated: Uint8Array, secret_key: any): Array<any>;
/**
* @param {Array<any>} witnesses
* @param {Array<any>} non_members
* @param {Array<any>} additions
* @param {Array<any>} removals
* @param {Uint8Array} old_accumulated
* @param {any} secret_key
* @returns {Array<any>}
*/
export function updateNonMembershipWitnessesPostBatchUpdates(witnesses: Array<any>, non_members: Array<any>, additions: Array<any>, removals: Array<any>, old_accumulated: Uint8Array, secret_key: any): Array<any>;
/**
* @param {Uint8Array} old_accumulated
* @param {Array<any>} additions
* @param {Array<any>} removals
* @param {any} secret_key
* @returns {Uint8Array}
*/
export function publicInfoForWitnessUpdate(old_accumulated: Uint8Array, additions: Array<any>, removals: Array<any>, secret_key: any): Uint8Array;
/**
* @param {any} witness
* @param {Uint8Array} member
* @param {Array<any>} additions
* @param {Array<any>} removals
* @param {Uint8Array} public_info
* @returns {any}
*/
export function updateMembershipWitnessUsingPublicInfoAfterBatchUpdate(witness: any, member: Uint8Array, additions: Array<any>, removals: Array<any>, public_info: Uint8Array): any;
/**
* @param {any} witness
* @param {Uint8Array} member
* @param {Array<any>} additions
* @param {Array<any>} removals
* @param {Array<any>} public_info
* @returns {any}
*/
export function updateMembershipWitnessUsingPublicInfoAfterMultipleBatchUpdates(witness: any, member: Uint8Array, additions: Array<any>, removals: Array<any>, public_info: Array<any>): any;
/**
* @param {any} witness
* @param {Uint8Array} non_member
* @param {Array<any>} additions
* @param {Array<any>} removals
* @param {Uint8Array} public_info
* @returns {any}
*/
export function updateNonMembershipWitnessUsingPublicInfoAfterBatchUpdate(witness: any, non_member: Uint8Array, additions: Array<any>, removals: Array<any>, public_info: Uint8Array): any;
/**
* @param {any} witness
* @param {Uint8Array} non_member
* @param {Array<any>} additions
* @param {Array<any>} removals
* @param {Array<any>} public_info
* @returns {any}
*/
export function updateNonMembershipWitnessUsingPublicInfoAfterMultipleBatchUpdates(witness: any, non_member: Uint8Array, additions: Array<any>, removals: Array<any>, public_info: Array<any>): any;
/**
* @param {Uint8Array | undefined} label
* @returns {Uint8Array}
*/
export function generateMembershipProvingKey(label?: Uint8Array): Uint8Array;
/**
* @param {Uint8Array | undefined} label
* @returns {Uint8Array}
*/
export function generateNonMembershipProvingKey(label?: Uint8Array): Uint8Array;
/**
* @param {Uint8Array} proving_key
* @returns {Uint8Array}
*/
export function accumulatorDeriveMembershipProvingKeyFromNonMembershipKey(proving_key: Uint8Array): Uint8Array;
/**
* @param {Uint8Array} member
* @param {Uint8Array} blinding
* @param {any} witness
* @param {Uint8Array} public_key
* @param {Uint8Array} params
* @param {Uint8Array} proving_key
* @returns {any}
*/
export function accumulatorInitializeMembershipProof(member: Uint8Array, blinding: Uint8Array, witness: any, public_key: Uint8Array, params: Uint8Array, proving_key: Uint8Array): any;
/**
* @param {any} protocol
* @param {Uint8Array} challenge
* @returns {any}
*/
export function accumulatorGenMembershipProof(protocol: any, challenge: Uint8Array): any;
/**
* @param {any} proof
* @param {Uint8Array} accumulated
* @param {Uint8Array} challenge
* @param {Uint8Array} public_key
* @param {Uint8Array} params
* @param {Uint8Array} proving_key
* @returns {any}
*/
export function accumulatorVerifyMembershipProof(proof: any, accumulated: Uint8Array, challenge: Uint8Array, public_key: Uint8Array, params: Uint8Array, proving_key: Uint8Array): any;
/**
* @param {any} protocol
* @param {Uint8Array} accumulated
* @param {Uint8Array} public_key
* @param {Uint8Array} params
* @param {Uint8Array} proving_key
* @returns {Uint8Array}
*/
export function accumulatorChallengeContributionFromMembershipProtocol(protocol: any, accumulated: Uint8Array, public_key: Uint8Array, params: Uint8Array, proving_key: Uint8Array): Uint8Array;
/**
* @param {any} proof
* @param {Uint8Array} accumulated
* @param {Uint8Array} public_key
* @param {Uint8Array} params
* @param {Uint8Array} proving_key
* @returns {Uint8Array}
*/
export function accumulatorChallengeContributionFromMembershipProof(proof: any, accumulated: Uint8Array, public_key: Uint8Array, params: Uint8Array, proving_key: Uint8Array): Uint8Array;
/**
* @param {Uint8Array} non_member
* @param {Uint8Array} blinding
* @param {any} witness
* @param {Uint8Array} public_key
* @param {Uint8Array} params
* @param {Uint8Array} proving_key
* @returns {any}
*/
export function accumulatorInitializeNonMembershipProof(non_member: Uint8Array, blinding: Uint8Array, witness: any, public_key: Uint8Array, params: Uint8Array, proving_key: Uint8Array): any;
/**
* @param {any} protocol
* @param {Uint8Array} challenge
* @returns {any}
*/
export function accumulatorGenNonMembershipProof(protocol: any, challenge: Uint8Array): any;
/**
* @param {any} proof
* @param {Uint8Array} accumulated
* @param {Uint8Array} challenge
* @param {Uint8Array} public_key
* @param {Uint8Array} params
* @param {Uint8Array} proving_key
* @returns {any}
*/
export function accumulatorVerifyNonMembershipProof(proof: any, accumulated: Uint8Array, challenge: Uint8Array, public_key: Uint8Array, params: Uint8Array, proving_key: Uint8Array): any;
/**
* @param {any} protocol
* @param {Uint8Array} accumulated
* @param {Uint8Array} public_key
* @param {Uint8Array} params
* @param {Uint8Array} proving_key
* @returns {Uint8Array}
*/
export function accumulatorChallengeContributionFromNonMembershipProtocol(protocol: any, accumulated: Uint8Array, public_key: Uint8Array, params: Uint8Array, proving_key: Uint8Array): Uint8Array;
/**
* @param {any} proof
* @param {Uint8Array} accumulated
* @param {Uint8Array} public_key
* @param {Uint8Array} params
* @param {Uint8Array} proving_key
* @returns {Uint8Array}
*/
export function accumulatorChallengeContributionFromNonMembershipProof(proof: any, accumulated: Uint8Array, public_key: Uint8Array, params: Uint8Array, proving_key: Uint8Array): Uint8Array;
/**
* @param {any} params
* @returns {Uint8Array}
*/
export function generateSetupParamForBBSSignatureParametersG1(params: any): Uint8Array;
/**
* @param {Uint8Array} public_key
* @returns {Uint8Array}
*/
export function generateSetupParamForBBSPublicKeyG2(public_key: Uint8Array): Uint8Array;
/**
* @param {Uint8Array} params
* @returns {Uint8Array}
*/
export function generateSetupParamForVbAccumulatorParams(params: Uint8Array): Uint8Array;
/**
* @param {Uint8Array} public_key
* @returns {Uint8Array}
*/
export function generateSetupParamForVbAccumulatorPublicKey(public_key: Uint8Array): Uint8Array;
/**
* @param {Uint8Array} key
* @returns {Uint8Array}
*/
export function generateSetupParamForVbAccumulatorMemProvingKey(key: Uint8Array): Uint8Array;
/**
* @param {Uint8Array} key
* @returns {Uint8Array}
*/
export function generateSetupParamForVbAccumulatorNonMemProvingKey(key: Uint8Array): Uint8Array;
/**
* @param {Array<any>} commitment_key
* @returns {Uint8Array}
*/
export function generateSetupParamForPedersenCommitmentKeyG1(commitment_key: Array<any>): Uint8Array;
/**
* @param {Array<any>} commitment_key
* @returns {Uint8Array}
*/
export function generateSetupParamForPedersenCommitmentKeyG2(commitment_key: Array<any>): Uint8Array;
/**
* If `uncompressed` is true, expects the encryption generators to be in uncompressed form else
* they should be compressed.
* @param {Uint8Array} enc_gens
* @param {boolean} uncompressed
* @returns {Uint8Array}
*/
export function generateSetupParamForSaverEncryptionGens(enc_gens: Uint8Array, uncompressed: boolean): Uint8Array;
/**
* If `uncompressed` is true, expects the commitment generators to be in uncompressed form else
* they should be compressed.
* @param {Uint8Array} comm_gens
* @param {boolean} uncompressed
* @returns {Uint8Array}
*/
export function generateSetupParamForSaverCommitmentGens(comm_gens: Uint8Array, uncompressed: boolean): Uint8Array;
/**
* If `uncompressed` is true, expects the encryption key to be in uncompressed form else
* it should be compressed.
* @param {Uint8Array} key
* @param {boolean} uncompressed
* @returns {Uint8Array}
*/
export function generateSetupParamForSaverEncryptionKey(key: Uint8Array, uncompressed: boolean): Uint8Array;
/**
* If `uncompressed` is true, expects the snark proving key to be in uncompressed form else
* it should be compressed.
* @param {Uint8Array} key
* @param {boolean} uncompressed
* @returns {Uint8Array}
*/
export function generateSetupParamForSaverProvingKey(key: Uint8Array, uncompressed: boolean): Uint8Array;
/**
* If `uncompressed` is true, expects the snark verifying key to be in uncompressed form else
* it should be compressed.
* @param {Uint8Array} key
* @param {boolean} uncompressed
* @returns {Uint8Array}
*/
export function generateSetupParamForSaverVerifyingKey(key: Uint8Array, uncompressed: boolean): Uint8Array;
/**
* If `uncompressed` is true, expects the legosnark proving key to be in uncompressed form else
* it should be compressed.
* @param {Uint8Array} key
* @param {boolean} uncompressed
* @returns {Uint8Array}
*/
export function generateSetupParamForLegoProvingKey(key: Uint8Array, uncompressed: boolean): Uint8Array;
/**
* If `uncompressed` is true, expects the legosnark verifying key to be in uncompressed form else
* it should be compressed.
* @param {Uint8Array} key
* @param {boolean} uncompressed
* @returns {Uint8Array}
*/
export function generateSetupParamForLegoVerifyingKey(key: Uint8Array, uncompressed: boolean): Uint8Array;
/**
* @param {string} curve_name
* @param {number} num_public
* @param {number} num_private
* @param {Array<any>} constraints
* @returns {Uint8Array}
*/
export function generateSetupParamForR1CS(curve_name: string, num_public: number, num_private: number, constraints: Array<any>): Uint8Array;
/**
* @param {Uint8Array} bytes
* @returns {Uint8Array}
*/
export function generateSetupParamForBytes(bytes: Uint8Array): Uint8Array;
/**
* @param {Array<any>} arr
* @returns {Uint8Array}
*/
export function generateSetupParamForFieldElemVec(arr: Array<any>): Uint8Array;
/**
* Setup snark and generate compressed or uncompressed SNARK proving key
* @param {boolean} return_uncompressed
* @returns {Uint8Array}
*/
export function boundCheckSnarkSetup(return_uncompressed: boolean): Uint8Array;
/**
* @param {any} params
* @param {Uint8Array} public_key
* @param {Map<any, any>} revealed_msgs
* @param {boolean} encode_messages
* @returns {Uint8Array}
*/
export function generatePoKBBSSignatureStatement(params: any, public_key: Uint8Array, revealed_msgs: Map<any, any>, encode_messages: boolean): Uint8Array;
/**
* @param {number} params
* @param {number} public_key
* @param {Map<any, any>} revealed_msgs
* @param {boolean} encode_messages
* @returns {Uint8Array}
*/
export function generatePoKBBSSignatureStatementFromParamRefs(params: number, public_key: number, revealed_msgs: Map<any, any>, encode_messages: boolean): Uint8Array;
/**
* @param {Uint8Array} params
* @param {Uint8Array} public_key
* @param {Uint8Array} proving_key
* @param {Uint8Array} accumulated
* @returns {Uint8Array}
*/
export function generateAccumulatorMembershipStatement(params: Uint8Array, public_key: Uint8Array, proving_key: Uint8Array, accumulated: Uint8Array): Uint8Array;
/**
* @param {number} params
* @param {number} public_key
* @param {number} proving_key
* @param {Uint8Array} accumulated
* @returns {Uint8Array}
*/
export function generateAccumulatorMembershipStatementFromParamRefs(params: number, public_key: number, proving_key: number, accumulated: Uint8Array): Uint8Array;
/**
* @param {Uint8Array} params
* @param {Uint8Array} public_key
* @param {Uint8Array} proving_key
* @param {Uint8Array} accumulated
* @returns {Uint8Array}
*/
export function generateAccumulatorNonMembershipStatement(params: Uint8Array, public_key: Uint8Array, proving_key: Uint8Array, accumulated: Uint8Array): Uint8Array;
/**
* @param {number} params
* @param {number} public_key
* @param {number} proving_key
* @param {Uint8Array} accumulated
* @returns {Uint8Array}
*/
export function generateAccumulatorNonMembershipStatementFromParamRefs(params: number, public_key: number, proving_key: number, accumulated: Uint8Array): Uint8Array;
/**
* @param {Array<any>} commitment_key
* @param {Uint8Array} commitment
* @returns {Uint8Array}
*/
export function generatePedersenCommitmentG1Statement(commitment_key: Array<any>, commitment: Uint8Array): Uint8Array;
/**
* @param {number} commitment_key
* @param {Uint8Array} commitment
* @returns {Uint8Array}
*/
export function generatePedersenCommitmentG1StatementFromParamRefs(commitment_key: number, commitment: Uint8Array): Uint8Array;
/**
* @param {Array<any>} commitment_key
* @param {Uint8Array} commitment
* @returns {Uint8Array}
*/
export function generatePedersenCommitmentG2Statement(commitment_key: Array<any>, commitment: Uint8Array): Uint8Array;
/**
* @param {number} commitment_key
* @param {Uint8Array} commitment
* @returns {Uint8Array}
*/
export function generatePedersenCommitmentG2StatementFromParamRefs(commitment_key: number, commitment: Uint8Array): Uint8Array;
/**
* @param {Set<any>} equality
* @returns {any}
*/
export function generateWitnessEqualityMetaStatement(equality: Set<any>): any;
/**
* @param {number} chunk_bit_size
* @param {Uint8Array} enc_gens
* @param {Uint8Array} chunked_comm_gens
* @param {Uint8Array} encryption_key
* @param {Uint8Array} snark_pk
* @param {boolean} uncompressed_public_params
* @returns {Uint8Array}
*/
export function generateSaverProverStatement(chunk_bit_size: number, enc_gens: Uint8Array, chunked_comm_gens: Uint8Array, encryption_key: Uint8Array, snark_pk: Uint8Array, uncompressed_public_params: boolean): Uint8Array;
/**
* @param {number} chunk_bit_size
* @param {number} enc_gens
* @param {number} chunked_comm_gens
* @param {number} encryption_key
* @param {number} snark_pk
* @returns {Uint8Array}
*/
export function generateSaverProverStatementFromParamRefs(chunk_bit_size: number, enc_gens: number, chunked_comm_gens: number, encryption_key: number, snark_pk: number): Uint8Array;
/**
* @param {number} chunk_bit_size
* @param {Uint8Array} enc_gens
* @param {Uint8Array} chunked_comm_gens
* @param {Uint8Array} encryption_key
* @param {Uint8Array} snark_vk
* @param {boolean} uncompressed_public_params
* @returns {Uint8Array}
*/
export function generateSaverVerifierStatement(chunk_bit_size: number, enc_gens: Uint8Array, chunked_comm_gens: Uint8Array, encryption_key: Uint8Array, snark_vk: Uint8Array, uncompressed_public_params: boolean): Uint8Array;
/**
* @param {number} chunk_bit_size
* @param {number} enc_gens
* @param {number} chunked_comm_gens
* @param {number} encryption_key
* @param {number} snark_vk
* @returns {Uint8Array}
*/
export function generateSaverVerifierStatementFromParamRefs(chunk_bit_size: number, enc_gens: number, chunked_comm_gens: number, encryption_key: number, snark_vk: number): Uint8Array;
/**
* If `uncompressed` is true, expects the legosnark proving key to be in uncompressed form else
* it should be compressed.
* @param {number} min
* @param {number} max
* @param {Uint8Array} snark_pk
* @param {boolean} uncompressed_public_params
* @returns {Uint8Array}
*/
export function generateBoundCheckLegoProverStatement(min: number, max: number, snark_pk: Uint8Array, uncompressed_public_params: boolean): Uint8Array;
/**
* @param {number} min
* @param {number} max
* @param {number} snark_pk
* @returns {Uint8Array}
*/
export function generateBoundCheckLegoProverStatementFromParamRefs(min: number, max: number, snark_pk: number): Uint8Array;
/**
* If `uncompressed` is true, expects the legosnark verifying key to be in uncompressed form else
* it should be compressed.
* @param {number} min
* @param {number} max
* @param {Uint8Array} snark_vk
* @param {boolean} uncompressed_public_params
* @returns {Uint8Array}
*/
export function generateBoundCheckLegoVerifierStatement(min: number, max: number, snark_vk: Uint8Array, uncompressed_public_params: boolean): Uint8Array;
/**
* @param {number} min
* @param {number} max
* @param {number} snark_vk
* @returns {Uint8Array}
*/
export function generateBoundCheckLegoVerifierStatementFromParamRefs(min: number, max: number, snark_vk: number): Uint8Array;
/**
* @param {string} curve_name
* @param {number} num_public
* @param {number} num_private
* @param {Array<any>} constraints
* @param {Uint8Array} wasm_bytes
* @param {Uint8Array} snark_pk
* @param {boolean} uncompressed_public_params
* @returns {Uint8Array}
*/
export function generateR1CSCircomProverStatement(curve_name: string, num_public: number, num_private: number, constraints: Array<any>, wasm_bytes: Uint8Array, snark_pk: Uint8Array, uncompressed_public_params: boolean): Uint8Array;
/**
* @param {number} r1cs
* @param {number} wasm_bytes
* @param {number} snark_pk
* @returns {Uint8Array}
*/
export function generateR1CSCircomProverStatementFromParamRefs(r1cs: number, wasm_bytes: number, snark_pk: number): Uint8Array;
/**
* @param {Array<any>} public_inputs
* @param {Uint8Array} snark_vk
* @param {boolean} uncompressed_public_params
* @returns {Uint8Array}
*/
export function generateR1CSCircomVerifierStatement(public_inputs: Array<any>, snark_vk: Uint8Array, uncompressed_public_params: boolean): Uint8Array;
/**
* @param {number} public_inputs
* @param {number} snark_vk
* @returns {Uint8Array}
*/
export function generateR1CSCircomVerifierStatementFromParamRefs(public_inputs: number, snark_vk: number): Uint8Array;
/**
* @param {Uint8Array} wasm_bytes
* @param {Map<any, any>} input_wires
* @returns {Array<any>}
*/
export function r1csGenerateWires(wasm_bytes: Uint8Array, input_wires: Map<any, any>): Array<any>;
/**
* @param {string} curve_name
* @param {number} num_public
* @param {number} num_private
* @param {Array<any>} constraints
* @param {Uint8Array} wasm_bytes
* @param {Map<any, any>} input_wires
* @returns {boolean}
*/
export function r1csCircuitSatisfied(curve_name: string, num_public: number, num_private: number, constraints: Array<any>, wasm_bytes: Uint8Array, input_wires: Map<any, any>): boolean;
/**
* @param {string} curve_name
* @param {number} num_public
* @param {number} num_private
* @param {Array<any>} constraints
* @param {number} commit_witness_count
* @param {boolean} return_uncompressed
* @returns {Uint8Array}
*/
export function r1csSnarkSetup(curve_name: string, num_public: number, num_private: number, constraints: Array<any>, commit_witness_count: number, return_uncompressed: boolean): Uint8Array;
/**
* A struct representing an aborted instruction execution, with a message
* indicating the cause.
*/
export class WasmerRuntimeError {
  free(): void;
}

export type InitInput = RequestInfo | URL | Response | BufferSource | WebAssembly.Module;

export interface InitOutput {
  readonly memory: WebAssembly.Memory;
  readonly saverGenerateEncryptionGenerators: (a: number, b: number, c: number) => void;
  readonly saverGenerateChunkedCommitmentGenerators: (a: number, b: number, c: number) => void;
  readonly saverDecryptorSetup: (a: number, b: number, c: number, d: number) => void;
  readonly saverDecompressEncryptionGenerators: (a: number, b: number) => void;
  readonly saverDecompressChunkedCommitmentGenerators: (a: number, b: number) => void;
  readonly saverDecompressEncryptionKey: (a: number, b: number) => void;
  readonly saverDecompressDecryptionKey: (a: number, b: number) => void;
  readonly saverDecompressSnarkPk: (a: number, b: number) => void;
  readonly saverGetSnarkVkFromPk: (a: number, b: number, c: number) => void;
  readonly saverDecompressSnarkVk: (a: number, b: number) => void;
  readonly saverDecryptCiphertextUsingSnarkVk: (a: number, b: number, c: number, d: number, e: number, f: number, g: number) => void;
  readonly saverDecryptCiphertextUsingSnarkPk: (a: number, b: number, c: number, d: number, e: number, f: number, g: number) => void;
  readonly saverVerifyDecryptionUsingSnarkVk: (a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number, i: number) => void;
  readonly saverVerifyDecryptionUsingSnarkPk: (a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number, i: number) => void;
  readonly generateRandomG1Element: (a: number, b: number, c: number) => void;
  readonly generateRandomG2Element: (a: number, b: number, c: number) => void;
  readonly generateRandomFieldElement: (a: number, b: number, c: number) => void;
  readonly generateFieldElementFromNumber: (a: number, b: number) => void;
  readonly generateChallengeFromBytes: (a: number, b: number) => number;
  readonly fieldElementAsBytes: (a: number, b: number, c: number) => void;
  readonly pedersenCommitmentG1: (a: number, b: number, c: number) => void;
  readonly pedersenCommitmentG2: (a: number, b: number, c: number) => void;
  readonly generateFieldElementFromBytes: (a: number, b: number) => number;
  readonly generateSignatureParamsG1: (a: number, b: number, c: number, d: number) => void;
  readonly isSignatureParamsG1Valid: (a: number, b: number) => void;
  readonly bbsSignatureParamsG1MaxSupportedMsgs: (a: number, b: number) => void;
  readonly generateSignatureParamsG2: (a: number, b: number, c: number, d: number) => void;
  readonly isSignatureParamsG2Valid: (a: number, b: number) => void;
  readonly bbsSignatureParamsG2MaxSupportedMsgs: (a: number, b: number) => void;
  readonly bbsSignatureParamsG1ToBytes: (a: number, b: number) => void;
  readonly bbsSignatureParamsG1FromBytes: (a: number, b: number) => void;
  readonly bbsSignatureParamsG2ToBytes: (a: number, b: number) => void;
  readonly bbsSignatureParamsG2FromBytes: (a: number, b: number) => void;
  readonly generateBBSSigningKey: (a: number, b: number, c: number) => void;
  readonly generateBBSPublicKeyG1: (a: number, b: number, c: number) => void;
  readonly isBBSPublicKeyG1Valid: (a: number, b: number) => void;
  readonly generateBBSPublicKeyG2: (a: number, b: number, c: number) => void;
  readonly isBBSPublicKeyG2Valid: (a: number, b: number) => void;
  readonly generateBBSKeyPairG1: (a: number, b: number, c: number, d: number) => void;
  readonly generateBBSKeyPairG2: (a: number, b: number, c: number, d: number) => void;
  readonly bbsGetBasesForCommitmentG1: (a: number, b: number, c: number) => void;
  readonly bbsGetBasesForCommitmentG2: (a: number, b: number, c: number) => void;
  readonly bbsEncodeMessageForSigning: (a: number, b: number, c: number) => void;
  readonly bbsEncodeMessagesForSigning: (a: number, b: number, c: number) => void;
  readonly bbsCommitMsgsInG1: (a: number, b: number, c: number, d: number, e: number) => void;
  readonly bbsCommitMsgsInG2: (a: number, b: number, c: number, d: number, e: number) => void;
  readonly bbsSignG1: (a: number, b: number, c: number, d: number, e: number) => void;
  readonly bbsBlindSignG1: (a: number, b: number, c: number, d: number, e: number, f: number) => void;
  readonly bbsUnblindSigG1: (a: number, b: number, c: number) => void;
  readonly bbsVerifyG1: (a: number, b: number, c: number, d: number, e: number, f: number) => void;
  readonly bbsSignG2: (a: number, b: number, c: number, d: number, e: number) => void;
  readonly bbsBlindSignG2: (a: number, b: number, c: number, d: number, e: number, f: number) => void;
  readonly bbsUnblindSigG2: (a: number, b: number, c: number) => void;
  readonly bbsVerifyG2: (a: number, b: number, c: number, d: number, e: number, f: number) => void;
  readonly bbsInitializeProofOfKnowledgeOfSignature: (a: number, b: number, c: number, d: number, e: number, f: number, g: number) => void;
  readonly bbsGenProofOfKnowledgeOfSignature: (a: number, b: number, c: number) => void;
  readonly bbsVerifyProofOfKnowledgeOfSignature: (a: number, b: number, c: number, d: number, e: number, f: number, g: number) => void;
  readonly bbsChallengeContributionFromProtocol: (a: number, b: number, c: number, d: number, e: number) => void;
  readonly bbsChallengeContributionFromProof: (a: number, b: number, c: number, d: number, e: number) => void;
  readonly bbsAdaptSigParamsG1ForMsgCount: (a: number, b: number, c: number, d: number) => void;
  readonly bbsAdaptSigParamsG2ForMsgCount: (a: number, b: number, c: number, d: number) => void;
  readonly generatePoKBBSSignatureWitness: (a: number, b: number, c: number, d: number) => void;
  readonly generateAccumulatorMembershipWitness: (a: number, b: number, c: number) => void;
  readonly generateAccumulatorNonMembershipWitness: (a: number, b: number, c: number) => void;
  readonly generatePedersenCommitmentWitness: (a: number, b: number) => void;
  readonly generateProofSpecG1: (a: number, b: number, c: number, d: number, e: number, f: number) => void;
  readonly isProofSpecG1Valid: (a: number, b: number) => void;
  readonly generateProofSpecG2: (a: number, b: number, c: number, d: number, e: number, f: number) => void;
  readonly isProofSpecG2Valid: (a: number, b: number) => void;
  readonly generateCompositeProofG1: (a: number, b: number, c: number, d: number, e: number) => void;
  readonly generateCompositeProofG2: (a: number, b: number, c: number, d: number, e: number) => void;
  readonly generateCompositeProofG1WithDeconstructedProofSpec: (a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number, i: number) => void;
  readonly verifyCompositeProofG1: (a: number, b: number, c: number, d: number, e: number) => void;
  readonly verifyCompositeProofG2: (a: number, b: number, c: number, d: number, e: number) => void;
  readonly verifyCompositeProofG1WithDeconstructedProofSpec: (a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number, i: number) => void;
  readonly generateSaverWitness: (a: number, b: number) => void;
  readonly saverGetCiphertextFromProof: (a: number, b: number, c: number) => void;
  readonly saverGetCiphertextsFromProof: (a: number, b: number, c: number, d: number) => void;
  readonly generateBoundCheckWitness: (a: number, b: number) => void;
  readonly generateR1CSCircomWitness: (a: number, b: number, c: number, d: number) => void;
  readonly legosnarkDecompressPk: (a: number, b: number) => void;
  readonly legosnarkVkFromPk: (a: number, b: number, c: number) => void;
  readonly legosnarkDecompressVk: (a: number, b: number) => void;
  readonly generateAccumulatorParams: (a: number, b: number, c: number) => void;
  readonly isAccumulatorParamsValid: (a: number, b: number) => void;
  readonly generateAccumulatorSecretKey: (a: number, b: number, c: number) => void;
  readonly generateAccumulatorPublicKey: (a: number, b: number, c: number) => void;
  readonly isAccumulatorPublicKeyValid: (a: number, b: number) => void;
  readonly generateAccumulatorKeyPair: (a: number, b: number, c: number, d: number) => void;
  readonly accumulatorGetElementFromBytes: (a: number, b: number, c: number) => void;
  readonly positiveAccumulatorInitialize: (a: number, b: number) => void;
  readonly positiveAccumulatorGetAccumulated: (a: number, b: number) => void;
  readonly positiveAccumulatorAdd: (a: number, b: number, c: number, d: number) => void;
  readonly positiveAccumulatorRemove: (a: number, b: number, c: number, d: number) => void;
  readonly positiveAccumulatorMembershipWitness: (a: number, b: number, c: number, d: number) => void;
  readonly positiveAccumulatorVerifyMembership: (a: number, b: number, c: number, d: number, e: number, f: number) => void;
  readonly universalAccumulatorFixedInitialElements: (a: number) => void;
  readonly universalAccumulatorComputeInitialFv: (a: number, b: number, c: number) => void;
  readonly universalAccumulatorCombineMultipleInitialFv: (a: number, b: number) => void;
  readonly universalAccumulatorInitialiseGivenFv: (a: number, b: number, c: number, d: number) => void;
  readonly universalAccumulatorGetAccumulated: (a: number, b: number) => void;
  readonly universalAccumulatorAdd: (a: number, b: number, c: number, d: number) => void;
  readonly universalAccumulatorRemove: (a: number, b: number, c: number, d: number) => void;
  readonly universalAccumulatorMembershipWitness: (a: number, b: number, c: number, d: number) => void;
  readonly universalAccumulatorVerifyMembership: (a: number, b: number, c: number, d: number, e: number, f: number) => void;
  readonly universalAccumulatorComputeD: (a: number, b: number, c: number) => void;
  readonly universalAccumulatorCombineMultipleD: (a: number, b: number) => void;
  readonly universalAccumulatorNonMembershipWitness: (a: number, b: number, c: number, d: number, e: number, f: number) => void;
  readonly universalAccumulatorVerifyNonMembership: (a: number, b: number, c: number, d: number, e: number, f: number) => void;
  readonly positiveAccumulatorAddBatch: (a: number, b: number, c: number, d: number) => void;
  readonly positiveAccumulatorRemoveBatch: (a: number, b: number, c: number, d: number) => void;
  readonly positiveAccumulatorBatchUpdates: (a: number, b: number, c: number, d: number, e: number) => void;
  readonly positiveAccumulatorMembershipWitnessesForBatch: (a: number, b: number, c: number, d: number) => void;
  readonly universalAccumulatorAddBatch: (a: number, b: number, c: number, d: number) => void;
  readonly universalAccumulatorRemoveBatch: (a: number, b: number, c: number, d: number) => void;
  readonly universalAccumulatorBatchUpdates: (a: number, b: number, c: number, d: number, e: number) => void;
  readonly universalAccumulatorMembershipWitnessesForBatch: (a: number, b: number, c: number, d: number) => void;
  readonly universalAccumulatorComputeDForBatch: (a: number, b: number, c: number) => void;
  readonly universalAccumulatorCombineMultipleDForBatch: (a: number, b: number) => void;
  readonly universalAccumulatorNonMembershipWitnessesForBatch: (a: number, b: number, c: number, d: number, e: number, f: number) => void;
  readonly updateMembershipWitnessPostAdd: (a: number, b: number, c: number, d: number, e: number) => void;
  readonly updateMembershipWitnessPostRemove: (a: number, b: number, c: number, d: number, e: number) => void;
  readonly updateNonMembershipWitnessPostAdd: (a: number, b: number, c: number, d: number, e: number) => void;
  readonly updateNonMembershipWitnessPostRemove: (a: number, b: number, c: number, d: number, e: number) => void;
  readonly updateMembershipWitnessesPostBatchUpdates: (a: number, b: number, c: number, d: number, e: number, f: number, g: number) => void;
  readonly updateNonMembershipWitnessesPostBatchUpdates: (a: number, b: number, c: number, d: number, e: number, f: number, g: number) => void;
  readonly publicInfoForWitnessUpdate: (a: number, b: number, c: number, d: number, e: number) => void;
  readonly updateMembershipWitnessUsingPublicInfoAfterBatchUpdate: (a: number, b: number, c: number, d: number, e: number, f: number) => void;
  readonly updateMembershipWitnessUsingPublicInfoAfterMultipleBatchUpdates: (a: number, b: number, c: number, d: number, e: number, f: number) => void;
  readonly updateNonMembershipWitnessUsingPublicInfoAfterBatchUpdate: (a: number, b: number, c: number, d: number, e: number, f: number) => void;
  readonly updateNonMembershipWitnessUsingPublicInfoAfterMultipleBatchUpdates: (a: number, b: number, c: number, d: number, e: number, f: number) => void;
  readonly generateMembershipProvingKey: (a: number, b: number, c: number) => void;
  readonly generateNonMembershipProvingKey: (a: number, b: number, c: number) => void;
  readonly accumulatorDeriveMembershipProvingKeyFromNonMembershipKey: (a: number, b: number) => void;
  readonly accumulatorInitializeMembershipProof: (a: number, b: number, c: number, d: number, e: number, f: number, g: number) => void;
  readonly accumulatorGenMembershipProof: (a: number, b: number, c: number) => void;
  readonly accumulatorVerifyMembershipProof: (a: number, b: number, c: number, d: number, e: number, f: number, g: number) => void;
  readonly accumulatorChallengeContributionFromMembershipProtocol: (a: number, b: number, c: number, d: number, e: number, f: number) => void;
  readonly accumulatorChallengeContributionFromMembershipProof: (a: number, b: number, c: number, d: number, e: number, f: number) => void;
  readonly accumulatorInitializeNonMembershipProof: (a: number, b: number, c: number, d: number, e: number, f: number, g: number) => void;
  readonly accumulatorGenNonMembershipProof: (a: number, b: number, c: number) => void;
  readonly accumulatorVerifyNonMembershipProof: (a: number, b: number, c: number, d: number, e: number, f: number, g: number) => void;
  readonly accumulatorChallengeContributionFromNonMembershipProtocol: (a: number, b: number, c: number, d: number, e: number, f: number) => void;
  readonly accumulatorChallengeContributionFromNonMembershipProof: (a: number, b: number, c: number, d: number, e: number, f: number) => void;
  readonly generateSetupParamForBBSSignatureParametersG1: (a: number, b: number) => void;
  readonly generateSetupParamForBBSPublicKeyG2: (a: number, b: number) => void;
  readonly generateSetupParamForVbAccumulatorParams: (a: number, b: number) => void;
  readonly generateSetupParamForVbAccumulatorPublicKey: (a: number, b: number) => void;
  readonly generateSetupParamForVbAccumulatorMemProvingKey: (a: number, b: number) => void;
  readonly generateSetupParamForVbAccumulatorNonMemProvingKey: (a: number, b: number) => void;
  readonly generateSetupParamForPedersenCommitmentKeyG1: (a: number, b: number) => void;
  readonly generateSetupParamForPedersenCommitmentKeyG2: (a: number, b: number) => void;
  readonly generateSetupParamForSaverEncryptionGens: (a: number, b: number, c: number) => void;
  readonly generateSetupParamForSaverCommitmentGens: (a: number, b: number, c: number) => void;
  readonly generateSetupParamForSaverEncryptionKey: (a: number, b: number, c: number) => void;
  readonly generateSetupParamForSaverProvingKey: (a: number, b: number, c: number) => void;
  readonly generateSetupParamForSaverVerifyingKey: (a: number, b: number, c: number) => void;
  readonly generateSetupParamForLegoProvingKey: (a: number, b: number, c: number) => void;
  readonly generateSetupParamForLegoVerifyingKey: (a: number, b: number, c: number) => void;
  readonly generateSetupParamForR1CS: (a: number, b: number, c: number, d: number, e: number, f: number) => void;
  readonly generateSetupParamForBytes: (a: number, b: number) => void;
  readonly generateSetupParamForFieldElemVec: (a: number, b: number) => void;
  readonly boundCheckSnarkSetup: (a: number, b: number) => void;
  readonly generatePoKBBSSignatureStatement: (a: number, b: number, c: number, d: number, e: number) => void;
  readonly generatePoKBBSSignatureStatementFromParamRefs: (a: number, b: number, c: number, d: number, e: number) => void;
  readonly generateAccumulatorMembershipStatement: (a: number, b: number, c: number, d: number, e: number) => void;
  readonly generateAccumulatorMembershipStatementFromParamRefs: (a: number, b: number, c: number, d: number, e: number) => void;
  readonly generateAccumulatorNonMembershipStatement: (a: number, b: number, c: number, d: number, e: number) => void;
  readonly generateAccumulatorNonMembershipStatementFromParamRefs: (a: number, b: number, c: number, d: number, e: number) => void;
  readonly generatePedersenCommitmentG1Statement: (a: number, b: number, c: number) => void;
  readonly generatePedersenCommitmentG1StatementFromParamRefs: (a: number, b: number, c: number) => void;
  readonly generatePedersenCommitmentG2Statement: (a: number, b: number, c: number) => void;
  readonly generatePedersenCommitmentG2StatementFromParamRefs: (a: number, b: number, c: number) => void;
  readonly generateWitnessEqualityMetaStatement: (a: number, b: number) => void;
  readonly generateSaverProverStatement: (a: number, b: number, c: number, d: number, e: number, f: number, g: number) => void;
  readonly generateSaverProverStatementFromParamRefs: (a: number, b: number, c: number, d: number, e: number, f: number) => void;
  readonly generateSaverVerifierStatement: (a: number, b: number, c: number, d: number, e: number, f: number, g: number) => void;
  readonly generateSaverVerifierStatementFromParamRefs: (a: number, b: number, c: number, d: number, e: number, f: number) => void;
  readonly generateBoundCheckLegoProverStatement: (a: number, b: number, c: number, d: number, e: number) => void;
  readonly generateBoundCheckLegoProverStatementFromParamRefs: (a: number, b: number, c: number, d: number) => void;
  readonly generateBoundCheckLegoVerifierStatement: (a: number, b: number, c: number, d: number, e: number) => void;
  readonly generateBoundCheckLegoVerifierStatementFromParamRefs: (a: number, b: number, c: number, d: number) => void;
  readonly generateR1CSCircomProverStatement: (a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number, i: number) => void;
  readonly generateR1CSCircomProverStatementFromParamRefs: (a: number, b: number, c: number, d: number) => void;
  readonly generateR1CSCircomVerifierStatement: (a: number, b: number, c: number, d: number) => void;
  readonly generateR1CSCircomVerifierStatementFromParamRefs: (a: number, b: number, c: number) => void;
  readonly r1csGenerateWires: (a: number, b: number, c: number) => void;
  readonly r1csCircuitSatisfied: (a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number) => void;
  readonly r1csSnarkSetup: (a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number) => void;
  readonly __wbg_wasmerruntimeerror_free: (a: number) => void;
  readonly __wbindgen_malloc: (a: number) => number;
  readonly __wbindgen_realloc: (a: number, b: number, c: number) => number;
  readonly __wbindgen_export_2: WebAssembly.Table;
  readonly __wbindgen_add_to_stack_pointer: (a: number) => number;
  readonly __wbindgen_exn_store: (a: number) => void;
}

export type SyncInitInput = BufferSource | WebAssembly.Module;
/**
* Instantiates the given `module`, which can either be bytes or
* a precompiled `WebAssembly.Module`.
*
* @param {SyncInitInput} module
*
* @returns {InitOutput}
*/
export function initSync(module: SyncInitInput): InitOutput;

/**
* If `module_or_path` is {RequestInfo} or {URL}, makes a request and
* for everything else, calls `WebAssembly.instantiate` directly.
*
* @param {InitInput | Promise<InitInput>} module_or_path
*
* @returns {Promise<InitOutput>}
*/
export default function init (module_or_path?: InitInput | Promise<InitInput>): Promise<InitOutput>;
